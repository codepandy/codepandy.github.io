<!DOCTYPE html><html lang="[&quot;zh-Hans&quot;,&quot;zh-CN&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="从基础到实战 手把手带你掌握新版Webpack4.0-2"><meta name="keywords" content="webpack"><meta name="author" content="wenmu"><meta name="copyright" content="wenmu"><title>从基础到实战 手把手带你掌握新版Webpack4.0-2 | 温木的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=66523541&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#css-进行代码分割"><span class="toc-number">1.</span> <span class="toc-text">css 进行代码分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filename-和-chunkFileName-的区别"><span class="toc-number">2.</span> <span class="toc-text">filename 和 chunkFileName 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shimming"><span class="toc-number">3.</span> <span class="toc-text">Shimming</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模块中的-this-指向-window"><span class="toc-number">3.1.</span> <span class="toc-text">模块中的 this 指向 window</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打包分析"><span class="toc-number">4.</span> <span class="toc-text">打包分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看-js-代码使用率"><span class="toc-number">5.</span> <span class="toc-text">查看 js 代码使用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prefetching"><span class="toc-number">6.</span> <span class="toc-text">prefetching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根据文件内容命名文件"><span class="toc-number">7.</span> <span class="toc-text">根据文件内容命名文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#library"><span class="toc-number">8.</span> <span class="toc-text">library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#外部化"><span class="toc-number">8.1.</span> <span class="toc-text">外部化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#支持多种方式访问包"><span class="toc-number">8.2.</span> <span class="toc-text">支持多种方式访问包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指定包的执行文件"><span class="toc-number">8.3.</span> <span class="toc-text">指定包的执行文件</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://sm.ms/image/xwaBoOj158MfNyq"></div><div class="author-info__name text-center">wenmu</div><div class="author-info__description text-center">记录一些在工作中或学习新知识时学到的一些知识点；正所谓好记性不如一个烂笔头，温故而知新！</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">41</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">20</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">温木的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">从基础到实战 手把手带你掌握新版Webpack4.0-2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/webpack/">webpack</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>###懒加载和 chunk 是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">'/* webpackChunkName:"lodash" */ lodash'</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    element.innnerHTML = _.join([<span class="string">"Hello"</span>, <span class="string">"Every"</span>, <span class="string">"One"</span>], <span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当点击页面时才加载lodash</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在页面加载时，上面的代码所依赖的<code>lodash</code>模块是不会被加载的，可以查看请求记录，只有当点击页面时，<code>lodash</code>被打的包才会被加载 。 这就是懒加载。（注意上面的语法）</p>
<blockquote>
<p>懒加载实际上是 ES6 的概念，不是 webpack 的，只是 webpack 支持这个语法而已。</p>
</blockquote>
<h3 id="css-进行代码分割"><a href="#css-进行代码分割" class="headerlink" title="css 进行代码分割"></a>css 进行代码分割</h3><p>使用<code>mini-css-extract-plugin</code>插件，注意修改 tree shaking 的配置。比如<code>sideEffects:[&quot;*.css&quot;]</code></p>
<p>如果想把多个入口的 css 打包到同一个文件中，或者分开打包，都需要参考 cacheGroup,参考官网配置。</p>
<h3 id="filename-和-chunkFileName-的区别"><a href="#filename-和-chunkFileName-的区别" class="headerlink" title="filename 和 chunkFileName 的区别"></a>filename 和 chunkFileName 的区别</h3><p>如果生成的文件是被入口 index.html 文件直接引用的，则使用 filename 指定的规则，如果是被其他模块引用的文件也就是二级引用则走 chunkFileName 规则。</p>
<h3 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h3><p>这个意思就是“垫片”，什么是垫片呢，举个例子；<br>比如你引入了一个第三方的模块 A，他依赖 jquery，但是它本身自己没有对 jquery 的引用，虽然你在自己的项目安装也引用了 jquery，但是由于 webpack 打包是基于模块的，A 是无法使用项目中引入的 jquery 的，但是第三方安装包，我们又不能改代码，Shimming 就是来解决这个问题的。<br>这需要用到<code>webpack</code>的<code>ProvidePlugin</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    <span class="comment">// 这个指定，只要有用到$的地方，就在这个使用的模块中引入jquery，并命名成$</span></span><br><span class="line">    $: <span class="string">"jquery"</span>,</span><br><span class="line">    <span class="comment">// 把lodash中的join方法打包成_join，这样也就可以在代码中直接使用了。</span></span><br><span class="line">    _join: [<span class="string">"lodash"</span>, <span class="string">"join"</span>],</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="模块中的-this-指向-window"><a href="#模块中的-this-指向-window" class="headerlink" title="模块中的 this 指向 window"></a>模块中的 this 指向 window</h4><blockquote>
<p>模块中的 this 指向模块本身<br>使用<code>imports-loader</code>可以轻松做到这个。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"babel-loader"</span> &#125;,</span><br><span class="line">      <span class="comment">// 加上下面的配置,模块中的this就指向window了</span></span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"imports-loader?this=&gt;window"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>这也是<code>shimming</code>的一种</p>
<h3 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h3><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis" target="_blank" rel="noopener">参考官网介绍</a><br><a href="https://www.webpackjs.com/guides/code-splitting/#bundle-%E5%88%86%E6%9E%90-bundle-analysis-" target="_blank" rel="noopener">中文版</a><br>也可以参考《项目性能和规范总结》一文中的介绍。<br>官网给了多种分析方式，其中一种是<a href="https://github.com/webpack/analyse" target="_blank" rel="noopener">官方分析工具</a>，这个比较简单，直接在 webpack 的 bu 打包生产环境的命令中传几个参数即可。<code>--profile --json &gt; stats.json</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">      "build":"webpack --profile --json &gt; stats.json --config webpack.pro.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样打包后会有一个<code>stats.json</code>文件，打开这个工具提供的<a href="http://webpack.github.com/analyse" target="_blank" rel="noopener">分析网站</a>，把生成的<code>stats.json</code>文件上传，就会生成界面化的分析结果。</p>
<h3 id="查看-js-代码使用率"><a href="#查看-js-代码使用率" class="headerlink" title="查看 js 代码使用率"></a>查看 js 代码使用率</h3><p>在 chrome 浏览器的开发者工具中，在下面窗口的<code>Coverage</code>窗口中可以录制代码的使用率，并且打开代码也可以看到哪些代码使用了，哪些代码没使用到，这样可以有针对性的把第一次没有用到的代码使用动态加载的方式来做，提高效率。</p>
<h3 id="prefetching"><a href="#prefetching" class="headerlink" title="prefetching"></a>prefetching</h3><p>在官网的概念模块讲解了 prefetching 的概念，这个就是当访问页面时，主文件先下载，等主要文件下载完了，线程有空闲了再下载<code>prefetching</code>的文件。<br>这个需要和懒加载一起使用，通过注释的方式来指定是否<code>prefetching</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">"LoginModal"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="根据文件内容命名文件"><a href="#根据文件内容命名文件" class="headerlink" title="根据文件内容命名文件"></a>根据文件内容命名文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>webpack4 之前的版本需要配置 runtime；老版本因为把 manifest 打包到了各个 chunk 中，所以老版本的 webpack 打包，即使内容没改变，打出的包的名字 hash 也可能不一样，因为 manifest 可能发生了变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">"runtime"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="library"><a href="#library" class="headerlink" title="library"></a>library</h3><p>当开发一个工具包时，我们也可以通过 webpack 进行打包，并发布到 npm 仓库中。<br>配置很简单，和常用的配置差别不大，甚至没那么复杂。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"webpack-numbers.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的配置就已经做完了，这样就可以进行打包了。但是可以从以下几个方面进行优化会更好：</p>
<ol>
<li>外部化 lodash</li>
<li>支持多种方式访问包，比如 amd，cmd，es6 等等</li>
<li>把包暴露给指定的全局变量</li>
<li>指定包的执行文件</li>
<li>发布到 npm 仓库</li>
</ol>
<h4 id="外部化"><a href="#外部化" class="headerlink" title="外部化"></a>外部化</h4><p>首先介绍下什么是外部化：外部化就是使用用户环境中的第三方库，而不是把第三方库打包到我们的包中。<br>比如我们开发一个数字处理的工具包 A，我们的代码中用到了<code>lodash</code>、<code>moment</code>等等多种第三方包，如果不做外部化处理，这些在代码中用到的第三方包都会和我们的逻辑代码一起进行打包。这就有个问题，使用我们包 A 的用户的项目中如果也用到了<code>lodash</code>、<code>moment</code>,那就会出现重复的打包。<br>因此在我们的开发包 A 中不对这些第三方的包进行打包，而是让使用我们包 A 的用户去安装我们依赖的这些包，然后使用包 A 的地方也引入包 A 所依赖的包即可；<br>实现这个功能需要用到<code>externals</code>的配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  lodash: &#123;</span><br><span class="line">    commonjs: 'lodash', // 指定在commonjs环境下引入lodash的名字</span><br><span class="line">    commonjs2: 'lodash',</span><br><span class="line">    amd: 'lodash',</span><br><span class="line">    root: '_', // script标签引入lodash的变量名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们虽然使用了 lodash，但 lodash 不会被打包到包 A 中。</p>
<h4 id="支持多种方式访问包"><a href="#支持多种方式访问包" class="headerlink" title="支持多种方式访问包"></a>支持多种方式访问包</h4><p>我们的包打包后，应该支持 amd、cmd、es6 以及在文件中引入等方式的使用。实现这个功能也很简单，配置<code>output</code>属性的<code>library</code>和<code>libraryTarget</code>即可。具体的参数可参见官网上的详细介绍</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, 'dist'),</span><br><span class="line">  filename: 'webpack-numbers.js',</span><br><span class="line">  library: 'myLibrary',// 通过配置这个，可以让通过script标签的方式引入，通过全局变量myLibrary来访问</span><br><span class="line">  libraryTarget: 'umd'</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>libraryTarget 的值不同，包可被访问的方式就不同。</p>
<ul>
<li>变量：默认值。作为一个全局变量，通过 script 标签来访问（libraryTarget:’var’），需要配置 library 属性来指定变量的名字。</li>
<li>this：通过 this 对象访问（libraryTarget:’this’）。</li>
<li>window：通过 window 对象访问，在浏览器中（libraryTarget:’window’）。</li>
<li>UMD：在 AMD 或 CommonJS 的 require 之后可访问（libraryTarget:’umd’）。<blockquote>
<p>只配置<code>libraryTarget</code>不支持通过 script 标签的方式引入。</p>
</blockquote>
</li>
</ul>
<h4 id="指定包的执行文件"><a href="#指定包的执行文件" class="headerlink" title="指定包的执行文件"></a>指定包的执行文件</h4><p>当别人使用我们的包时，加载的是哪个文件可以在 package.json 中的 main 字段进行配置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main: "./dist/webpack-numbers.js";</span><br></pre></td></tr></table></figure>

<p>####发布到 npm 仓库<br>首先需要在 npm 官网上有一个账号。在命令行中运行<code>npm adduser</code>，然后输入用户名和密码，接着运行发布命令<code>npm publish</code>，这样你的 npm 包就发送完成了，包名就是 package.json 中 name 指定的名字。<code>npm install 包名</code>就可以安装了。</p>
<blockquote>
<p>动态链接库用的也是这块的功能。</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wenmu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-2/">http://yoursite.com/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">温木的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/webpack/">webpack</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://sm.ms/image/hOBzIxFDJMCrmtN"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/01/09/webpack%E7%9A%84code%20splitting%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/"><i class="fa fa-chevron-left">  </i><span>webpack的code splitting和懒加载</span></a></div><div class="next-post pull-right"><a href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-3/"><span>从基础到实战 手把手带你掌握新版Webpack4.0-3</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By wenmu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>