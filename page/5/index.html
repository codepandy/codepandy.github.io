<!DOCTYPE html><html lang="[&quot;zh-Hans&quot;,&quot;zh-CN&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="记录一些在工作中或学习新知识时学到的一些知识点；正所谓好记性不如一个烂笔头，温故而知新！"><meta name="keywords" content=""><meta name="author" content="wenmu"><meta name="copyright" content="wenmu"><title>技术的积累 | 温木的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://thumbnail0.baidupcs.com/thumbnail/ea5429806p23c6a153c0b44981506b2f?fid=1259130490-250528-341140853690276&amp;time=1578463200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Kd6VOtTMgp5dMaCmS1ZAkLZzOD8%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=176613175980206257&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video"></div><div class="author-info__name text-center">wenmu</div><div class="author-info__description text-center">记录一些在工作中或学习新知识时学到的一些知识点；正所谓好记性不如一个烂笔头，温故而知新！</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">18</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">温木的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="site-info"><div id="site-title">温木的博客</div><div id="site-sub-title">技术的积累</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-1/">从基础到实战 手把手带你掌握新版Webpack4.0-1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/webpack/">webpack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webpack/">webpack</a></span><div class="content"><h3 id="webpack-是什么？"><a href="#webpack-是什么？" class="headerlink" title="webpack 是什么？"></a>webpack 是什么？</h3><p>webpack 是模块打包工具。它不能理解成 es6 的翻译器，因为它只认识 import 语法，其他的高级语法不认识。因为它是模块打包工具，所以各种模块的语法它都认识。</p></div><a class="more" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-1/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-2/">从基础到实战 手把手带你掌握新版Webpack4.0-2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/webpack/">webpack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webpack/">webpack</a></span><div class="content"><p>###懒加载和 chunk 是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">'/* webpackChunkName:"lodash" */ lodash'</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    element.innnerHTML = _.join([<span class="string">"Hello"</span>, <span class="string">"Every"</span>, <span class="string">"One"</span>], <span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当点击页面时才加载lodash</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在页面加载时，上面的代码所依赖的<code>lodash</code>模块是不会被加载的，可以查看请求记录，只有当点击页面时，<code>lodash</code>被打的包才会被加载 。 这就是懒加载。（注意上面的语法）</p>
<blockquote>
<p>懒加载实际上是 ES6 的概念，不是 webpack 的，只是 webpack 支持这个语法而已。</p>
</blockquote>
<h3 id="css-进行代码分割"><a href="#css-进行代码分割" class="headerlink" title="css 进行代码分割"></a>css 进行代码分割</h3><p>使用<code>mini-css-extract-plugin</code>插件，注意修改 tree shaking 的配置。比如<code>sideEffects:[&quot;*.css&quot;]</code></p>
<p>如果想把多个入口的 css 打包到同一个文件中，或者分开打包，都需要参考 cacheGroup,参考官网配置。</p>
<h3 id="filename-和-chunkFileName-的区别"><a href="#filename-和-chunkFileName-的区别" class="headerlink" title="filename 和 chunkFileName 的区别"></a>filename 和 chunkFileName 的区别</h3><p>如果生成的文件是被入口 index.html 文件直接引用的，则使用 filename 指定的规则，如果是被其他模块引用的文件也就是二级引用则走 chunkFileName 规则。</p>
<h3 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h3><p>这个意思就是“垫片”，什么是垫片呢，举个例子；<br>比如你引入了一个第三方的模块 A，他依赖 jquery，但是它本身自己没有对 jquery 的引用，虽然你在自己的项目安装也引用了 jquery，但是由于 webpack 打包是基于模块的，A 是无法使用项目中引入的 jquery 的，但是第三方安装包，我们又不能改代码，Shimming 就是来解决这个问题的。<br>这需要用到<code>webpack</code>的<code>ProvidePlugin</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    <span class="comment">// 这个指定，只要有用到$的地方，就在这个使用的模块中引入jquery，并命名成$</span></span><br><span class="line">    $: <span class="string">"jquery"</span>,</span><br><span class="line">    <span class="comment">// 把lodash中的join方法打包成_join，这样也就可以在代码中直接使用了。</span></span><br><span class="line">    _join: [<span class="string">"lodash"</span>, <span class="string">"join"</span>],</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="模块中的-this-指向-window"><a href="#模块中的-this-指向-window" class="headerlink" title="模块中的 this 指向 window"></a>模块中的 this 指向 window</h4><blockquote>
<p>模块中的 this 指向模块本身<br>使用<code>imports-loader</code>可以轻松做到这个。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"babel-loader"</span> &#125;,</span><br><span class="line">      <span class="comment">// 加上下面的配置,模块中的this就指向window了</span></span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"imports-loader?this=&gt;window"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>这也是<code>shimming</code>的一种</p>
<h3 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h3><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis" target="_blank" rel="noopener">参考官网介绍</a><br><a href="https://www.webpackjs.com/guides/code-splitting/#bundle-%E5%88%86%E6%9E%90-bundle-analysis-" target="_blank" rel="noopener">中文版</a><br>也可以参考《项目性能和规范总结》一文中的介绍。<br>官网给了多种分析方式，其中一种是<a href="https://github.com/webpack/analyse" target="_blank" rel="noopener">官方分析工具</a>，这个比较简单，直接在 webpack 的 bu 打包生产环境的命令中传几个参数即可。<code>--profile --json &gt; stats.json</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">      "build":"webpack --profile --json &gt; stats.json --config webpack.pro.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样打包后会有一个<code>stats.json</code>文件，打开这个工具提供的<a href="http://webpack.github.com/analyse" target="_blank" rel="noopener">分析网站</a>，把生成的<code>stats.json</code>文件上传，就会生成界面化的分析结果。</p>
<h3 id="查看-js-代码使用率"><a href="#查看-js-代码使用率" class="headerlink" title="查看 js 代码使用率"></a>查看 js 代码使用率</h3><p>在 chrome 浏览器的开发者工具中，在下面窗口的<code>Coverage</code>窗口中可以录制代码的使用率，并且打开代码也可以看到哪些代码使用了，哪些代码没使用到，这样可以有针对性的把第一次没有用到的代码使用动态加载的方式来做，提高效率。</p>
<h3 id="prefetching"><a href="#prefetching" class="headerlink" title="prefetching"></a>prefetching</h3><p>在官网的概念模块讲解了 prefetching 的概念，这个就是当访问页面时，主文件先下载，等主要文件下载完了，线程有空闲了再下载<code>prefetching</code>的文件。<br>这个需要和懒加载一起使用，通过注释的方式来指定是否<code>prefetching</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">"LoginModal"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="根据文件内容命名文件"><a href="#根据文件内容命名文件" class="headerlink" title="根据文件内容命名文件"></a>根据文件内容命名文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>webpack4 之前的版本需要配置 runtime；老版本因为把 manifest 打包到了各个 chunk 中，所以老版本的 webpack 打包，即使内容没改变，打出的包的名字 hash 也可能不一样，因为 manifest 可能发生了变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">"runtime"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="library"><a href="#library" class="headerlink" title="library"></a>library</h3><p>当开发一个工具包时，我们也可以通过 webpack 进行打包，并发布到 npm 仓库中。<br>配置很简单，和常用的配置差别不大，甚至没那么复杂。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"webpack-numbers.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的配置就已经做完了，这样就可以进行打包了。但是可以从以下几个方面进行优化会更好：</p>
<ol>
<li>外部化 lodash</li>
<li>支持多种方式访问包，比如 amd，cmd，es6 等等</li>
<li>把包暴露给指定的全局变量</li>
<li>指定包的执行文件</li>
<li>发布到 npm 仓库</li>
</ol>
<h4 id="外部化"><a href="#外部化" class="headerlink" title="外部化"></a>外部化</h4><p>首先介绍下什么是外部化：外部化就是使用用户环境中的第三方库，而不是把第三方库打包到我们的包中。<br>比如我们开发一个数字处理的工具包 A，我们的代码中用到了<code>lodash</code>、<code>moment</code>等等多种第三方包，如果不做外部化处理，这些在代码中用到的第三方包都会和我们的逻辑代码一起进行打包。这就有个问题，使用我们包 A 的用户的项目中如果也用到了<code>lodash</code>、<code>moment</code>,那就会出现重复的打包。<br>因此在我们的开发包 A 中不对这些第三方的包进行打包，而是让使用我们包 A 的用户去安装我们依赖的这些包，然后使用包 A 的地方也引入包 A 所依赖的包即可；<br>实现这个功能需要用到<code>externals</code>的配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  lodash: &#123;</span><br><span class="line">    commonjs: 'lodash', // 指定在commonjs环境下引入lodash的名字</span><br><span class="line">    commonjs2: 'lodash',</span><br><span class="line">    amd: 'lodash',</span><br><span class="line">    root: '_', // script标签引入lodash的变量名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们虽然使用了 lodash，但 lodash 不会被打包到包 A 中。</p>
<h4 id="支持多种方式访问包"><a href="#支持多种方式访问包" class="headerlink" title="支持多种方式访问包"></a>支持多种方式访问包</h4><p>我们的包打包后，应该支持 amd、cmd、es6 以及在文件中引入等方式的使用。实现这个功能也很简单，配置<code>output</code>属性的<code>library</code>和<code>libraryTarget</code>即可。具体的参数可参见官网上的详细介绍</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, 'dist'),</span><br><span class="line">  filename: 'webpack-numbers.js',</span><br><span class="line">  library: 'myLibrary',// 通过配置这个，可以让通过script标签的方式引入，通过全局变量myLibrary来访问</span><br><span class="line">  libraryTarget: 'umd'</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>libraryTarget 的值不同，包可被访问的方式就不同。</p>
<ul>
<li>变量：默认值。作为一个全局变量，通过 script 标签来访问（libraryTarget:’var’），需要配置 library 属性来指定变量的名字。</li>
<li>this：通过 this 对象访问（libraryTarget:’this’）。</li>
<li>window：通过 window 对象访问，在浏览器中（libraryTarget:’window’）。</li>
<li>UMD：在 AMD 或 CommonJS 的 require 之后可访问（libraryTarget:’umd’）。<blockquote>
<p>只配置<code>libraryTarget</code>不支持通过 script 标签的方式引入。</p>
</blockquote>
</li>
</ul>
<h4 id="指定包的执行文件"><a href="#指定包的执行文件" class="headerlink" title="指定包的执行文件"></a>指定包的执行文件</h4><p>当别人使用我们的包时，加载的是哪个文件可以在 package.json 中的 main 字段进行配置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main: "./dist/webpack-numbers.js";</span><br></pre></td></tr></table></figure>

<p>####发布到 npm 仓库<br>首先需要在 npm 官网上有一个账号。在命令行中运行<code>npm adduser</code>，然后输入用户名和密码，接着运行发布命令<code>npm publish</code>，这样你的 npm 包就发送完成了，包名就是 package.json 中 name 指定的名字。<code>npm install 包名</code>就可以安装了。</p>
<blockquote>
<p>动态链接库用的也是这块的功能。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-3/">从基础到实战 手把手带你掌握新版Webpack4.0-3</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/webpack/">webpack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webpack/">webpack</a></span><div class="content"><h3 id="快速使用-PWA"><a href="#快速使用-PWA" class="headerlink" title="快速使用 PWA"></a>快速使用 PWA</h3><p>根据<a href="https://www.webpackjs.com/guides/progressive-web-application/" target="_blank" rel="noopener">官网上的推荐</a>简单配置一下就行了。</p>
<h3 id="配置-typescript"><a href="#配置-typescript" class="headerlink" title="配置 typescript"></a>配置 typescript</h3><p>使用第三方库时，需要安装对应的类型库，不然不会提示。比如<code>@types/jquery</code>，可以在如下网站中查看有哪些 types<br><a href="http://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">http://microsoft.github.io/TypeSearch/</a></p>
<h3 id="单页面路由访问提示找不到资源"><a href="#单页面路由访问提示找不到资源" class="headerlink" title="单页面路由访问提示找不到资源"></a>单页面路由访问提示找不到资源</h3><p>比如我们使用的是单页面模式，<code>BrowserRouter</code>的方式，当我们根据路由去访问页面时，可能会提示找不到资源的情况，比如访问<code>http://localhost:8000/list</code>，提示找不到<code>list</code>；因为是单页面应用，所以只有 index.html 页面<br>配置 devServer 来解决</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">historyApiFallback: <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="ESLint-5-6"><a href="#ESLint-5-6" class="headerlink" title="ESLint 5-6"></a>ESLint 5-6</h3><p>首先安装，然后使用<br>检测 src 目录下的代码是否符合规范</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint src</span><br></pre></td></tr></table></figure>

<p>webpack 结合 eslin<br>如果编辑器没有安装 eslint 插件，编辑器就无法检查代码规范。因此可以在 webpack 中配置 loader 来解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules:&#123;</span><br><span class="line">    test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">    use:[<span class="string">'babel-loader'</span>,<span class="string">'eslint-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在每次打包的时候就会在打包信息中显示不符合规范的地方，但是这样和直接运行<code>npx eslint src</code>一样，错误信息在控制台输出中，不方便发现。<br>可以通过配置 devServer 的 overlay 来解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    overlay:<span class="literal">true</span>,</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置了 overlay，如果代码不符合 eslint 规范，编译后，页面会弹出下面的页面！每当修改掉一个 error，就会自动刷新。<br><img src="https://upload-images.jianshu.io/upload_images/1348523-2181fb06960c68cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="使用-git-钩子来检测代码规范"><a href="#使用-git-钩子来检测代码规范" class="headerlink" title="使用 git 钩子来检测代码规范"></a>使用 git 钩子来检测代码规范</h3><p>当提交带的时候，通过 git 钩子来对代码进行规范检测。</p>
<h3 id="提升-webpack-打包速度"><a href="#提升-webpack-打包速度" class="headerlink" title="提升 webpack 打包速度"></a>提升 webpack 打包速度</h3><p>1.跟上技术迭代（升级 node、Npm、Yarm 版本） 2.在尽可能少的模块上应用 loader<br>善于使用 exclude 和 include，图片没必要使用，因为所有的图片都需要进行打包处理。<br>3.plugin 尽可能精简并确保可靠<br>4.resolve 参数合理配置<br>比如配置了多个<code>extensions</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">"css"</span>, <span class="string">"jpg"</span>, <span class="string">"js"</span>, <span class="string">"jsx"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置，当引入一个没写后缀的文件时，会先去找对应名称的 css，然后 jpg，依次往下匹配，直到匹配到，这样的话，如果配置的后缀比较多，肯定会影响效率。<br>所以建议配置逻辑代码的文件，资源类的最好在引入时写全后缀。</p>
<p>mainFiles 指定默认加载文件,默认是 index，当我们引入自定义组件时，通常引入到文件夹就行了，就是因为这个配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  mainFiles: [<span class="string">"index"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个属性同样有上面性能问题。</p>
<h3 id="自定义-loader"><a href="#自定义-loader" class="headerlink" title="自定义 loader"></a>自定义 loader</h3><p>其实 loader 就是一个函数，函数会接收被执行文件的内容，然后在 loader 中对内容做处理即可。<br>下面是一个自定义<code>loader</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要使用箭头函数，this的指向会出现问题。loader中的this需要绑定webpack响应的上下文</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">"eluanshi"</span>, <span class="string">"wenmu"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面就是一个简单的 loader 开发完成，然后在 webapack 中配置即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js/</span>,</span><br><span class="line">      use: [path.resolve(__dirname, <span class="string">"./loaders/myloader.js"</span>)],</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打完包后，<code>js</code>文件中所欲的<code>eluanshi</code>都会被替换成<code>wenmu</code><br>如果返回值是多个，则需要用到<code>callback</code>函数<br>异步方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  callback(<span class="literal">null</span>, result);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="自定义-plugin"><a href="#自定义-plugin" class="headerlink" title="自定义 plugin"></a>自定义 plugin</h3><p>loader 是一个方法，plugin 是一个类。因为在使用的时候需要 new 一个实例。</p>
<p>调试开发的 plugin，使用 node 的调试，配置一个新的命令</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">      <span class="string">"debug"</span>:<span class="string">"node --inspect --inspect-brk node_modules/webpack/bin/webpack.js</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>inspect 开启调试模式</li>
<li>inspect-brk 在代码第一行截住<br>并且可以在代码中使用<code>debugger</code></li>
</ul>
</blockquote>
<h3 id="什么时候执行-resolve？"><a href="#什么时候执行-resolve？" class="headerlink" title="什么时候执行 resolve？"></a>什么时候执行 resolve？</h3><p>当引入一个模块时，会执行 resolve 中的配置。</p>
<h3 id="什么时候执行-resolveLoader"><a href="#什么时候执行-resolveLoader" class="headerlink" title="什么时候执行 resolveLoader"></a>什么时候执行 resolveLoader</h3><p>和 resolve 类似，这个是当引入 loader 的时候，执行里面的配置。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-1/">前端知识点串讲-1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JavaScript/">JavaScript</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span><div class="content"><h2 id="HTML-的-meta-配置"><a href="#HTML-的-meta-配置" class="headerlink" title="HTML 的 meta 配置"></a>HTML 的 meta 配置</h2><p>1.X-UA-Compatible</p>
<p><code>X-UA-Compatible</code>是自从<code>IE8</code>新加的一个设置，对于<code>IE8</code>以下的浏览器是不识别的。 通过在 meta 中设置 X-UA-Compatible 的值，可以指定<strong>网页的兼容性模式设置</strong>。</p>
<p>在网页中指定的模式优先权高于服务器中(通过 HTTP Header)所指定的模式。 兼容性模式设置优先级：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta tag &gt; http header</span><br></pre></td></tr></table></figure>

<p>常用的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;7&quot;&gt;</span><br><span class="line">#以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8&#x2F;9都会以IE7引擎来渲染页面。</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;8&quot;&gt;</span><br><span class="line">#以上代码告诉IE浏览器，IE8&#x2F;9都会以IE8引擎来渲染页面。</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">#以上代码告诉IE浏览器，IE8&#x2F;9及以后的版本都会以最高版本IE来渲染页面。</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;7,IE&#x3D;9&quot;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;7,9&quot;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge,chrome&#x3D;1&quot;&gt;</span><br><span class="line">#以上代码IE&#x3D;edge告诉IE使用最新的引擎渲染网页，chrome&#x3D;1则可以激活Chrome Frame.</span><br></pre></td></tr></table></figure>

<p>京东、淘宝用的就是最后一个。</p>
<p><strong>content = “IE=Edge,chrome=1”</strong></p>
<p>meta 信息中常有这么一句：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>chrome=1</code>不是说 IE 的技术增强了可以模拟<code>Chrome</code>浏览器，而是与谷歌开发的<code>Google Chrome Frame</code>(谷歌内嵌浏览器框架<code>GCF</code>)有关。这个插件可以让用户的 IE 浏览器外观不变，但用户在浏览网页时实际上使用的是 Chrome 的内核，并且支持 Windows XP 及以上系统的 IE6/7/8。</p>
<ol start="2">
<li>指定双核浏览器优先使用什么内核渲染运行</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的配置说明如果是双核浏览器，优先以 webkit 内核运行。</p>
<h3 id="dns-域名预解析"><a href="#dns-域名预解析" class="headerlink" title="dns 域名预解析"></a>dns 域名预解析</h3><p>dns 域名预解析可以提高网页性能，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//static.360buyimg.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/goloving/p/9368965.html" target="_blank" rel="noopener">dns 域名预解析文章</a><br>不同的浏览器对<strong>单个域名</strong>的最大并发连接数有一定的限制，所以不同的资源需要放到不同的域名上面。这就用到了 dns 域名预解析。<br>字体文件<br>自定义字体<br>自定义图标<br>webp 图片</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-2/">前端知识点串讲-2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JavaScript/">JavaScript</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span><div class="content"><h2 id="float的理解"><a href="#float的理解" class="headerlink" title="float的理解"></a>float的理解</h2><ul>
<li>在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。</li>
<li>CSS 属性将一个元素放在其容器的左边或右边，允许文本和内联元素环绕它。元素将从页面的正常流中删除，但仍然保留为流的一部分(与绝对定位相反)。</li>
<li>如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。</li>
<li>假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。</li>
</ul>
<h3 id="仍保留流的一部分怎么理解？"><a href="#仍保留流的一部分怎么理解？" class="headerlink" title="仍保留流的一部分怎么理解？"></a>仍保留流的一部分怎么理解？</h3><p>这里先解释下流的理解。首先流分为三种，标准文档流、文档流、文本流；</p>
<p>标准文档流 = 文档流 + 文本流</p>
<p>其实float的元素是从正常流中脱离的，说的是文档流，所以浮动元素会浮在正常流元素上面；仍然保留一部分说的文本流，正常流中的文本或内联元遇到浮动元素会换行。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>把 div3 的填充满内容，然后把 div2 的高度设置成小于 div3 ；可以看到 div2 是压在 div3 上面，这说明 float 元素是脱离文档流的，但是文本在遇到float元素时是换行显示的，并没有被float元素所遮挡，这就是文本流。</p>
<p><a href="https://www.imooc.com/article/8915" target="_blank" rel="noopener">推荐阅读内容</a></p>
<h2 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h2><h3 id="基本概念：标准模型-IE模型"><a href="#基本概念：标准模型-IE模型" class="headerlink" title="基本概念：标准模型+IE模型"></a>基本概念：标准模型+IE模型</h3><p>盒子模型就是块的组成部分，<code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>。<br><code>标准模型</code>就是宽高只计算<code>content</code>，也就是<code>content-box</code>。<br><code>IE模型</code>就是宽高把<code>border</code>和<code>padding</code>包含进来，注意不包含<code>margin</code>，也就是<code>border-box</code>。</p>
<h3 id="标准模型和IE模型的区别"><a href="#标准模型和IE模型的区别" class="headerlink" title="标准模型和IE模型的区别"></a>标准模型和IE模型的区别</h3><p>区别就是上面说的宽高的计算方式不同。</p>
<h3 id="CSS如何设置这两种模型"><a href="#CSS如何设置这两种模型" class="headerlink" title="CSS如何设置这两种模型"></a>CSS如何设置这两种模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing:content-box; &#x2F;&#x2F; 标准模型，默认</span><br><span class="line">box-sizing:border-box; &#x2F;&#x2F; IE模型</span><br></pre></td></tr></table></figure>
<h3 id="JS如何设置获取盒模对应的宽和高"><a href="#JS如何设置获取盒模对应的宽和高" class="headerlink" title="JS如何设置获取盒模对应的宽和高"></a>JS如何设置获取盒模对应的宽和高</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这个只能获取内联样式的宽和高，也就是通过style属性设置的，不然即使css中设置了高度也获取不到</span><br><span class="line">dom.style.width&#x2F;height</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个是获取渲染后的宽和高，但是这个只有IE支持</span><br><span class="line">dom.currentStyle.width&#x2F;height</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个和上面一样，但是兼容所有主流浏览器------所以用这个</span><br><span class="line">window.getComputedStyle(dom).width&#x2F;height</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个也能获取渲染后的宽高，但是这个主要用于计算位置，因为返回值里面有位置和宽高信息</span><br><span class="line">dom.getBoundingClientRect().width&#x2F;height</span><br></pre></td></tr></table></figure>
<h3 id="根据盒模型解释边距重叠"><a href="#根据盒模型解释边距重叠" class="headerlink" title="根据盒模型解释边距重叠"></a>根据盒模型解释边距重叠</h3><h3 id="BFC-边距重叠解决方案"><a href="#BFC-边距重叠解决方案" class="headerlink" title="BFC(边距重叠解决方案)"></a>BFC(边距重叠解决方案)</h3><ol>
<li>BFC的概念<br>BFC就是块级格式化上下文。</li>
<li>BFC的原理<br>原理说白了就是渲染规则，规则是：<blockquote>
<ol>
<li>BFC这个元素的垂直方向的边距会发生重叠</li>
<li>BFC的区域不会与浮动元素的box重叠，这用来清除浮动和布局<br>我们知道float的元素是覆盖在其他元素上面，比如A，只是文本会受浮动元素影响，但是当把A设置成BFC(overflow:hidden)，float元素就不会在A元素上面了。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    html * &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .parent &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123; </span><br><span class="line">      margin-top: 10px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      height: 100px;</span><br><span class="line">      &#x2F;* overflow: hidden; *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    .float &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      height: 50px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;section class&#x3D;&quot;parent&quot; id&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;float&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;article class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;article&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>BFC 在页面上是个独立的容器，外面的元素不会影响里面的元素，里面的也不会影响外面的</li>
<li>计算BFC高度时，浮动元素也会参与计算<br>正常情况下，容器中有浮动元素，容器的高度是不受浮动元素影响，即使浮动元素独自占一行。但是如果容器设置成BFC，高度就受浮动元素的影响了</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    html * &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .parent &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123;</span><br><span class="line">      margin-top: 10px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    .float &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      height: 50px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;section class&#x3D;&quot;parent&quot; id&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">    &lt;article class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;article&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;float&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    window.onload &#x3D; function() &#123;</span><br><span class="line">      console.log(window.getComputedStyle(document.getElementById(&quot;parent&quot;)).height);</span><br><span class="line">    &#125;;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="创建BFC"><a href="#创建BFC" class="headerlink" title="创建BFC"></a>创建BFC</h3><ul>
<li>根元素(<code>&lt;html&gt;</code>)</li>
<li>浮动元素（元素的 <code>float</code> 不是 <code>none</code>）</li>
<li>绝对定位元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener" title="CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li>行内块元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a> 为 <code>inline-block</code>）</li>
<li>表格单元格（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a>为 <code>table-cell</code>，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a>为 <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 <code>inline-table</code>）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow" target="_blank" rel="noopener" title="CSS属性 overflow 定义当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。它是 overflow-x 和overflow-y的 简写属性 "><code>overflow</code></a> 值不为 <code>visible</code> 的块元素</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a> 值为 <a href="https://drafts.csswg.org/css-display/#valdef-display-flow-root" target="_blank" rel="noopener"><code>flow-root</code></a> 的元素</li>
</ul>
<p><a href="https://www.cnblogs.com/mlw1814011067/p/10397999.html" target="_blank" rel="noopener">一篇不错的BFC的讲解，貌似和我听的一套课程</a></p>
<p>##DOM事件类</p>
<h3 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DOM0 element.onclick&#x3D;function()&#123;&#125; || &lt;div onclick&#x3D;&quot;clickme()&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">DOM2 element.addEventListener(&#39;click&#39;,function()&#123;&#125;,false)</span><br><span class="line"></span><br><span class="line">DOM3 element.addEventListener(&#39;keyup&#39;,function()&#123;&#125;,false)</span><br></pre></td></tr></table></figure>
<p>与其说是级别，不如说是版本。<br>DOM0 就是上面两种添加事件的时代。<br>DOM1 没有制定事件相关的内容<br>DOM2 就是增加了使用<code>addEventListener</code>添加事件的方式<br>DOM3 增加了很多的事件类型，比如鼠标事件、键盘事件等等</p>
<h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p>说的就是冒泡和捕获</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>事件流分为三个阶段：<br>捕获阶段—目标阶段—冒泡阶段</p>
<h3 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h3><p>window–document—html—body—继续向下到目标</p>
<blockquote>
<p>注意第一个对象是window，不是html</p>
</blockquote>
<h3 id="EVent对象的常见应用"><a href="#EVent对象的常见应用" class="headerlink" title="EVent对象的常见应用"></a>EVent对象的常见应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault()</span><br><span class="line">event.stopPropagation()</span><br><span class="line">event.stopImmediatePropagation()</span><br><span class="line">event.currentTarget &#x2F;&#x2F; 绑定事件的元素</span><br><span class="line">event.target &#x2F;&#x2F; 触发事件的元素</span><br></pre></td></tr></table></figure>
<p>前两个没啥可说的，直接说第三个；<br>比如给按钮绑定了两个事件<code>eventA</code>和<code>eventB</code>,正常情况下，点击按钮后，<code>eventA</code>和<code>eventB</code>都会被执行；<br>如果想执行<code>eventA</code>后不再执行<code>eventB</code>，在eventA中调用<code>event.stopImmediatePropagation()</code>就行了。<br>event.target比较好理解，表示触发事件的元素。<br>event.currentTarget表示绑定事件的元素；比如把事件绑定在父元素<code>ul</code>上，点击子元素<code>li</code>时，<code>e.target</code>是<code>li</code>，但是<code>e.currentTarget</code>是<code>ul</code></p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义事件</span><br><span class="line">let eve&#x3D;new Event(&#39;eventName&#39;)</span><br><span class="line">&#x2F;&#x2F; 绑定事件</span><br><span class="line">dom.addEventListener(&#39;eventName&#39;,function()&#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; 触发事件</span><br><span class="line">dom.dispatchEvent(eve)</span><br></pre></td></tr></table></figure>
<p>如果定义事件时需要传递一些参数，可以使用<code>CustomEvent</code></p>
<h2 id="HTTP协议类"><a href="#HTTP协议类" class="headerlink" title="HTTP协议类"></a>HTTP协议类</h2><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li>简单快速</li>
<li>灵活</li>
<li>无连接</li>
<li>无状态</li>
</ul>
<p>###HTTP报文的组成部分<br>请求报文</p>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>空行</li>
<li>请求体<br>响应报文</li>
<li>状态行</li>
<li>响应行</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h3 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h3><ol>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求 √</li>
<li>GET产生的URL地址可以被收藏，而POST不可用</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置 √</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式</li>
<li>GET请求参数会被完整的保留在浏览器的历史记录里，而POST中的参数不会被保留 √</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制 √</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制 √</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
</ol>
<h2 id="原型链类问题"><a href="#原型链类问题" class="headerlink" title="原型链类问题"></a>原型链类问题</h2><h3 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h3><p>总共三种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o1 &#x3D; &#123; name:&#39;zhangsan&#39; &#125; &#x2F;&#x2F; 字面量的方式</span><br><span class="line">let 02 &#x3D; new Object(&#123;name:&#39;zhagnsan&#39;&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的两种写法是一种声明方式。</p>
<p>第二种：构造函数的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Man&#x3D;function()&#123;&#125;</span><br><span class="line">let zhangsan&#x3D;new Man()</span><br></pre></td></tr></table></figure>

<p>第三种：Object.create()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o1&#x3D; &#123;name:&#39;zhangsan&#39;&#125;</span><br><span class="line">let o2 &#x3D; Object.create(01)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1348523-c516f36ecb8241e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h3><p>只要使用new创建实例，那这个函数这时就是构造函数，不使用new操作它，它就是普通的函数，所以任何函数都可以是构造函数。</p>
<blockquote>
<p>使用实例原型链上的constructor和function进行对比，来判断实例是哪个function的实例。</p>
</blockquote>
<h3 id="手动实现-new-运算法"><a href="#手动实现-new-运算法" class="headerlink" title="手动实现 new 运算法"></a>手动实现 new 运算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Fun&#x3D;function(func)&#123;</span><br><span class="line">        &#x2F;&#x2F; 首先创建一个空对象，并把它的原型指到func上</span><br><span class="line">        let o &#x3D; Object.create(func.prototype);</span><br><span class="line">        &#x2F;&#x2F; 执行原函数</span><br><span class="line">        let r &#x3D; func.call(o);</span><br><span class="line">        &#x2F;&#x2F; 判断原函数是否有返回值，有返回值则返回，没有则返回上面创造的对象</span><br><span class="line">        if(typeof r &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">          return r;</span><br><span class="line">        &#125;</span><br><span class="line">        return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">  this.name &#x3D; &quot;zhangsan&quot;;</span><br><span class="line">  this.list &#x3D; [];</span><br><span class="line">&#125;</span><br><span class="line">function Child() &#123;</span><br><span class="line">  Parent.call(this);</span><br><span class="line">  this.age &#x3D; 18;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 第一种方式</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">&#x2F;&#x2F; 第二种方式</span><br><span class="line">Child.prototype &#x3D; Parent.prototype;</span><br><span class="line">&#x2F;&#x2F; 第三种方式</span><br><span class="line">Child.prototype &#x3D; Object.create(Parent.prototype);</span><br><span class="line">Child.contructor &#x3D; Child;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">&#x2F;&#x2F; Child.prototype.__proto__&#x3D;Parent.prototype;</span><br></pre></td></tr></table></figure>

<h2 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h2><h3 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h3><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。<br>这是一个用于隔离潜在恶意文件的关键的安全机制。</p>
<p>源=协议+域名+端口</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取 </li>
<li>DOM无法获得 </li>
<li>AJAX请求不能发送</li>
</ul>
<h3 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h3><ul>
<li>Ajax </li>
<li>WebSocket 不受同源策略限制</li>
<li>CORS 支持跨域通信也支持同源通信<br>这是一个新的企业通信标准</li>
</ul>
<h3 id="如何创建一个Ajax"><a href="#如何创建一个Ajax" class="headerlink" title="如何创建一个Ajax"></a>如何创建一个Ajax</h3><ul>
<li>XMLHttpRequest对象的工作流程</li>
<li>兼容性处理</li>
<li>事件的触发条件</li>
<li>事件的触发顺序</li>
</ul>
<h3 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h3><ul>
<li>jSONP<br>使用script标签的src属性实现</li>
<li>Hash<br>就是url中#号后面的内容，hash的改变是不刷新页面的，query是的改变会刷新(?后面的)，所以query不能做<br>跨域通信<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 场景是当前页面 A 通过 iframe或frame嵌入了跨域的页面 B</span><br><span class="line">&#x2F;&#x2F; 在 A 中的伪代码如下：</span><br><span class="line">let B &#x3D;document.getElementByTagName(&#39;iframe&#39;);</span><br><span class="line">B[0].src &#x3D; B[0].src + &#39;#&#39; + &#39;data&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在 B 中的伪代码如下</span><br><span class="line">window.onhashchange &#x3D; function() &#123;</span><br><span class="line">    let data &#x3D; window.location.hash;</span><br><span class="line">    &#x2F;&#x2F; 然后再用data发出请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我想了想为什么query不行，按说上面的方式也能改变url的参数，并且在B页面是可以获取到的。但是为什么不能做跨域呢？<br>上面也说了这种方式不能是因为会引起刷新，问题是为什么引起刷新就不能做跨域了？<br>原因为刷新导致了其他服务端请求，这些请求被认为是A发出的，但是经过测试发现，<code>iframe</code>中发出的请求<code>origin</code>和<code>referer</code>都是B自己。那应该也可以啊？？？</li>
<li>postMessage HTML5</li>
<li>WebSocket</li>
<li>CORS<br>为什么cors能跨域？<br>当浏览器发现发出的请求是CORS，会在请求头里面加上origin参数。</li>
</ul>
<h2 id="安全类"><a href="#安全类" class="headerlink" title="安全类"></a>安全类</h2><p>主要就是XSS和CSRF<br><a href="https://segmentfault.com/n/1330000017762196?token=3c334f35a69008d4e1607e3530f1612f" target="_blank" rel="noopener">https://segmentfault.com/n/1330000017762196?token=3c334f35a69008d4e1607e3530f1612f</a></p>
<h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><ul>
<li><p>排序<br><img src="https://upload-images.jianshu.io/upload_images/1348523-cb372f6de1c6c54d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>堆栈、队列、链表</p>
</li>
<li><p>递归</p>
</li>
<li><p>波兰式和逆波兰式</p>
<p><a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">Javascript算法——快速排序</a></p>
<p><a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">Javascript算法——选择排序</a></p>
<p><a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">Javascript算法——希尔排序</a></p>
<p><a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">JavaScript中的递归</a></p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">波兰式、逆波兰式与表达式求值</a></p>
<p><a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">https://github.com/Tairraos/rpn.js/blob/master/rpn.js</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">智能合约开发笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span><div class="content"><p>记录智能合约开发的环境配置及各个软件的功能。</p></div><a class="more" href="/2020/01/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E8%BE%93%E5%85%A5%E6%A1%86%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E8%A1%A8%E6%83%85%E5%92%8C%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/">输入框禁止输入表情和特殊符号</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JavaScript/">JavaScript</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content"><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>react+ant Design<br>我使用的 Input 组件。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>实现方式很简单，就是在 onChange 事件中过滤掉表情和特殊符号。</p>
<h3 id="过滤方法封装"><a href="#过滤方法封装" class="headerlink" title="过滤方法封装"></a>过滤方法封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">clearEmoji</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> regEmoji = <span class="regexp">/[^\u0020-\u007E\u00A0-\u00BE\u2E80-\uA4CF\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF\u0080-\u009F\u2000-\u201f\u2026\u2022\u20ac\r\n]/g</span>;</span><br><span class="line">  <span class="keyword">return</span> text.replace(regEmoji, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">clearEmojiAndSymbol</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> regSymbol = <span class="regexp">/[`~!@#$%^&amp;*()_\-+=&lt;&gt;?:"&#123;&#125;|,.\/;\\[\]·~！@#￥%……&amp;*（）——\-+=&#123;&#125;|《》？：“”【】、；‘’，。、]/g</span>;</span><br><span class="line">  <span class="keyword">return</span> clearEmoji(text).replace(regSymbol, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Input</span><br><span class="line">  size=<span class="string">"large"</span></span><br><span class="line">  disabled=&#123;isDisable&#125;</span><br><span class="line">  value=&#123;account&#125;</span><br><span class="line">  onChange=&#123;<span class="keyword">this</span>.onChangeAccount&#125;</span><br><span class="line">  maxLength=&#123;<span class="number">20</span>&#125;</span><br><span class="line">  placeholder=<span class="string">"请填写登录账号（至少包含一个字母）"</span></span><br><span class="line">/&gt;;</span><br><span class="line"></span><br><span class="line">onChangeAccount = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; onChange &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  onChange(<span class="string">"account"</span>, clearEmojiAndSymbol(e.target.value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="汉字只能打印一个的坑"><a href="#汉字只能打印一个的坑" class="headerlink" title="汉字只能打印一个的坑"></a>汉字只能打印一个的坑</h3><p>在测试上面的方法时，一切都很顺利，但是在测试输入汉字时，有个奇怪的现象，就是输入汉字的时候，当打出第二个汉字时，搜狗输入法的框就消失了，打印的拼音就被自动填充到输入框中。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>经过测试，如果不走验证特殊字符的方法就没问题，说明不是 replace 的时候影响了输入法，于是在验证特殊字符的方法中 debugger 了一下。</p>
<blockquote>
<p>原来是因为输入法在输入多个汉字的时候，每个拼音之间有一个单引号<code>&#39;</code>；<br>这样导致匹配成功，所以被 replace 了，输入结果被改变了;<br>输入法得到的只是字母，没有单引号，也就没有匹配的汉字，输入框就自动关闭了。</p>
</blockquote>
<p><strong>解决方法</strong><br>把匹配特殊字符串中的单引号去掉，就没这个问题了，哈哈，所以这个有个小漏洞就是单引号是可以输入的，小声告诉你</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E9%82%A3%E4%BA%9Bnpm%E5%90%AF%E5%8A%A8%E7%94%A8%E5%88%B0%E7%9A%84%E6%8F%92%E4%BB%B6/">那些npm启动用到的插件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/npm/">npm</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/npm/">npm</a></span><div class="content"><h3 id="npm-run-all"><a href="#npm-run-all" class="headerlink" title="npm-run-all"></a>npm-run-all</h3><p>当我们全栈开发时，可能需要启动一个服务的命令窗口，一个启动前端的命令窗口，这样每次打开两个窗体口比较麻烦。<br>使用<code>npm-run-all</code> 可以多个命令一起执行。并且可定义并行或同步执行。并且跨平台。<br><a href="https://github.com/codepandy/react_ssr" target="_blank" rel="noopener">参考例子</a>服务端渲染中有用到</p>
<blockquote>
<p><code>npm</code>也提供了多命令同时执行的语法，使用<code>&amp;</code>或<code>&amp;&amp;</code>符号连接多个命令即可，但是<code>window</code>平台不支持<code>&amp;</code>。</p>
</blockquote>
<h3 id="cross-env"><a href="#cross-env" class="headerlink" title="cross-env"></a>cross-env</h3><p>由于 mac 和 window 的环境变量写法不一样，使用<code>cross-env</code>解决跨平台环境变量定义</p>
<h3 id="Concurrently"><a href="#Concurrently" class="headerlink" title="Concurrently"></a>Concurrently</h3><p>这也是一个解决多个命令窗口的问题，可以指定同时需要运行的多条命令。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E5%92%8C%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/">项目性能和规范总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%80%A7%E8%83%BD/">性能</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%80%A7%E8%83%BD/">性能</a></span><div class="content"><h3 id="使用-eslint-格式化指定文件"><a href="#使用-eslint-格式化指定文件" class="headerlink" title="使用 eslint 格式化指定文件"></a>使用 eslint 格式化指定文件</h3><p>在<code>package.json</code>文件中增加通过 eslint 格式代码的方式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node scripts/start.js",</span><br><span class="line">  "build": "node scripts/build.js",</span><br><span class="line">  "test": "node scripts/test.js",</span><br><span class="line">  "format": "eslint src/**/*.&#123;jsx,js&#125; --fix", // 这行的配置</span><br><span class="line">  "deploy": "gh-pages -d build"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>执行<code>npm run format</code>就会使用<code>eslint</code>的规则对<code>src</code>路径下的<code>jsx</code>和<code>js</code>文件进行格式化。<br>使用的规则可以在<code>eslintConfig</code>字段就行配置，比如默认使用的是 react-app 的规则。这个规则非常有限。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"eslintConfig": &#123;</span><br><span class="line">  "extends": "react-app",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 eslint 推荐的规则进行格式化。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"eslintConfig": &#123;</span><br><span class="line">  "extends": [</span><br><span class="line">        “eslint:recommended”,</span><br><span class="line">        <span class="string">"react-app"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写格式规则"><a href="#重写格式规则" class="headerlink" title="重写格式规则"></a>重写格式规则</h3><p>在 eslintConfig 中的 rule 字段进行设置。比如下面是要求 jsx 的缩进是 4 个空格的空白。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &quot;eslintConfig&quot;: &#123;</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">        “eslint:recommended”,</span><br><span class="line">        &quot;react-app&quot;</span><br><span class="line">  ],</span><br><span class="line"> &quot;rules&quot;:&#123;</span><br><span class="line">        &quot;react&#x2F;jsx-indent&quot; :[“error”,4]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>npm run format</code>后，不符合规则的文件将被修复成符合规则的格式。</p>
<h3 id="提交的时候自动格式化"><a href="#提交的时候自动格式化" class="headerlink" title="提交的时候自动格式化"></a>提交的时候自动格式化</h3><p>提交的时候做校验，需要用到 git 的 hooks，由于自己配置比较麻烦，可以使用第三方的公交<code>husky</code></p>
<p>另外需要配合 lint-staged，lint-staged 是被 husky 进行调用，然后进行规则验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i husky lint-staged -D</span><br></pre></td></tr></table></figure>

<p>安装完成后后 package.json 中进行配置。增加根字段 husky。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"husky":&#123;</span><br><span class="line">    "hooks":&#123;</span><br><span class="line">          "pre-commit":"lint-staged"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">"lint-staged":&#123;</span><br><span class="line">    "*.&#123;js,jsx&#125;":[</span><br><span class="line">            "eslint --fix",</span><br><span class="line">             <span class="string">"git add "</span></span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是对 pre-commit 进行了设置，其实 hooks 有很多种。<br>上面的配置意思是：提交之前执行 lint-staged 命令（在 modules 的 bin 文件夹中可以找到）， 然后配置 lint-staged 命令的规则。<br>当执行<code>git commit -am &quot;test&quot;</code>时，就会自动执行 lint-staged 的规则。</p>
<h3 id="使用-prettier-进行格式化"><a href="#使用-prettier-进行格式化" class="headerlink" title="使用 prettier 进行格式化"></a>使用 prettier 进行格式化</h3><p>由于 eslint 的格式化功能比较弱，并且支持的文件格式也不多，所以使用更强大的 prettier 会更合适，prettier 不仅能格式化 js、jsx 还能格式化 css 和 md 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i prettier -D</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"lint-staged":&#123;</span><br><span class="line">    "*.&#123;js,jsx&#125;":[</span><br><span class="line">            "prittier --write",</span><br><span class="line">            "eslint --fix",</span><br><span class="line">             <span class="string">"git add "</span></span><br><span class="line">      ],</span><br><span class="line">    "*.&#123;css,md&#125;":[</span><br><span class="line">          "prittier --write",</span><br><span class="line">          <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个改动会比较大，所以开发的时候配置的规则最好就是 prettier，不然提交后代码变动较大。</p>
<p>可以在根目录创建 prettier 的配置文件 prettier.config.js，来自定义规则</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  tabWidth: <span class="number">4</span>,</span><br><span class="line">  singleQuote: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用了 husky 后，手动执行命令的方式就不要了。</p>
</blockquote>
<h3 id="分析各个模块的代码体积"><a href="#分析各个模块的代码体积" class="headerlink" title="分析各个模块的代码体积"></a>分析各个模块的代码体积</h3><p>使用<code>webpack-bundle-analyzer</code>可以分析各个模块的体积大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure>

<p>在 webpack.config.js 配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">"webpack-bundle-analyzer"</span>).BundleAnalyzerPlugin;</span><br></pre></td></tr></table></figure>

<p>在 plugins 中增加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">      <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>配置好后，重新启动程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>这次启动除了原本服务之外，还会启动并打开一个<code>http://127.0.0.1:8888/</code>的服务，打开这个就能看到各个模块的体积了。<br>这种方式看到是开发模式下的体积，意义不大，看到打包后放到生产环境上的体积才是有意义的。<br>安装了这个插件后，执行打包后也会自动启动 8888 服务，这时候看到的就是生产环境上的体积了(注意：把原来启动的 8888 关掉，不然端口冲突)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h3 id="禁止打包的时候自动启动服务"><a href="#禁止打包的时候自动启动服务" class="headerlink" title="禁止打包的时候自动启动服务"></a>禁止打包的时候自动启动服务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">      <span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">            openAnalyzer: <span class="literal">false</span>, <span class="comment">//是否打开8888服务</span></span><br><span class="line">            analyzerMode: <span class="string">"static"</span>, <span class="comment">// 生成静态的html文件</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样打包后会生成一个 report.html 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>可以在 build 的 build 目录启个服务，访问 report.html 查看结果。使用 serve</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/</span><br><span class="line">serve</span><br></pre></td></tr></table></figure>

<p>访问<a href="http://localhost:5000/report.html可以看到相通的结果。" target="_blank" rel="noopener">http://localhost:5000/report.html可以看到相通的结果。</a></p>
<p>可以控制是否生成分析文件，不然放到生产环境就不好了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">     proces.env.GENERATE_BUNDLE_ANALYZER===<span class="string">"true"</span>&amp;&amp;<span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">            openAnalyzer: <span class="literal">false</span>, <span class="comment">//是否打开8888服务</span></span><br><span class="line">            analyzerMode: <span class="string">"static"</span>, <span class="comment">// 生成静态的html文件</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/08/Electron%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">Electron入门笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Electron/">Electron</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/electron/">electron</a></span><div class="content"><p>讲解 electron 的一些入门知识。</p></div><a class="more" href="/2020/01/08/Electron%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-chevron-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">&lt;i class&#x3D;&quot;fa fa-chevron-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By wenmu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>