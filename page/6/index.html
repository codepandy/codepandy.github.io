<!DOCTYPE html><html lang="[&quot;zh-Hans&quot;,&quot;zh-CN&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="记录一些在工作中或学习新知识时学到的一些知识点；正所谓好记性不如一个烂笔头，温故而知新！"><meta name="keywords" content=""><meta name="author" content="wenmu"><meta name="copyright" content="wenmu"><title>技术的积累 | 温木的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://thumbnail0.baidupcs.com/thumbnail/ea5429806p23c6a153c0b44981506b2f?fid=1259130490-250528-341140853690276&amp;time=1578463200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Kd6VOtTMgp5dMaCmS1ZAkLZzOD8%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=176613175980206257&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video"></div><div class="author-info__name text-center">wenmu</div><div class="author-info__description text-center">记录一些在工作中或学习新知识时学到的一些知识点；正所谓好记性不如一个烂笔头，温故而知新！</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">70</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">41</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">20</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">温木的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="site-info"><div id="site-title">温木的博客</div><div id="site-sub-title">技术的积累</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/electron+react+%E4%B8%83%E7%89%9B%E4%BA%91%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">electron+react+七牛云开发笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/electron/">electron</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/electron/">electron</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h1 id="Electron-和-React-双剑合璧做-markdown"><a href="#Electron-和-React-双剑合璧做-markdown" class="headerlink" title="Electron 和 React 双剑合璧做 markdown"></a>Electron 和 React 双剑合璧做 markdown</h1><p>使用 Electrong 、 React 和七牛云做一个在线 markdown。</p></div><a class="more" href="/2020/01/09/electron+react+%E4%B8%83%E7%89%9B%E4%BA%91%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">javascript原型链容易混淆的相关知识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JavaScript/">JavaScript</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/prototype/">prototype</a></span><div class="content"><p>讲解一下关于原型链的知识。</p></div><a class="more" href="/2020/01/09/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/nextjs%E9%85%8D%E5%90%88redux%E7%AC%94%E8%AE%B0/">nextjs配合redux笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/react/">react</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ssr/">ssr</a></span><div class="content"><p>具体可查看<a href="https://github.com/zeit/next.js" target="_blank" rel="noopener">github 上官方提供的 demo</a><br>下面对代码关键地方做说明，主要讲解如何实现数据共享。</p></div><a class="more" href="/2020/01/09/nextjs%E9%85%8D%E5%90%88redux%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/no-cache%E5%92%8Cno-store%E7%9A%84%E5%8C%BA%E5%88%AB/">no-cache和no-store的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/HTTP/">HTTP</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/HTTP/">HTTP</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/cache/">cache</a></span><div class="content"><p>从字面意思上很容易把 <code>no-cache</code> 误解成为不缓存，但事实上 <code>no-cache</code> 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源， 也许称为 <code>do-not-serve-from-cache-without-revalidation</code> 更合适。<br>也就是每次还是需要向服务端发送请求确认是否过期。<br><code>no-store</code> 才是真正地不进行缓存，请读者注意区别理解。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/onLoad%E5%92%8CDOMContentLoaded%E7%9A%84%E5%8C%BA%E5%88%AB/">onLoad和DOMContentLoaded的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JavaScript/">JavaScript</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content"><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p>当纯 HTML 被完全加载以及解析时，DOMContentLoaded 事件会被触发，而不必等待样式表，图片或者子框架完成加载。</p>
<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>The <strong><code>load</code></strong> event is fired when the whole page has loaded, including <code>all dependent resources</code> such as stylesheets and images. This is in contrast to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event" target="_blank" rel="noopener" title="The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading."><code>DOMContentLoaded</code></a>, which is fired as soon as the page DOM has been loaded, without waiting for resources to finish loading.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/react%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%AC%94%E8%AE%B0/">react服务端渲染笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/react/">react</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ssr/">ssr</a></span><div class="content"><p><img src="https://upload-images.jianshu.io/upload_images/1348523-da23aad53417fb16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-c71c18796084afb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-4759920497527f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-e440776fdffcdf1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-8075a4c51d5aeb8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-1c7481761f44fd51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/webpack%E7%9A%84code%20splitting%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/">webpack的code splitting和懒加载</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/webpack/">webpack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webpack/">webpack</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/code-splitting/">code splitting</a></span><div class="content"><h3 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h3><p>原来一直以为 code splitting 了，就已经实现了懒加载了，但现在 react 又单独退出了懒加载功能，突然就迷茫了，webpack 已经实现懒加载了，为什么 react 还要单独实现这个功能呢？细心思考才明白两者之间的关系。</p>
<hr>
<p>code splitting 实现了代码分割，就是不把所有的代码打包到一起，这只是解决了单个大文件加载慢的问题（因为浏览器现在可以同时多个线程下载文件），而不是懒加载的问题。</p>
<hr>
<p>什么是懒加载？<br>懒加载就是没用到某个文件的时候，这文件不<strong>下载</strong>，用到的时候才下载加载，从而提高性能。</p>
<blockquote>
<p>注意：懒加载时，如果文件没用到，连下载都不下载，而不是下载下来不加载。</p>
</blockquote>
<p>而要实现懒加载，那首先各个文件是分开的，这就依赖 code splitting 功能，不然代码都在一个文件里，动态加载个屁。</p>
<h3 id="react-懒加载"><a href="#react-懒加载" class="headerlink" title="react 懒加载"></a>react 懒加载</h3><p>react 的懒加载，提供了 lazy 和 suspense，另外需要借助 js 的 import()“函数”（<code>其实本质不是个函数</code>）。</p>
<blockquote>
<p>懒加载解决了页面首次加载的性能问题。</p>
</blockquote>
<h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h3><p>lazy 接收一个无参的函数，返回一个新的 react 组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;lazy&#125; <span class="keyword">from</span> <span class="string">'react;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const About = lazy(() =&gt; import("./About"));</span></span><br></pre></td></tr></table></figure>

<p><strong>可以指定动态加载 chunk 的名字,通过在 import 里面加注释实现。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"about" */</span> <span class="string">"./About"</span>));</span><br></pre></td></tr></table></figure>

<p>这在浏览器的 network 中，就可以看到 About 组件的 chunk 文件名叫<code>about.chunk.js</code>,如果不指定，则是 0.chunk.js 这样，用数字命名。</p>
<blockquote>
<p>注意<code>webpackChunkName:&quot;about&quot;</code>两边要有空格，如果没有空格，也不报错，只是 chunk 文件中的代码以文本的方式显示，所有代码都是黑色的。带空格就会以代码的格式，字体有颜色。<br>另外注意 value 上的双引号。</p>
</blockquote>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>使用<code>lazy</code>必须使用<code>Suspense</code>组件，<code>Suspense</code>是<code>react</code>的一个内置组件。<br>suspense 是干什么的，因为 lazy 是动态加载，所以加载过程中会有一个空档期，Suspense 就是执行，这个空档期显示什么。<br>Suspense 的 fallback 属性执行了要显示的组件，fallback 接收的是一个组件的实例，而不是组件的类型（感觉一句废话）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./About"</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading,please wait……&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;About /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果组件下载失败，会报错，Suspense 没有处理错误的能力。那错误如何处理呢？使用 ErrorBoundary(错误边界)，其实就是利用了组件的<code>componentDidCatch</code>生命周期。<br>当 UI 渲染有错误时，就会触发 getDerivedStateFromError 和 componentDidCatch，可以在设置 state 的状态，然后根据 state 判断是否显示错误组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"about" */</span> <span class="string">"./About"</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    hasError: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidCatch(error) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; hasError &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>组件获取失败！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading,please wait……&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;About /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>getDerivedStateFromError</code>返回一个新的 state 对象并合并到原来的 state 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromError(error, info) &#123;</span><br><span class="line">  <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//componentDidCatch(error, info) &#123;</span></span><br><span class="line">  <span class="comment">//this.setState(&#123; hasError: true &#125;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<p>官方建议：当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。<br><a href="https://react.docschina.org/docs/error-boundaries.html" target="_blank" rel="noopener">错误边界的介绍</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-1/">从基础到实战 手把手带你掌握新版Webpack4.0-1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/webpack/">webpack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webpack/">webpack</a></span><div class="content"><h3 id="webpack-是什么？"><a href="#webpack-是什么？" class="headerlink" title="webpack 是什么？"></a>webpack 是什么？</h3><p>webpack 是模块打包工具。它不能理解成 es6 的翻译器，因为它只认识 import 语法，其他的高级语法不认识。因为它是模块打包工具，所以各种模块的语法它都认识。</p></div><a class="more" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-1/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-2/">从基础到实战 手把手带你掌握新版Webpack4.0-2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/webpack/">webpack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webpack/">webpack</a></span><div class="content"><p>###懒加载和 chunk 是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">'/* webpackChunkName:"lodash" */ lodash'</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    element.innnerHTML = _.join([<span class="string">"Hello"</span>, <span class="string">"Every"</span>, <span class="string">"One"</span>], <span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当点击页面时才加载lodash</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在页面加载时，上面的代码所依赖的<code>lodash</code>模块是不会被加载的，可以查看请求记录，只有当点击页面时，<code>lodash</code>被打的包才会被加载 。 这就是懒加载。（注意上面的语法）</p>
<blockquote>
<p>懒加载实际上是 ES6 的概念，不是 webpack 的，只是 webpack 支持这个语法而已。</p>
</blockquote>
<h3 id="css-进行代码分割"><a href="#css-进行代码分割" class="headerlink" title="css 进行代码分割"></a>css 进行代码分割</h3><p>使用<code>mini-css-extract-plugin</code>插件，注意修改 tree shaking 的配置。比如<code>sideEffects:[&quot;*.css&quot;]</code></p>
<p>如果想把多个入口的 css 打包到同一个文件中，或者分开打包，都需要参考 cacheGroup,参考官网配置。</p>
<h3 id="filename-和-chunkFileName-的区别"><a href="#filename-和-chunkFileName-的区别" class="headerlink" title="filename 和 chunkFileName 的区别"></a>filename 和 chunkFileName 的区别</h3><p>如果生成的文件是被入口 index.html 文件直接引用的，则使用 filename 指定的规则，如果是被其他模块引用的文件也就是二级引用则走 chunkFileName 规则。</p>
<h3 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h3><p>这个意思就是“垫片”，什么是垫片呢，举个例子；<br>比如你引入了一个第三方的模块 A，他依赖 jquery，但是它本身自己没有对 jquery 的引用，虽然你在自己的项目安装也引用了 jquery，但是由于 webpack 打包是基于模块的，A 是无法使用项目中引入的 jquery 的，但是第三方安装包，我们又不能改代码，Shimming 就是来解决这个问题的。<br>这需要用到<code>webpack</code>的<code>ProvidePlugin</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    <span class="comment">// 这个指定，只要有用到$的地方，就在这个使用的模块中引入jquery，并命名成$</span></span><br><span class="line">    $: <span class="string">"jquery"</span>,</span><br><span class="line">    <span class="comment">// 把lodash中的join方法打包成_join，这样也就可以在代码中直接使用了。</span></span><br><span class="line">    _join: [<span class="string">"lodash"</span>, <span class="string">"join"</span>],</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="模块中的-this-指向-window"><a href="#模块中的-this-指向-window" class="headerlink" title="模块中的 this 指向 window"></a>模块中的 this 指向 window</h4><blockquote>
<p>模块中的 this 指向模块本身<br>使用<code>imports-loader</code>可以轻松做到这个。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"babel-loader"</span> &#125;,</span><br><span class="line">      <span class="comment">// 加上下面的配置,模块中的this就指向window了</span></span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"imports-loader?this=&gt;window"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>这也是<code>shimming</code>的一种</p>
<h3 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h3><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis" target="_blank" rel="noopener">参考官网介绍</a><br><a href="https://www.webpackjs.com/guides/code-splitting/#bundle-%E5%88%86%E6%9E%90-bundle-analysis-" target="_blank" rel="noopener">中文版</a><br>也可以参考《项目性能和规范总结》一文中的介绍。<br>官网给了多种分析方式，其中一种是<a href="https://github.com/webpack/analyse" target="_blank" rel="noopener">官方分析工具</a>，这个比较简单，直接在 webpack 的 bu 打包生产环境的命令中传几个参数即可。<code>--profile --json &gt; stats.json</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">      "build":"webpack --profile --json &gt; stats.json --config webpack.pro.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样打包后会有一个<code>stats.json</code>文件，打开这个工具提供的<a href="http://webpack.github.com/analyse" target="_blank" rel="noopener">分析网站</a>，把生成的<code>stats.json</code>文件上传，就会生成界面化的分析结果。</p>
<h3 id="查看-js-代码使用率"><a href="#查看-js-代码使用率" class="headerlink" title="查看 js 代码使用率"></a>查看 js 代码使用率</h3><p>在 chrome 浏览器的开发者工具中，在下面窗口的<code>Coverage</code>窗口中可以录制代码的使用率，并且打开代码也可以看到哪些代码使用了，哪些代码没使用到，这样可以有针对性的把第一次没有用到的代码使用动态加载的方式来做，提高效率。</p>
<h3 id="prefetching"><a href="#prefetching" class="headerlink" title="prefetching"></a>prefetching</h3><p>在官网的概念模块讲解了 prefetching 的概念，这个就是当访问页面时，主文件先下载，等主要文件下载完了，线程有空闲了再下载<code>prefetching</code>的文件。<br>这个需要和懒加载一起使用，通过注释的方式来指定是否<code>prefetching</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">"LoginModal"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="根据文件内容命名文件"><a href="#根据文件内容命名文件" class="headerlink" title="根据文件内容命名文件"></a>根据文件内容命名文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>webpack4 之前的版本需要配置 runtime；老版本因为把 manifest 打包到了各个 chunk 中，所以老版本的 webpack 打包，即使内容没改变，打出的包的名字 hash 也可能不一样，因为 manifest 可能发生了变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">"runtime"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="library"><a href="#library" class="headerlink" title="library"></a>library</h3><p>当开发一个工具包时，我们也可以通过 webpack 进行打包，并发布到 npm 仓库中。<br>配置很简单，和常用的配置差别不大，甚至没那么复杂。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"webpack-numbers.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的配置就已经做完了，这样就可以进行打包了。但是可以从以下几个方面进行优化会更好：</p>
<ol>
<li>外部化 lodash</li>
<li>支持多种方式访问包，比如 amd，cmd，es6 等等</li>
<li>把包暴露给指定的全局变量</li>
<li>指定包的执行文件</li>
<li>发布到 npm 仓库</li>
</ol>
<h4 id="外部化"><a href="#外部化" class="headerlink" title="外部化"></a>外部化</h4><p>首先介绍下什么是外部化：外部化就是使用用户环境中的第三方库，而不是把第三方库打包到我们的包中。<br>比如我们开发一个数字处理的工具包 A，我们的代码中用到了<code>lodash</code>、<code>moment</code>等等多种第三方包，如果不做外部化处理，这些在代码中用到的第三方包都会和我们的逻辑代码一起进行打包。这就有个问题，使用我们包 A 的用户的项目中如果也用到了<code>lodash</code>、<code>moment</code>,那就会出现重复的打包。<br>因此在我们的开发包 A 中不对这些第三方的包进行打包，而是让使用我们包 A 的用户去安装我们依赖的这些包，然后使用包 A 的地方也引入包 A 所依赖的包即可；<br>实现这个功能需要用到<code>externals</code>的配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  lodash: &#123;</span><br><span class="line">    commonjs: 'lodash', // 指定在commonjs环境下引入lodash的名字</span><br><span class="line">    commonjs2: 'lodash',</span><br><span class="line">    amd: 'lodash',</span><br><span class="line">    root: '_', // script标签引入lodash的变量名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们虽然使用了 lodash，但 lodash 不会被打包到包 A 中。</p>
<h4 id="支持多种方式访问包"><a href="#支持多种方式访问包" class="headerlink" title="支持多种方式访问包"></a>支持多种方式访问包</h4><p>我们的包打包后，应该支持 amd、cmd、es6 以及在文件中引入等方式的使用。实现这个功能也很简单，配置<code>output</code>属性的<code>library</code>和<code>libraryTarget</code>即可。具体的参数可参见官网上的详细介绍</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, 'dist'),</span><br><span class="line">  filename: 'webpack-numbers.js',</span><br><span class="line">  library: 'myLibrary',// 通过配置这个，可以让通过script标签的方式引入，通过全局变量myLibrary来访问</span><br><span class="line">  libraryTarget: 'umd'</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>libraryTarget 的值不同，包可被访问的方式就不同。</p>
<ul>
<li>变量：默认值。作为一个全局变量，通过 script 标签来访问（libraryTarget:’var’），需要配置 library 属性来指定变量的名字。</li>
<li>this：通过 this 对象访问（libraryTarget:’this’）。</li>
<li>window：通过 window 对象访问，在浏览器中（libraryTarget:’window’）。</li>
<li>UMD：在 AMD 或 CommonJS 的 require 之后可访问（libraryTarget:’umd’）。<blockquote>
<p>只配置<code>libraryTarget</code>不支持通过 script 标签的方式引入。</p>
</blockquote>
</li>
</ul>
<h4 id="指定包的执行文件"><a href="#指定包的执行文件" class="headerlink" title="指定包的执行文件"></a>指定包的执行文件</h4><p>当别人使用我们的包时，加载的是哪个文件可以在 package.json 中的 main 字段进行配置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main: "./dist/webpack-numbers.js";</span><br></pre></td></tr></table></figure>

<p>####发布到 npm 仓库<br>首先需要在 npm 官网上有一个账号。在命令行中运行<code>npm adduser</code>，然后输入用户名和密码，接着运行发布命令<code>npm publish</code>，这样你的 npm 包就发送完成了，包名就是 package.json 中 name 指定的名字。<code>npm install 包名</code>就可以安装了。</p>
<blockquote>
<p>动态链接库用的也是这块的功能。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-3/">从基础到实战 手把手带你掌握新版Webpack4.0-3</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/webpack/">webpack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/webpack/">webpack</a></span><div class="content"><h3 id="快速使用-PWA"><a href="#快速使用-PWA" class="headerlink" title="快速使用 PWA"></a>快速使用 PWA</h3><p>根据<a href="https://www.webpackjs.com/guides/progressive-web-application/" target="_blank" rel="noopener">官网上的推荐</a>简单配置一下就行了。</p>
<h3 id="配置-typescript"><a href="#配置-typescript" class="headerlink" title="配置 typescript"></a>配置 typescript</h3><p>使用第三方库时，需要安装对应的类型库，不然不会提示。比如<code>@types/jquery</code>，可以在如下网站中查看有哪些 types<br><a href="http://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">http://microsoft.github.io/TypeSearch/</a></p>
<h3 id="单页面路由访问提示找不到资源"><a href="#单页面路由访问提示找不到资源" class="headerlink" title="单页面路由访问提示找不到资源"></a>单页面路由访问提示找不到资源</h3><p>比如我们使用的是单页面模式，<code>BrowserRouter</code>的方式，当我们根据路由去访问页面时，可能会提示找不到资源的情况，比如访问<code>http://localhost:8000/list</code>，提示找不到<code>list</code>；因为是单页面应用，所以只有 index.html 页面<br>配置 devServer 来解决</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">historyApiFallback: <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="ESLint-5-6"><a href="#ESLint-5-6" class="headerlink" title="ESLint 5-6"></a>ESLint 5-6</h3><p>首先安装，然后使用<br>检测 src 目录下的代码是否符合规范</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint src</span><br></pre></td></tr></table></figure>

<p>webpack 结合 eslin<br>如果编辑器没有安装 eslint 插件，编辑器就无法检查代码规范。因此可以在 webpack 中配置 loader 来解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules:&#123;</span><br><span class="line">    test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">    use:[<span class="string">'babel-loader'</span>,<span class="string">'eslint-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在每次打包的时候就会在打包信息中显示不符合规范的地方，但是这样和直接运行<code>npx eslint src</code>一样，错误信息在控制台输出中，不方便发现。<br>可以通过配置 devServer 的 overlay 来解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    overlay:<span class="literal">true</span>,</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置了 overlay，如果代码不符合 eslint 规范，编译后，页面会弹出下面的页面！每当修改掉一个 error，就会自动刷新。<br><img src="https://upload-images.jianshu.io/upload_images/1348523-2181fb06960c68cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="使用-git-钩子来检测代码规范"><a href="#使用-git-钩子来检测代码规范" class="headerlink" title="使用 git 钩子来检测代码规范"></a>使用 git 钩子来检测代码规范</h3><p>当提交带的时候，通过 git 钩子来对代码进行规范检测。</p>
<h3 id="提升-webpack-打包速度"><a href="#提升-webpack-打包速度" class="headerlink" title="提升 webpack 打包速度"></a>提升 webpack 打包速度</h3><p>1.跟上技术迭代（升级 node、Npm、Yarm 版本） 2.在尽可能少的模块上应用 loader<br>善于使用 exclude 和 include，图片没必要使用，因为所有的图片都需要进行打包处理。<br>3.plugin 尽可能精简并确保可靠<br>4.resolve 参数合理配置<br>比如配置了多个<code>extensions</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">"css"</span>, <span class="string">"jpg"</span>, <span class="string">"js"</span>, <span class="string">"jsx"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置，当引入一个没写后缀的文件时，会先去找对应名称的 css，然后 jpg，依次往下匹配，直到匹配到，这样的话，如果配置的后缀比较多，肯定会影响效率。<br>所以建议配置逻辑代码的文件，资源类的最好在引入时写全后缀。</p>
<p>mainFiles 指定默认加载文件,默认是 index，当我们引入自定义组件时，通常引入到文件夹就行了，就是因为这个配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  mainFiles: [<span class="string">"index"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个属性同样有上面性能问题。</p>
<h3 id="自定义-loader"><a href="#自定义-loader" class="headerlink" title="自定义 loader"></a>自定义 loader</h3><p>其实 loader 就是一个函数，函数会接收被执行文件的内容，然后在 loader 中对内容做处理即可。<br>下面是一个自定义<code>loader</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要使用箭头函数，this的指向会出现问题。loader中的this需要绑定webpack响应的上下文</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">"eluanshi"</span>, <span class="string">"wenmu"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面就是一个简单的 loader 开发完成，然后在 webapack 中配置即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js/</span>,</span><br><span class="line">      use: [path.resolve(__dirname, <span class="string">"./loaders/myloader.js"</span>)],</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打完包后，<code>js</code>文件中所欲的<code>eluanshi</code>都会被替换成<code>wenmu</code><br>如果返回值是多个，则需要用到<code>callback</code>函数<br>异步方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  callback(<span class="literal">null</span>, result);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="自定义-plugin"><a href="#自定义-plugin" class="headerlink" title="自定义 plugin"></a>自定义 plugin</h3><p>loader 是一个方法，plugin 是一个类。因为在使用的时候需要 new 一个实例。</p>
<p>调试开发的 plugin，使用 node 的调试，配置一个新的命令</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">      <span class="string">"debug"</span>:<span class="string">"node --inspect --inspect-brk node_modules/webpack/bin/webpack.js</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>inspect 开启调试模式</li>
<li>inspect-brk 在代码第一行截住<br>并且可以在代码中使用<code>debugger</code></li>
</ul>
</blockquote>
<h3 id="什么时候执行-resolve？"><a href="#什么时候执行-resolve？" class="headerlink" title="什么时候执行 resolve？"></a>什么时候执行 resolve？</h3><p>当引入一个模块时，会执行 resolve 中的配置。</p>
<h3 id="什么时候执行-resolveLoader"><a href="#什么时候执行-resolveLoader" class="headerlink" title="什么时候执行 resolveLoader"></a>什么时候执行 resolveLoader</h3><p>和 resolve 类似，这个是当引入 loader 的时候，执行里面的配置。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">下一页</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By wenmu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>