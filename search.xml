<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js判断浏览器窗口的关闭与刷新</title>
      <link href="/2020/06/19/js%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E9%97%AD%E4%B8%8E%E5%88%B7%E6%96%B0/"/>
      <url>/2020/06/19/js%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E9%97%AD%E4%B8%8E%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>今日项目遇到一个问题，有一个功能会在浏览器的主窗口中新开一个窗口，然后业务要求：关闭新窗口的时候往后端发个请求，刷新的时候不发送。知道有个 onbeforeunload 事件是用于捕获关闭浏览器事件（包括刷新）的，但刷新也会走此方法，所以行不通，于是就网上找了找资料，网上回答的最多的大致是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//鼠标相对于用户屏幕的水平位置 - 窗口左上角相对于屏幕左上角的水平位置 = 鼠标在当前窗口上的水平位置</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="built_in">window</span>.event.screenX - <span class="built_in">window</span>.screenLeft;</span><br><span class="line">  <span class="comment">//鼠标在当前窗口内时，n&lt;m，b为false；鼠标在当前窗口外时，n&gt;m，b为true。20这个值是指关闭按钮的宽度</span></span><br><span class="line">  <span class="keyword">var</span> b = n &gt; <span class="built_in">document</span>.documentElement.scrollWidth - <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//鼠标在客户区内时，window.event.clientY&gt;0；鼠标在客户区外时，window.event.clientY&lt;0</span></span><br><span class="line">  <span class="keyword">if</span> ((b &amp;&amp; <span class="built_in">window</span>.event.clientY &lt; <span class="number">0</span>) || <span class="built_in">window</span>.event.altKey || <span class="built_in">window</span>.event.ctrlKey) &#123;</span><br><span class="line">    <span class="comment">//关闭浏览器时你想做的事</span></span><br><span class="line">    alert(<span class="string">"关闭"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.clientY &gt; <span class="built_in">document</span>.body.clientHeight || event.altKey) &#123;</span><br><span class="line">    <span class="comment">//刷新浏览器时你想做的事</span></span><br><span class="line">    alert(<span class="string">"刷新"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，这个方法是监听浏览器右上角的关闭事件的，我想要的是选项卡的关闭与刷新事件，下面我们先来分析一下关闭窗口相关的几个方法</p><blockquote><p>页面关闭时先执行 onbeforeunload，然后 onunload<br>页面刷新时先执行 onbeforeunload，然后 onunload，最后 onload。</p></blockquote><p>从上面的分析中，发现关闭与刷新都会走 onbeforeunload 与 onunload，如果我们认为用这两个方法无法区分关闭与刷新事件，那就大错特错了，正因为关闭与刷新事件都会走 onbeforeunload 与 onunload，所以我们利用了一个关键点就能区分出这两种，那就是：<code>时间差</code></p><h2 id="最终解决方法"><a href="#最终解决方法" class="headerlink" title="最终解决方法"></a>最终解决方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var beginTime &#x3D; 0；&#x2F;&#x2F;执行onbeforeunload的开始时间</span><br><span class="line">var differTime &#x3D; 0;&#x2F;&#x2F;时间差</span><br><span class="line">window.onunload &#x3D; function ()&#123;</span><br><span class="line">        differTime &#x3D; new Date().getTime() - beginTime;</span><br><span class="line">        if(differTime &lt;&#x3D; 5) &#123;</span><br><span class="line">            console.log(&quot;浏览器关闭&quot;)</span><br><span class="line">             $.ajax(&#123;</span><br><span class="line">                type: &quot;POST&quot;,</span><br><span class="line">                url:url,</span><br><span class="line">                dataType: &quot;JSON&quot;,</span><br><span class="line">                cache: false,</span><br><span class="line">                success: function(msg)&#123;</span><br><span class="line">                    console.log(msg);</span><br><span class="line">                    &#125;,</span><br><span class="line">                error:function(err)&#123;</span><br><span class="line">                    console.log(err)</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;浏览器刷新&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    window.onbeforeunload &#x3D; function ()&#123;</span><br><span class="line">       beginTime &#x3D; new Date().getTime();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>分析：虽然刷新与关闭都会走 onbeforeunload 与 onunload，但可能因为刷新在加载新页面前内部机制还需要做一些准备工作，所以刷新事件在执行到 onunload 事件时，用的时间会比关闭事件时间长，在我的测试页面中，页面里面没啥内容，关闭时 onbeforeunload 与 onunload 的时间差一般会在 3 毫秒内，而刷新事件的时间差一般会在 10 毫秒以上，当我真正用到项目中的时候（真正的项目页面中就有很多内容了），刷新事件的时间差竟能达到 100 毫秒左右，而关闭事件时间差还是 3 毫秒左右，这就大大保证了此方法的准确率，所以，判断浏览器窗口或者说是选项卡的关闭与刷新，此方法是比较合适的。<br>————————————————<br>版权声明：本文为 CSDN 博主「微行」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/itlsq/article/details/81095323" target="_blank" rel="noopener">https://blog.csdn.net/itlsq/article/details/81095323</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态更改keyframes</title>
      <link href="/2020/06/19/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9keyframes/"/>
      <url>/2020/06/19/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9keyframes/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近做了一个上线滚动文字的走马灯组件，通过关键帧@keyframes at-rule 来定义滚动；<br>由于我的滚动条目是动态的，个数不定，所以需要动态计算时间段显示的内容。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>就是@keyframe 设置在不同时间显示不同的元素，通过绝对定位来实现，动态控制元素的位置来控制显示哪个元素。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line">  animation-iteration-count: infinite; // 无限循环</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> myfirst &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ,</span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">24px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">48px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">72px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 兼容性的代码省略</span><br></pre></td></tr></table></figure><p>上面是基本的代码，但是我的条目是动态的，所以时间刻度需要动态计算，但是@keyframe 没有像元素样式的动态的属性，不能计算后赋值给元素； 在网上的查询后，最终使用动态给样式对象插入新的样式的方式来实现。</p><h2 id="动态更改-keyframes"><a href="#动态更改-keyframes" class="headerlink" title="动态更改@keyframes"></a>动态更改@keyframes</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleSheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>];</span><br><span class="line">styleSheet.insertRule(<span class="string">"keyframe的定义"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>网上的大致思路就是上面的代码，但是有几个坑。</p><h2 id="styleSheets-分内部和外部样式"><a href="#styleSheets-分内部和外部样式" class="headerlink" title="styleSheets 分内部和外部样式"></a>styleSheets 分内部和外部样式</h2><p>我在写 demo 测试的时候，由于我没有内嵌样式，所以看到的都是外部，所以我就把样式插入到了第一个里面，但是放到项目里面发现，竟然报错提示没有<code>rules</code>属性。因为如果有内嵌样式，第一个是内嵌样式，内嵌的 rules 属性是没有值的。所以为了保险不要直接在第一个对象中插入。最好插入到最后一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleSheet = <span class="built_in">document</span>.styleSheets[<span class="built_in">document</span>.styleSheets.length - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><h2 id="通过属性设置animation-name属性"><a href="#通过属性设置animation-name属性" class="headerlink" title="通过属性设置animation-name属性"></a>通过属性设置<code>animation-name</code>属性</h2><p>开始我是按照网上的写法，直接设置 animation 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">myfirst</span> 5<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure><p>由于我是 react，使用了 webpack 打包，打包后，名字<code>myfirst</code>被重新命名了。由于 demo 中的样式比价少，可以通过<code>document.styleSheets</code>看到，样式中 myfirst 被打包后的名字；并且也可以看到它的位置。<br>但是在项目中，样式比较多，根据打包后的名字去设置比较困难的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleSheet = <span class="built_in">document</span>.styleSheets[<span class="built_in">document</span>.styleSheets.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> keyframesName = styleSheet.rules[<span class="number">0</span>].name;</span><br><span class="line"><span class="keyword">const</span> keyframesStr = <span class="string">`<span class="subst">$&#123;keyframesName&#125;</span> &#123;0% &#123;</span></span><br><span class="line"><span class="string">          left: 0px;</span></span><br><span class="line"><span class="string">          top: 0px;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;keyframesItem.join(<span class="string">""</span>)&#125;</span></span></span><br><span class="line"><span class="string">      &#125;`</span>.replace(<span class="regexp">/\s+/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">const</span> keyframes = <span class="string">`@keyframes <span class="subst">$&#123;keyframesStr&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> keyframes_webdit = <span class="string">`@-webkit-keyframes <span class="subst">$&#123;keyframesStr&#125;</span>`</span>; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"></span><br><span class="line">styleSheet.insertRule(keyframes, styleSheet.rules.length);</span><br><span class="line">styleSheet.insertRule(keyframes_webdit, styleSheet.rules.length);</span><br></pre></td></tr></table></figure><h2 id="动态设置-keyframes"><a href="#动态设置-keyframes" class="headerlink" title="动态设置 keyframes"></a>动态设置 keyframes</h2><p>这个需要用到<code>insertRule()</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">styleSheet.insertRule(keyframes_webdit, styleSheet.rules.length);</span><br></pre></td></tr></table></figure><h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><ul><li>在样式中不指定 animation-name,通过 js 操作样式属性设置，这样生成 keyframes 时，就不用去获取打包生成的名字。</li><li>样式直接插入最后的 styleSheets 中</li><li>在 js 中指定<code>animationName</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局定义名字</span></span><br><span class="line"><span class="keyword">const</span> keyframesName = <span class="string">"text-carousel-keyframesName-key-asdf8324-df324s"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键代码</span></span><br><span class="line"><span class="keyword">const</span> styleSheet = <span class="built_in">document</span>.styleSheets[<span class="built_in">document</span>.styleSheets.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyframesStr = <span class="string">`<span class="subst">$&#123;keyframesName&#125;</span> &#123;0% &#123;</span></span><br><span class="line"><span class="string">          left: 0px;</span></span><br><span class="line"><span class="string">          top: 0px;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;keyframesItem.join(<span class="string">""</span>)&#125;</span></span></span><br><span class="line"><span class="string">      &#125;`</span>.replace(<span class="regexp">/\s+/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">const</span> keyframes = <span class="string">`@keyframes <span class="subst">$&#123;keyframesStr&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> keyframes_webdit = <span class="string">`@-webkit-keyframes <span class="subst">$&#123;keyframesStr&#125;</span>`</span>; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"></span><br><span class="line">styleSheet.insertRule(keyframes, styleSheet.rules.length);</span><br><span class="line">styleSheet.insertRule(keyframes_webdit, styleSheet.rules.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsx</span></span><br><span class="line"></span><br><span class="line"> &lt;section</span><br><span class="line">          className=&#123;styles.itemContainer&#125;</span><br><span class="line">          style=&#123;&#123;</span><br><span class="line">            animationDuration: animationDuration,</span><br><span class="line">            animationName: keyframesName,   <span class="comment">// 设置名字</span></span><br><span class="line">            ...contentStyle,</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.parentNode和node.parentElement的区别</title>
      <link href="/2020/06/11/node-parentNode%E5%92%8Cnode-parentElement%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/11/node-parentNode%E5%92%8Cnode-parentElement%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>这两个属性都是返回指定节点的在 DOM 树中的父节点。</p><h2 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h2><p>parentNode 是指定节点的父节点.一个元素节点的父节点可能是一个元素(Element )节点,也可能是一个文档(Document )节点,或者是个文档碎片(DocumentFragment)节点.</p><h2 id="parentElement"><a href="#parentElement" class="headerlink" title="parentElement"></a>parentElement</h2><p>返回当前节点的父元素节点，如果该元素没有父节点，或者父节点不是一个 DOM 元素，则返回 null。</p><p>从定义就可以看出差别，推荐使用<code>parentNode</code></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac录制屏幕声音QuickTime和Soundflower</title>
      <link href="/2020/05/27/mac%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95%E5%A3%B0%E9%9F%B3QuickTime%E5%92%8CSoundflower/"/>
      <url>/2020/05/27/mac%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95%E5%A3%B0%E9%9F%B3QuickTime%E5%92%8CSoundflower/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-Soundflower"><a href="#安装-Soundflower" class="headerlink" title="安装 Soundflower"></a>安装 Soundflower</h2><p>先装 Soundflower：<a href="https://github.com/mattingalls/Soundflower/releases" target="_blank" rel="noopener">https://github.com/mattingalls/Soundflower/releases</a><br>下载安装<code>Soundflower-2.0b2.dmg</code>文件<br><img src="https://i.loli.net/2020/05/27/muwJsMp7ZjoO9FN.jpg" alt="file-list.jpg"></p><p>下载成功后，运行 dmg</p><blockquote><p>如果出现打不开的提示，请参照 MacBook 在网上下载的软件打不开怎么办?<a href="https://jingyan.baidu.com/article/90bc8fc8ac7052f653640c91.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/90bc8fc8ac7052f653640c91.html</a></p></blockquote><p>双击 pkg 文件进行安装；然后按照引导一步一步安装就行</p><p>如果出现安装失败的提示，打开安装包里有 Uninstall Soundflower.scpt<br><img src="https://i.loli.net/2020/05/27/ZRnvWyajhJk3wsC.jpg" alt="uninstall.jpg"></p><p><img src="https://i.loli.net/2020/05/27/Q9Cv8TYyZM5Emt3.jpg" alt="unintall-done.jpg"><br>之后就可以安装成功了，还是错误的话 1.检查安全和隐私， 2.多执行几次 run</p><h2 id="音频-MIDI-设置"><a href="#音频-MIDI-设置" class="headerlink" title="音频 MIDI 设置"></a>音频 MIDI 设置</h2><p>在 应用程序 -&gt; 实用工具 里面找到“音频 MIDI 设置”<br><img src="https://i.loli.net/2020/05/27/gRXbLAQUTCKNOrx.png" alt="midi.png"><br>点左下角“+”，新建一个“聚集设备”，勾选右边的“内建麦克风”和“Soundflower(2ch)”。<br>再新建一个“多输出设备”，勾选“内建输出”和“Soundflower(2ch)”。<br><img src="https://i.loli.net/2020/05/27/hIWD3EXKRrVfleB.jpg" alt="newequipment.jpg"></p><h2 id="修改系统声音"><a href="#修改系统声音" class="headerlink" title="修改系统声音"></a>修改系统声音</h2><p>系统偏好设置 -&gt; 声音，输出，选“多输出设备”。<br><img src="https://i.loli.net/2020/05/27/FawbOSIAEjJi1mk.jpg" alt="output.jpg"><br>输入，选“聚集设备”。<br><img src="https://i.loli.net/2020/05/27/bvdxAYfRh7yW2me.jpg" alt="input.jpg"></p><p>这时候就能获取系统的声音了，可以使用讯飞语音转换文字测试下<br><a href="https://www.xfyun.cn/services/voicedictation" target="_blank" rel="noopener">https://www.xfyun.cn/services/voicedictation</a></p><h2 id="使用-QuickTime-录音电脑"><a href="#使用-QuickTime-录音电脑" class="headerlink" title="使用 QuickTime 录音电脑"></a>使用 QuickTime 录音电脑</h2><p>打开 QuickTime，文件 -&gt; 新建屏幕录制，点按钮旁边的小三角，麦克风选“聚集设备“<br><img src="https://i.loli.net/2020/05/27/98cKLChfVPpasJZ.jpg" alt="screem.jpg"><br>如果想只录系统的声音，则选择点按钮旁边的小三角，选择 Soundflower（2ch）就只有系统发出的声音而没有麦克风声音了。<br><img src="https://i.loli.net/2020/05/27/zrHaZ5eN7VIfxsw.jpg" alt="voice.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 电脑技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑技能 </tag>
            
            <tag> 电脑技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactDOM.render和ReactDOM.createPortal的区别</title>
      <link href="/2020/05/20/ReactDOM-render%E5%92%8CReactDOM-createPortal%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/20/ReactDOM-render%E5%92%8CReactDOM-createPortal%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在封装提醒组件时，因为提醒组件元素是动态创建的，<code>需要添加在当前组件的外部(不在root中)</code>，因为这种提醒的组件是全局使用的，和业务关系不大，并且是根据需要动态使用；<br>发现有用 <code>ReactDOM.createPortal</code>，而有的使用 <code>ReactDOM.render</code>，于是在网上找这俩的区别，也没很好的资料。于是详细的看了官网，并写了一些 demo 来测试和验证自己的理解。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(element, container[, callback])</span><br></pre></td></tr></table></figure><p>在提供的 container 里渲染一个 React 元素，并返回对该组件的引用（或者针对无状态组件返回 null）。</p><p>如果 React 元素之前已经在 container 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 DOM 以映射最新的 React 元素。</p><p>如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。</p><h3 id="createPortal"><a href="#createPortal" class="headerlink" title="createPortal()"></a>createPortal()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container)</span><br></pre></td></tr></table></figure><p>创建 portal。Portal 将提供一种将子节点渲染到 DOM 节点中的方式，<strong>该节点存在于 DOM 组件的层次结构之外</strong>。<br>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的<strong>优秀</strong>的方案。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>render()目前没有什么疑问，主要是 createPortal 的描述有些奇怪。<br>1.“该节点存在于 DOM 组件的层次结构之外”是什么意思？ 2.难道使用 render 不能把子节点渲染到父组件以外的 DOM 节点吗？ 3.为什么说 portal 的这个方案“优秀”？ 4.两者区别是什么？</p><blockquote><p>这四个问题你都知道答案，就没必要往下看了。</p></blockquote><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>1.“该节点存在于 DOM 组件的层次结构之外”是什么意思？</p><blockquote><p>这个很好理解，通常我们是把组件都渲染在页面上一个<code>id</code>为<code>root</code>的<code>div</code>容器中。这里所说的“之外”的意思，就是这个组件不渲染在<code>root</code>中，在一个新的容器中，也可以直接放到<code>body</code>最后。</p></blockquote><p>2.难道使用 render 不能把子节点渲染到父组件以外的 DOM 节点吗？</p><blockquote><p><strong>能</strong>！！！之前一直以为 render 只能使用一次，或者不能在额外的节点重新进行渲染，结果都不是。</p></blockquote><p>3.为什么说 portal 的这个方案“优秀”？ 两者的区别是什么？</p><blockquote><p>既然 render 也能在新的容器中渲染组件，为什么还要再新增一个 createPortal 方法呢，意义在哪？</p><p>意义在捕获事件，事件冒泡就不详细解释了。在使用 createPortal 渲染时，比如组件 A，虽然它渲染在一个新的元素中，但调用 A 的组件 B 是可以捕获 A 中的事件。如果使用 render 就无法捕获。</p><p>比如 B 的根元素上有一个 click 事件，如果使用 render 渲染 A，点击 A 的区域，B 的 click 事件是不会触发的；但如果使用 createPortal，则会触发。</p></blockquote><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPortal</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    root = <span class="built_in">document</span>.getElementById(<span class="string">"root1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// createPortal换成render测试</span></span><br><span class="line">    <span class="keyword">return</span> ReactDOM.createPortal(<span class="keyword">this</span>.props.children, root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestPortal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在APP.js中调用</span></span><br><span class="line">&lt;div</span><br><span class="line">  onClick=&#123;() =&gt; &#123;</span><br><span class="line">    alert(<span class="string">"触发了"</span>);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  hello</span><br><span class="line">  &lt;TestPortal&gt;</span><br><span class="line">    &lt;h1&gt;一个新的元素&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>TestPortal&gt;;</span><br><span class="line">&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure><p>这就是 createPortal 的奇特之处，虽然和父组件不在一个 dom 分支上，事件却会别捕获。</p><h2 id="什么时候使用createPortal"><a href="#什么时候使用createPortal" class="headerlink" title="什么时候使用createPortal"></a>什么时候使用createPortal</h2><p>一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框；</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> react </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站步骤引导组件实现</title>
      <link href="/2020/05/19/%E6%AD%A5%E9%AA%A4%E5%BC%95%E5%AF%BC%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/05/19/%E6%AD%A5%E9%AA%A4%E5%BC%95%E5%AF%BC%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>比较好用的组件有：</p><ol><li><a href="https://www.npmjs.com/package/driver.js" target="_blank" rel="noopener">driver.js</a></li><li><a href="https://github.com/shipshapecode/shepherd" target="_blank" rel="noopener">shepherd</a></li><li><a href="https://github.com/jrainlau/smartour/blob/master/README.zh.md" target="_blank" rel="noopener">smartour</a></li></ol><h2 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h2><p><code>smartour</code>中讲解了实现思路:<br>看到的遮罩层其实是阴影 box-shadow，但是阴影不会阻碍元素，页面上的元素还能点击，所以需要在下面再加一层透明的 div。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: h-shadow v-shadow blur spread color inset;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> component </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm安装包突然提示json报错</title>
      <link href="/2020/05/18/npm%E5%AE%89%E8%A3%85%E5%8C%85%E7%AA%81%E7%84%B6%E6%8F%90%E7%A4%BAjson%E6%8A%A5%E9%94%99/"/>
      <url>/2020/05/18/npm%E5%AE%89%E8%A3%85%E5%8C%85%E7%AA%81%E7%84%B6%E6%8F%90%E7%A4%BAjson%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>今天在安装一个包时，提示如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! Unexpected end of JSON input <span class="keyword">while</span> parsing near <span class="string">'...",'</span>解决方案</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看npm全局安装的包</title>
      <link href="/2020/05/18/%E6%9F%A5%E7%9C%8Bnpm%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/"/>
      <url>/2020/05/18/%E6%9F%A5%E7%9C%8Bnpm%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>老是忘，记录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list -g --depth 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOT和JIT是什么</title>
      <link href="/2020/04/13/AOT%E5%92%8CJIT%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/04/13/AOT%E5%92%8CJIT%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JIT，即 Just-in-time,动态(即时)编译，边运行边编译；AOT，Ahead Of Time，指运行前编译，是两种程序的编译方式</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>这两种编译方式的主要区别在于是否在“运行时”进行编译</p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><h3 id="JIT-优点"><a href="#JIT-优点" class="headerlink" title="JIT 优点"></a>JIT 优点</h3><p>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT 也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）<br>可以根据当前程序的运行情况生成最优的机器指令序列<br>当程序需要支持动态链接时，只能使用 JIT<br>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</p><h3 id="JIT-缺点"><a href="#JIT-缺点" class="headerlink" title="JIT 缺点"></a>JIT 缺点</h3><p>编译需要占用运行时资源，会导致进程卡顿<br>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡<br>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</p><h3 id="AOT-优点"><a href="#AOT-优点" class="headerlink" title="AOT 优点"></a>AOT 优点</h3><p>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗<br>可以在程序运行初期就达到最高性能<br>可以显著的加快程序的启动</p><h3 id="AOT-缺点"><a href="#AOT-缺点" class="headerlink" title="AOT 缺点"></a>AOT 缺点</h3><p>在程序运行前编译会使程序安装的时间增加</p><p>牺牲 Java 的一致性</p><p>将提前编译的内容保存会占用更多的外</p><p>与 Android 的关联</p><p>Android 在 2.2 的时候引入 JIT，在 kitkat 时新增了 ART(Android RunTime),在 Android L 时使用 ART 完全替代了 Dalvik 作为默认的虚拟机环境。</p><h2 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h2><h3 id="Dalvik-使用-JIT"><a href="#Dalvik-使用-JIT" class="headerlink" title="Dalvik 使用 JIT"></a>Dalvik 使用 JIT</h3><p>使用.dex 字节码，是针对 Android 设备优化后的 DVM 所使用的运行时编译字节码<br>.odex 是对 dex 的优化，deodex 在系统第一次开机时会提取所有 apk 内的 dex 文件，odex 优化将 dex 提前提取出，加快了开机的速度和程序运行的速度</p><h3 id="ART-使用-AOT"><a href="#ART-使用-AOT" class="headerlink" title="ART 使用 AOT"></a>ART 使用 AOT</h3><p>在安装 apk 时会进行预编译，生成 OAT 文件，仍以.odex 保存，但是与 Dalvik 下不同，这个文件是可执行文件<br>dex、odex 均可通过 dex2oat 生成 oat 文件，以实现兼容性<br>在大型应用安装时需要更多时间和空间</p><h3 id="Android-N-引入的混合编译"><a href="#Android-N-引入的混合编译" class="headerlink" title="Android N 引入的混合编译"></a>Android N 引入的混合编译</h3><p>在 Android N 中引入了一种新的编译模式，同时使用 JIT 和 AOT。这是我在网上找到的一些解释：</p><p>包含了一个混合模式的运行时。应用在安装时不做编译，而是解释字节码，所以可以快速启动。ART 中有一种新的、更快的解释器，通过一种新的 JIT 完成，但是这种 JIT 的信息不是持久化的。取而代之的是，代码在执行期间被分析，分析结果保存起来。然后，当设备空转和充电的时候，ART 会执行针对“热代码”进行的基于分析的编译，其他代码不做编译。为了得到更优的代码，ART 采用了几种技巧包括深度内联。<br>对同一个应用可以编译数次，或者找到变“热”的代码路径或者对已经编译的代码进行新的优化，这取决于分析器在随后的执行中的分析数据。</p><p>这些大概说的是新的 ART 在安装程序时使用 JIT，在 JIT 编译了一些代码后将这些代码保存到本地，等到设备空闲的时候将保存的这些代码使用 AOT 编译生成可执行文件保存到本地，待下次运行时直接使用，并且不断监视代码的更新，在代码有更新后重新生成可执行文件。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mac上创建bash_profile遇到的坑及解决方法</title>
      <link href="/2020/04/09/%E5%AD%A6%E4%B9%A0flutter%E6%97%B6%E6%B2%A1%E6%9C%89bash-profile%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/09/%E5%AD%A6%E4%B9%A0flutter%E6%97%B6%E6%B2%A1%E6%9C%89bash-profile%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天在学习 flutter 环境配置时，发现没有.bash_profile，于是我就百度了。统一的答案就是自己新建一个，然后把你的命令加进去就行了。我照做了，结果悲催了！</p><h2 id="所有命令失效了"><a href="#所有命令失效了" class="headerlink" title="所有命令失效了"></a>所有命令失效了</h2><p>自己 touch 了.bash_profile 后，发现所有命令都不管用了。ls 都不管用了！<br>于是只能通过界面使用 command+shift+.来显示所有文件，删除.bash_profile。<br>但是删除后，就没法永久设置 flutter 的启动路径了，设置临时的，那得多麻烦。<br>于是继续百度。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>还是自己新建一个</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bash_profile</span><br></pre></td></tr></table></figure><p>增加如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin</span><br></pre></td></tr></table></figure><p>增加这行后，原有的命令就不会失效了。</p><h2 id="增加-flutter-配置"><a href="#增加-flutter-配置" class="headerlink" title="增加 flutter 配置"></a>增加 flutter 配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:/Users/iss/软件/flutter/bin"</span></span><br></pre></td></tr></table></figure><p>前两行是 flutter 的镜像设置。<br>切记第三行和第四行的顺序不能乱，因为第四行使用了$PATH 环境变量，如果反了，就找不到 flutter 的真实路径了。</p><h2 id="git-命令不管用"><a href="#git-命令不管用" class="headerlink" title="git 命令不管用"></a>git 命令不管用</h2><p>在上面的配置完后，又安装了 xcode，结果发现 git 不管用了，解决方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><h2 id="hexo-不管用"><a href="#hexo-不管用" class="headerlink" title="hexo 不管用"></a>hexo 不管用</h2><p>使用 hexo 来写博客，使用 hexo 时发现命令不管用了。<br>把.profile 中的内容复制到.bash_profile 中管用了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/.npm-global/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h2 id="npm-的全局包命令不管用"><a href="#npm-的全局包命令不管用" class="headerlink" title="npm 的全局包命令不管用"></a>npm 的全局包命令不管用</h2><p>今天在使用了 npm 的全家包命令时，提示<code>command not found</code>；因为最近动过<code>bash_profile</code>，知道是这引起的。<br>但是 npm 命令都管用，经过艰苦的斗争，终于找到原因，原来是<code>.bash_profile</code>中 npm 路径的配置多了一个<code>:$PATH</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改前</span><br><span class="line"><span class="built_in">export</span> PATH=~/.npm-global/bin:<span class="variable">$PATH</span></span><br><span class="line">// 修改后</span><br><span class="line"><span class="built_in">export</span> PATH=~/.npm-global/bin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘点国内免费好用的图床</title>
      <link href="/2020/04/01/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
      <url>/2020/04/01/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>简单说图床就是一个在网络上存储图片的地方，目的是为了节省本地服务器空间，加快图片打开速度，主要是个人博客和网站使用</p><p>以下是详细的介绍，同时文中也提供了部分图片原文件链接供测试，建议大家看完全文再做选择</p><p>注意：由于微博技术升级，微博图床图片已经无法引用，因此请不要使用微博图床</p><h2 id="聚合图床-推荐"><a href="#聚合图床-推荐" class="headerlink" title="聚合图床-推荐"></a>聚合图床-推荐</h2><p>官网地址：<a href="https://www.superbed.cn" target="_blank" rel="noopener">https://www.superbed.cn</a></p><p>简介：将图片分发到多处备份，借助其本身的 CDN 加速功能，节省服务器流量，并且不用担心图片被删除，即便其中某几个图床上的图片被删除了，还有其他备份，保证万无一失，支持匿名和注册管理</p><p>图片上传限制：无</p><h2 id="路过图床-推荐"><a href="#路过图床-推荐" class="headerlink" title="路过图床-推荐"></a>路过图床-推荐</h2><p>官网地址：<a href="https://imgchr.com" target="_blank" rel="noopener">https://imgchr.com</a></p><p>简介：支持免注册上传图片，永久存储，支持 HTTPS 加密访问和调用图片，提供多种图片链接格式，成立于 2011 年</p><p>限制：最大 10M</p><h2 id="SM-MS-推荐"><a href="#SM-MS-推荐" class="headerlink" title="SM.MS-推荐"></a>SM.MS-推荐</h2><p>官网地址：<a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a></p><p>特点：永久存储免注册，图片链接支持 https，可以删除上传的图片，提供多种图片链接格式，建立于 2015 年，目前免费用户无法使用香港节点</p><p>图片上传限制：每个图片最大 5M，每次最多上传 10 张</p><h2 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h2><p>官网地址：<a href="https://portal.qiniu.com" target="_blank" rel="noopener">https://portal.qiniu.com</a></p><p>简介：注册认证后有 10G 永久免费空间，每月 10G 国内和 10G 国外流量，速度相当快，七牛云是国内专业 CDN 服务商，插件支持比较多，有免费 ssl 证书，但 https 流量收费</p><p>注意：七牛云 30 天后会回收测试域名，因此你必须要绑定自己的已经备案的域名</p><p>图片上传限制：无</p><h2 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h2><p>官网地址：<a href="https://www.upyun.com" target="_blank" rel="noopener">https://www.upyun.com</a></p><p>简介：注册认证后有 10G 永久免费空间，每月 15G 的 HTTP 和 HTTPS 流量，提供两款可以免费续期的 SSL 证书，不过用户需要加入又拍云联盟（即在网站底部添加又拍云 logo 及官网链接）</p><p>注意：需要绑定自己的已备案域名，又拍云认证比较麻烦，建议使用七牛云</p><p>图片上传限制：无</p><h2 id="腾讯云-免费有时间限制"><a href="#腾讯云-免费有时间限制" class="headerlink" title="腾讯云-免费有时间限制"></a>腾讯云-免费有时间限制</h2><p>官网地址：<a href="https://cloud.tencent.com" target="_blank" rel="noopener">https://cloud.tencent.com</a></p><p>简介：仅可以使用六个月的免费存储容量、免费请求和免费流量，不推荐使用</p><p>限制：时间、流量、空间大小均有限制</p><h2 id="ImgURL-经测试会删除图片"><a href="#ImgURL-经测试会删除图片" class="headerlink" title="ImgURL-经测试会删除图片"></a>ImgURL-经测试会删除图片</h2><p>官网地址：<a href="https://imgurl.org" target="_blank" rel="noopener">https://imgurl.org</a></p><p>开源代码：<a href="https://github.com/helloxz/imgurl" target="_blank" rel="noopener">https://github.com/helloxz/imgurl</a></p><p>简介：始于 2017 年底，由个人开发的图床，代码开源支持自建</p><p>限制：游客限制每日上传 10 张，单张图片不能超过 5M，上传的图片将公开显示，经测试会删除图片</p><h2 id="堆爱外链"><a href="#堆爱外链" class="headerlink" title="堆爱外链"></a>堆爱外链</h2><p>官网地址：<a href="http://pan.duiai.cc" target="_blank" rel="noopener">http://pan.duiai.cc</a></p><p>简介：注册才可以上传，存在的时间比较久，除了图片还可以上传视频和音乐</p><p>限制：视频体积过大不可，但具体限制不明</p><h2 id="小贱贱图床"><a href="#小贱贱图床" class="headerlink" title="小贱贱图床"></a>小贱贱图床</h2><p>官网地址：<a href="http://pic.xiaojianjian.net" target="_blank" rel="noopener">http://pic.xiaojianjian.net</a></p><p>需要注册，每日可以上传图片 30 张，上传后可以获取一个简单的外链，速度很快，但是图片清晰度会变低</p><h2 id="土豆图床"><a href="#土豆图床" class="headerlink" title="土豆图床"></a>土豆图床</h2><p>官方地址：<a href="https://images.ac.cn/" target="_blank" rel="noopener">https://images.ac.cn/</a></p><p>永久免费，托管在新浪服务器上</p><h2 id="图床工具"><a href="#图床工具" class="headerlink" title="图床工具"></a>图床工具</h2><p>PicGo：Molunerfinn/PicGo</p><p>MPic-图床神器：<a href="http://mpic.lzhaofu.cn" target="_blank" rel="noopener">http://mpic.lzhaofu.cn</a></p><h2 id="用开源图床自建"><a href="#用开源图床自建" class="headerlink" title="用开源图床自建"></a>用开源图床自建</h2><p>可以利用下面的开源代码搭建自己的图床，搭建自己的图床就是借助第三方提供的对象存储，把图片存储起来。</p><p><a href="https://www.xiebruce.top/644.html" target="_blank" rel="noopener">使用 nginx 负载均衡+多个云的免费额度打造免费 markdown 图床</a><br>lazy-koala/imgs-upload-srv<br><a href="https://www.xiebruce.top/17.html#MacWeb" target="_blank" rel="noopener">PicUploader: 一个还不错的图床工具</a><br><a href="https://github.com/skycity233/MDPIC" target="_blank" rel="noopener">使用 github 在 window 上搭建图床</a></p><p><a href="https://zhuanlan.zhihu.com/p/35270383?ivk_sa=1023345p" target="_blank" rel="noopener">转自：https://zhuanlan.zhihu.com/p/35270383?ivk_sa=1023345p</a></p>]]></content>
      
      
      <categories>
          
          <category> 电脑技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrollTop获取为0兼容解决方案</title>
      <link href="/2020/03/25/scrollTop%E8%8E%B7%E5%8F%96%E4%B8%BA0%E5%85%BC%E5%AE%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/03/25/scrollTop%E8%8E%B7%E5%8F%96%E4%B8%BA0%E5%85%BC%E5%AE%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>对于没有 doctype 声明的页面用 document.body.scrollTop</p><h3 id="Chrome、Firefox"><a href="#Chrome、Firefox" class="headerlink" title="Chrome、Firefox"></a>Chrome、Firefox</h3><p>对于有 doctype 声明的页面，则使用<br>document.documentElement.scrollTop</p><h3 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h3><p>safari 比较特别，有自己获取 scrollTop 的函数 ： window.pageYOffset；只读属性 pageYOffset 是 scrollY 的别名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollTop =</span><br><span class="line">  <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line"><span class="keyword">const</span> scrollLeft =</span><br><span class="line">  <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.body.scrollLeft || <span class="built_in">document</span>.documentElement.scrollLeft;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getScrollCoord</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> scrollTop = <span class="built_in">window</span>.scrollY || <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">  <span class="keyword">const</span> scrollLeft =</span><br><span class="line">    <span class="built_in">window</span>.scrollX || <span class="built_in">document</span>.body.scrollLeft || <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">  <span class="keyword">return</span> &#123; scrollTop, scrollLeft &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react开发并发布和更新一个npm包</title>
      <link href="/2020/03/20/react%E5%BC%80%E5%8F%91%E5%B9%B6%E5%8F%91%E5%B8%83%E5%92%8C%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AAnpm%E5%8C%85/"/>
      <url>/2020/03/20/react%E5%BC%80%E5%8F%91%E5%B9%B6%E5%8F%91%E5%B8%83%E5%92%8C%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AAnpm%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>最近开发了一个 npm 包，并发布到了官网上，下面记录下开发过程。<br><a href="https://github.com/codepandy/tabheader_react" target="_blank" rel="noopener">github 代码地址</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>注册 npm 账号</li><li>认证 npm，不然不能发布包；（会给你发认证邮件）</li><li>设置 npm 源为官网</li></ol><h3 id="查看和设置-npm-源"><a href="#查看和设置-npm-源" class="headerlink" title="查看和设置 npm 源"></a>查看和设置 npm 源</h3><p>在国内我们通常都设置成了淘宝的仓库<code>（https://registry.npm.taobao.org）</code>，这样是发布不了的。需要设置回官网的仓库连接<code>（https://registry.npmjs.org/）</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看</span><br><span class="line">npm config get registry</span><br><span class="line">// 设置</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>由于我使用的 react，搭建环境就是搭建 react 的开发环境。这里不做过多介绍。<br>只介绍几个发布组件相关的配置和注意事项。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><ul><li>main 字段设置的就是在引入你的程序时，执行的文件。</li><li>files 设置的是要发布到 npm 的文件。如果省略掉这一项，所有文件包括源代码会被一起上传到 npm</li><li>keywords 设置搜索关键字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"name"</span>: <span class="string">"tabheader-react"</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="string">"1.0.2"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">"a tabheader component for react."</span>,</span><br><span class="line"><span class="string">"main"</span>: <span class="string">"./build/bundle.js"</span>,</span><br><span class="line"><span class="string">"files"</span>: [</span><br><span class="line">  <span class="string">"build"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"webpack-dev-server --config webpack.dev.js"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --config webpack.pro.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"keywords"</span>: [</span><br><span class="line">  <span class="string">"react"</span>,</span><br><span class="line">  <span class="string">"tab"</span>,5</span><br><span class="line">  <span class="string">"header"</span>,</span><br><span class="line">  <span class="string">"tabheader"</span>,</span><br><span class="line">  <span class="string">"tabheader-react"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"author"</span>: <span class="string">"wenmu"</span>,</span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.cn/files/package.json/" target="_blank" rel="noopener">package.json 详情介绍</a></p><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>webpack 的配置需要注意的就是生产环境时，设置<code>libraryTarget</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, "build"),</span><br><span class="line">  filename: "bundle.js",</span><br><span class="line">  libraryTarget: "commonjs2",</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>libraryTarget 设置暴露的包类型，默认是 var，也就是变量的方式。这个要设置成模块的方式，这样可以通过模块的方式来引入。</p><h3 id="babel-的配置"><a href="#babel-的配置" class="headerlink" title="babel 的配置"></a>babel 的配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>, <span class="string">"@babel/preset-react"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-proposal-class-properties"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>程序开发完后，就可以打包发布了。上面也配置了发布的文件是哪些。<br>打包和发布其实也很简单，就是单纯的把组件的代码打包然后发布就行了。<br>在组件代码的根目录执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm build</span><br></pre></td></tr></table></figure><p>打包成功后，登录 npm 然后发布组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br><span class="line"></span><br><span class="line">// 登录成功后，执行发布命令</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>成功后，就可以在<a href="https://www.npmjs.com/settings/wenmu/packages" target="_blank" rel="noopener">npm 官网</a>查看你发布的 package，并且在<code>npm</code>也能搜索到了。</p><h2 id="本地调试-link"><a href="#本地调试-link" class="headerlink" title="本地调试 link"></a>本地调试 link</h2><p>在开发组件时，还没发布到仓库，如何安装调试呢？这个可以使用<code>npm link</code>命令来实现。</p><h3 id="link组件到global-node-modules"><a href="#link组件到global-node-modules" class="headerlink" title="link组件到global node_modules"></a><code>link</code>组件到<code>global node_modules</code></h3><p>在组件的根目录执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><blockquote><p>如果组件文件是在根目录，那么 link 后，代码有改动，引用的项目里面立马会体现出来，但是如果代码是在 src 目录下，需要 build 代码项目中才能看到修改后的效果；也可以直接是 src 目录中 link</p></blockquote><p>使用下面命令查看是否 link 成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看全局安装的包</span><br><span class="line">npm list -g --depth 0</span><br></pre></td></tr></table></figure><h3 id="使用link的组件"><a href="#使用link的组件" class="headerlink" title="使用link的组件"></a>使用<code>link</code>的组件</h3><p>进入到项目的根目录，执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link your_component_name</span><br></pre></td></tr></table></figure><p>成功后，就可以在你的项目中使用组件了，使用方式和安装的组件一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import TabHeader from <span class="string">'tabheader_react'</span></span><br></pre></td></tr></table></figure><h3 id="解除link"><a href="#解除link" class="headerlink" title="解除link"></a>解除<code>link</code></h3><ol><li>在项目中解除<br>进入引用组件的根目录，执行命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink your_component_name</span><br></pre></td></tr></table></figure><ol start="2"><li>从<code>global node_modules</code>解除<br>进入组件的根目录，执行下面命令，注意后面不要跟组件名</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink</span><br></pre></td></tr></table></figure><h2 id="更新-npm-包"><a href="#更新-npm-包" class="headerlink" title="更新 npm 包"></a>更新 npm 包</h2><p>发布了 npm 包后，如果有修改，我们需要发布更新，步骤如下：</p><ol><li>提交代码，如果你的代码已经用<code>git</code>托管，先提交代码，不然发布会报错</li><li>修改版本号<br>修改版本号，官方提供了的命令，当执行后，package.json 文件会自动被修改。命令如下：<br>比如现在版本是 1.0.0</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 最后一位加1，执行命令后未：1.0.1</span><br><span class="line">npm version patch</span><br><span class="line"></span><br><span class="line">// 第二位加1，执行后：1.1.0</span><br><span class="line">npm version minor</span><br><span class="line"></span><br><span class="line">// 第一位加1，执行后：2.0.0</span><br><span class="line">npm version major</span><br></pre></td></tr></table></figure><ol start="3"><li>发布更新<br>通过上面修改过版本号后，执行下面命令重新发布，线上的就会被更新了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><h2 id="You-must-sign-up-for-private-packages"><a href="#You-must-sign-up-for-private-packages" class="headerlink" title="You must sign up for private packages"></a>You must sign up for private packages</h2><p>今天在发布包时，提示类似的名字已经有了，建议加上范围，如(“@wenmu/steps-react”)，在 package.json 的 name 上加上范围。<br>但是加上后就报错了。一直提示<code>You must sign up for private packages</code>.</p><p>Scoped packages 会被自动发布为私有包，发布成公共的就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure><p>在写组件时，又遇到一种情况,如下提示，也是加上范围就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! 403 403 Forbidden - PUT https://registry.npmjs.org/xx-xx - You <span class="keyword">do</span> not have permission to publish <span class="string">"xx-xx-xx"</span>. Are you logged <span class="keyword">in</span> as the correct user?</span><br></pre></td></tr></table></figure><p>这其实也是重名了。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> component </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的target=\&quot;_blank\&quot;</title>
      <link href="/2020/03/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84target-blank/"/>
      <url>/2020/03/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84target-blank/</url>
      
        <content type="html"><![CDATA[<p>我们知道，网页里的 a 标签默认在当前窗口跳转链接地址，如果需要在新窗口打开，需要给 a 标签添加一个 <code>target=&quot;_blank&quot;</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://blog.wangpengpeng.site/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>打开新窗口<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>顺便提下一个有意思的现象，很早之前我就发现，国外网站倾向于在当前页跳转，而国内网站喜欢打开新窗口。不信你们可以去验证下。我不知道这是交互设计上的文化差异，还是技术上的开发习惯。</p><p>当然，这两种方式各有优缺点。当前页跳转显得操作比较有连贯性，不会贸然打断用户的注意力，也会减少浏览器的窗口（tab 页）数量。但是对于需要反复回到初始页面的场景来说，就很麻烦了。比如搜索结果页面，通常需要查看对比几个目标地址，保留在多个窗口还是比较方便。</p><p>今天要说的不只是用户体验上的差别，而是涉及安全和性能。</p><h2 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h2><p>如果只是加上 <code>target=&quot;_blank&quot;</code>，打开新窗口后，新页面能通过 <code>window.opener</code> 获取到来源页面的 <code>window</code> 对象，即使跨域也一样。虽然跨域的页面对于这个对象的属性访问有所限制，但还是有漏网之鱼。</p><p><img src="https://s1.ax1x.com/2020/03/15/815rS1.md.png" alt="参考图片"></p><p>这是某网页打开新窗口的页面控制台输出结果。可以看到 <code>window.opener</code> 的一些属性，某些属性的访问被拦截，是因为跨域安全策略的限制。</p><p>即便如此，还是给一些操作留下可乘之机。比如修改 <code>window.opener.location</code> 的值，指向另外一个地址。你想想看，刚刚还是在某个网站浏览，随后打开了新窗口，结果这个新窗口神不知鬼不觉地把原来的网页地址改了。这个可以用来做什么？钓鱼啊！等你回到那个钓鱼页面，已经伪装成登录页，你可能就稀里糊涂把账号密码输进去了。</p><p>还有一种玩法，如果你处于登录状态，有些操作可能只是发送一个 GET 请求就完事了。通过修改地址，就执行了非你本意的操作，其实就是 CSRF 攻击。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>除了安全隐患外，还有可能造成性能问题。通过 <code>target=&quot;_blank&quot;</code>打开的新窗口，跟原来的页面窗口共用一个进程。如果这个新页面执行了一大堆性能不好的 <code>JavaScript</code> 代码，占用了大量系统资源，那你原来的页面也会受到池鱼之殃。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>尽量不使用 <code>target=&quot;_blank&quot;</code>，如果一定要用，需要加上 <code>rel=&quot;noopener&quot;</code>或者 <code>rel=&quot;noreferrer&quot;</code>。这样新窗口的 window.openner 就是 null 了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。</p><blockquote><p>在看到这个文章的时候，在自己的项目中试了下，结果 eslint 给了警告，给的建议是如下写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rel=<span class="string">"noopener noreferrer"</span></span><br></pre></td></tr></table></figure></blockquote><p>我特意用自己的博客网站 <code>http://www.kaysonli.com/</code> 试了一下，点击里面的外链打开新页面，<code>window.openner</code> 都是 <code>null</code>。查看页面元素发现，<code>a</code> 标签都加上了 <code>rel=&quot;noreferrer&quot;</code>。博客是用 <code>Hexo</code> 生成的，看来这种设置已经成了基本常识了。</p><p>另外，对于通过 window.open 的方式打开的新页面，可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yourWindow = <span class="built_in">window</span>.open();</span><br><span class="line">yourWindow.opener = <span class="literal">null</span>;</span><br><span class="line">yourWindow.location = <span class="string">"http://someurl.here"</span>;</span><br><span class="line">yourWindow.target = <span class="string">"_blank"</span>;</span><br></pre></td></tr></table></figure><p>希望这个小技巧对你有用。</p><p><a href="http://kaysonli.com/2020/03/15/unsafe-target-blank/#more" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browserslist</title>
      <link href="/2020/03/05/browserslist/"/>
      <url>/2020/03/05/browserslist/</url>
      
        <content type="html"><![CDATA[<h1 id="browserslist-是干什么的？"><a href="#browserslist-是干什么的？" class="headerlink" title="browserslist 是干什么的？"></a>browserslist 是干什么的？</h1><p><a href="https://www.npmjs.com/package/browserslist" target="_blank" rel="noopener">browserslist</a>提供了配置你的项目是以哪些浏览器需要去兼容；在不同的前端工具之间共享目标浏览器和 Node.js 版本的配置。目前使用它的工具有：</p><ul><li><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a></li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-preset-env" target="_blank" rel="noopener">Babel</a></li><li><a href="https://github.com/jonathantneal/postcss-preset-env" target="_blank" rel="noopener">postcss-preset-env</a></li><li><a href="https://github.com/amilajack/eslint-plugin-compat" target="_blank" rel="noopener">eslint-plugin-compat</a></li><li><a href="https://github.com/ismay/stylelint-no-unsupported-browser-features" target="_blank" rel="noopener">stylelint-no-unsupported-browser-features</a></li><li><a href="https://github.com/jonathantneal/postcss-normalize" target="_blank" rel="noopener">postcss-normalize</a></li><li><a href="https://github.com/ElemeFE/obsolete-webpack-plugin" target="_blank" rel="noopener">obsolete-webpack-plugin</a></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i browserslist</span><br></pre></td></tr></table></figure><p>在 package.json 中增加配置(也可以在文件<code>.browserslistrc</code>中配置)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"browserslist"</span>: [</span><br><span class="line">  <span class="string">"defaults"</span>,</span><br><span class="line">  <span class="string">"not IE 11"</span>,</span><br><span class="line">  <span class="string">"not IE_Mob 11"</span>,</span><br><span class="line">  <span class="string">"maintained node versions"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><p>所有支持 browserslist 的组件，都将会自动找目标浏览器，然后生成对应的兼容代码。</p><h2 id="一些常用的查询组合的含义"><a href="#一些常用的查询组合的含义" class="headerlink" title="一些常用的查询组合的含义"></a>一些常用的查询组合的含义</h2><table><thead><tr><th>参数</th><th align="left">价格</th></tr></thead><tbody><tr><td>defaults</td><td align="left">&gt; 0.5%, last 2 versions, Firefox ESR, not dead</td></tr><tr><td>&gt; 5%</td><td align="left">全球超过 5%的人在使用的浏览器；同时支持&gt;=、&lt;、&lt;=</td></tr><tr><td>&gt; 5% in CN</td><td align="left">在中国被超过 5%人使用的浏览器；<a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements" target="_blank" rel="noopener">双字符国家缩写</a></td></tr><tr><td>ie 6-8</td><td align="left">版本在指定范围内的浏览器</td></tr><tr><td>Firefox &gt; 20</td><td align="left">版本号大于 20 的火狐浏览器</td></tr><tr><td>iOS 7</td><td align="left">指定版本的浏览器</td></tr><tr><td>since 2013</td><td align="left">2013 年后发布的所有版本</td></tr><tr><td>last 2 versions</td><td align="left">每个浏览器最近的 2 个版本</td></tr><tr><td>last 2 Chrome versions</td><td align="left">chrome 最近的 2 个版本</td></tr><tr><td>not ie &lt;= 8</td><td align="left">兼容大于版本 8 的 ie 浏览器</td></tr><tr><td>dead</td><td align="left">官方不再支持或 24 个月内没更新的浏览器。目前有 IE 10、IE_Mob 10、黑莓 10、黑莓 7、三星 4 和 OperaMobile 12.1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> 兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react在ie中空白解决方案</title>
      <link href="/2020/03/05/react%E5%9C%A8ie%E4%B8%AD%E7%A9%BA%E7%99%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/03/05/react%E5%9C%A8ie%E4%B8%AD%E7%A9%BA%E7%99%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react+dva+roadhog+antd</span><br></pre></td></tr></table></figure><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>原来开发公司只要求兼容 chrome 即可，所以 ie 的兼容性一直没注意，突然在 ie 上查看，竟然是空白，显示不了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>安装<code>setprototypeof</code>，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save setprototypeof</span><br></pre></td></tr></table></figure><p>然后在入口文件中设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="built_in">require</span>(<span class="string">"setprototypeof"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="在此之前做的工作"><a href="#在此之前做的工作" class="headerlink" title="在此之前做的工作"></a>在此之前做的工作</h2><p>上面的解决方案是做了之后，直接解决了问题。但是在此之前，还做了一些工作，如果你上面的方法没解决，可以按照下面的路线做一下。</p><h3 id="添加babel-polyfill"><a href="#添加babel-polyfill" class="headerlink" title="添加babel/polyfill"></a>添加<code>babel/polyfill</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure><p>然后在入口文件的<code>第一行引入</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"@babel/polyfill"</span>;</span><br></pre></td></tr></table></figure><p>有的人这样就解决了，但是我的没有解决。</p><h3 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h3><p>这个插件可以配置不同的组件需要兼容的浏览器，react 的各个组件会根据它的配置生成对应的兼容代码，具体可查看官网的介绍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i browserslist</span><br></pre></td></tr></table></figure><p>然后在 package.json 中配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": [</span><br><span class="line">  "&gt; 1%",</span><br><span class="line">  "last 2 versions",</span><br><span class="line">  <span class="string">"IE 10"</span> <span class="comment">// 或者 ie &gt; 9</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>查看支持的浏览器列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx browserslist</span><br></pre></td></tr></table></figure><p>执行后，会列举出所有支持的浏览器列表</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令记录</title>
      <link href="/2020/03/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/03/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Git-全局设置"><a href="#Git-全局设置" class="headerlink" title="Git 全局设置"></a>Git 全局设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"username"</span></span><br><span class="line">git config --global user.email <span class="string">"username@mail.com"</span></span><br></pre></td></tr></table></figure><h3 id="创建新版本库"><a href="#创建新版本库" class="headerlink" title="创建新版本库"></a>创建新版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://gitlab-in.bingex.com/store/ss-oco.git</span><br><span class="line"><span class="built_in">cd</span> ss-oco</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"add README"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="本地已存在的项目"><a href="#本地已存在的项目" class="headerlink" title="本地已存在的项目"></a>本地已存在的项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin http://gitlab-in.bingex.com/store/ss-oco.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line">git pull origin master --allow-unrelated-historie</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="已存在的-Git-版本库"><a href="#已存在的-Git-版本库" class="headerlink" title="已存在的 Git 版本库"></a>已存在的 Git 版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> existing_repo</span><br><span class="line">git remote add origin http://gitlab-in.bingex.com/store/ss-oco.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure><h3 id="另一种关联方式"><a href="#另一种关联方式" class="headerlink" title="另一种关联方式"></a>另一种关联方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">…or create a new repository on the <span class="built_in">command</span> line</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"# CouponCard"</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin https://github.com/codepandy/CouponCard.git</span><br><span class="line">git push -u origin master</span><br><span class="line">…or push an existing repository from the <span class="built_in">command</span> line</span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/codepandy/CouponCard.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="查看分支是根据哪个分支创建的"><a href="#查看分支是根据哪个分支创建的" class="headerlink" title="查看分支是根据哪个分支创建的"></a>查看分支是根据哪个分支创建的</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog --data=<span class="built_in">local</span> --all | grep 要查询的分支名称</span><br></pre></td></tr></table></figure><h3 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -am <span class="string">"提交说明"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="切换到远程其他分支"><a href="#切换到远程其他分支" class="headerlink" title="切换到远程其他分支"></a>切换到远程其他分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><h3 id="以当前分支创建新的分支"><a href="#以当前分支创建新的分支" class="headerlink" title="以当前分支创建新的分支"></a>以当前分支创建新的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b NewBranch <span class="comment"># NewBranch 是新的分支名</span></span><br><span class="line">git push --<span class="built_in">set</span>-upstream origin NewBranch <span class="comment"># 把本地分支同步到远程仓库，--set-upstream缩写是-u</span></span><br></pre></td></tr></table></figure><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D BranchName</span><br></pre></td></tr></table></figure><h3 id="查看本地配置信息"><a href="#查看本地配置信息" class="headerlink" title="查看本地配置信息"></a>查看本地配置信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure><h3 id="查看当前用户名和-email"><a href="#查看当前用户名和-email" class="headerlink" title="查看当前用户名和 email"></a>查看当前用户名和 email</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h3 id="更改-git-本地配置用户名"><a href="#更改-git-本地配置用户名" class="headerlink" title="更改 git 本地配置用户名"></a>更改 git 本地配置用户名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">'new_name'</span></span><br><span class="line">git config user.email <span class="string">'new_email'</span></span><br></pre></td></tr></table></figure><h3 id="更改远程仓库地址"><a href="#更改远程仓库地址" class="headerlink" title="更改远程仓库地址"></a>更改远程仓库地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin URL // 更换远程仓库地址，URL为新地址。</span><br></pre></td></tr></table></figure><h3 id="查看合并到-master-上的分支"><a href="#查看合并到-master-上的分支" class="headerlink" title="查看合并到 master 上的分支"></a>查看合并到 master 上的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master <span class="comment">#列出合并到母版中的分支</span></span><br><span class="line"></span><br><span class="line">git branch --merged    <span class="comment">#列出合并到HEAD中的分支（即当前分支的尖端）</span></span><br><span class="line"></span><br><span class="line">git branch --no-merged   <span class="comment">#列出尚未合并的分支</span></span><br><span class="line"></span><br><span class="line">默认情况下，这仅适用于本地分支。该-a标志将显示本地和远程分支，并且-r标志仅显示远程分支。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json的browserlist配置</title>
      <link href="/2020/03/04/package-json%E7%9A%84browserlist%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/04/package-json%E7%9A%84browserlist%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在很多项目中看到 <code>package.json</code> 有 <code>browserlist</code> 的配置，这个是在不同的前端工具之间共享目标浏览器和 Node.js 版本的配置，使用这个配置的工具有：</p><ul><li>Autoprefixer</li><li>Babel</li><li>postcss-preset-env</li><li>eslint-plugin-compat</li><li>stylelint-no-unsupported-browser-features</li><li>postcss-normalize</li><li>obsolete-webpack-plugin</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i browserslist</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 兼容性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> 兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-failed-to-install-correctly</title>
      <link href="/2020/02/28/Electron-failed-to-install-correctly/"/>
      <url>/2020/02/28/Electron-failed-to-install-correctly/</url>
      
        <content type="html"><![CDATA[<p>Electron 一直报版本安装不对，升级到 7.0.0 开始就有这个问题。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用 7 以下的版本，7 以下最大的稳定版本是 6.1.5</p><h3 id="使用-7-的方法"><a href="#使用-7-的方法" class="headerlink" title="使用 7 的方法"></a>使用 7 的方法</h3><p><a href="https://blog.csdn.net/u013584271/article/details/102764898" target="_blank" rel="noopener">https://blog.csdn.net/u013584271/article/details/102764898</a></p>]]></content>
      
      
      <categories>
          
          <category> electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react中input文本框提示由非控组件切换为受控组件</title>
      <link href="/2020/02/28/react%E4%B8%ADinput%E6%96%87%E6%9C%AC%E6%A1%86%E6%8F%90%E7%A4%BA%E7%94%B1%E9%9D%9E%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%88%87%E6%8D%A2%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/02/28/react%E4%B8%ADinput%E6%96%87%E6%9C%AC%E6%A1%86%E6%8F%90%E7%A4%BA%E7%94%B1%E9%9D%9E%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%88%87%E6%8D%A2%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: A component is changing an uncontrolled input of <span class="built_in">type</span> text to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa).</span><br></pre></td></tr></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>这是因为在给 input 的赋值的变量默认值是 undefined，做下处理，如果是 undefined 的就返回空字符串就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">"text"</span></span><br><span class="line">  className=<span class="string">"flex-grow-1 input-text"</span></span><br><span class="line">  placeholder=<span class="string">"请输入文件名称"</span></span><br><span class="line">  ref=&#123;title_ref&#125;</span><br><span class="line">  value=&#123;title || <span class="string">""</span>&#125; <span class="comment">// title的默认是undefined了</span></span><br><span class="line">  onChange=&#123;onChangeTitle&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中变量重复声明</title>
      <link href="/2020/02/28/js%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E/"/>
      <url>/2020/02/28/js%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><p>先做道题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">num</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>知道 js 的变量声明和方法声明提升特性的同学应该都知道，输出肯定不会是 10.<br>《你不知道的 javascript（上）》中说到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数优先：</span><br><span class="line">函数声明和变量声明都会提升，但值得注意的一个细节是，函数会优先被提升，然后才是变量。</span><br></pre></td></tr></table></figure><p>从上得知，那输出结果就是<code>undefine</code>,是不是被自己的英明神武所折服了，哈哈，那你就错了，结果应该是<code>function(){}</code></p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>既然方法优先被提升，那不应该被后面的变量给覆盖吗？<br>你可以试下下面的 demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><p>结果是 10，不是 undefined；</p><p>《JavaScript 高级程序设计》第 7.3 章节又说了：</p><blockquote><p>JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这就解释了第一道题的答案了，既然 num 已经是 function，但后面变量提升，提升并没有初始化，所以被忽略。（提升只是提升声明，初始化不提升）</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generator笔记</title>
      <link href="/2020/02/28/Generator%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/28/Generator%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"world"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"ending"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><h3 id="第一次调用时不执行"><a href="#第一次调用时不执行" class="headerlink" title="第一次调用时不执行"></a>第一次调用时不执行</h3><blockquote><p>当第一次调用时不执行，只是返回一个函数指针。<br>只有当调用<code>next()</code>时才执行函数，并遇到第一个<code>yield</code>时停止，返回<code>yield</code>的值。<br>每次调用<code>next()</code>时，启动原来的暂停，并执行到下一个<code>yield</code>或<code>return</code><br>遇到<code>return</code>直接结束。如果没有<code>return</code>，则在执行完<code>yield</code>后，<strong>下一个 next()才结束</strong>。<br><code>yield</code>不是必须的</p></blockquote><h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><blockquote><p>需要注意的是，yield 表达式后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中对数据类型的总结及判断数据类型的各种方法及优缺点</title>
      <link href="/2020/02/28/js%E4%B8%AD%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2020/02/28/js%E4%B8%AD%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="js-中的数据类型"><a href="#js-中的数据类型" class="headerlink" title="js 中的数据类型"></a>js 中的数据类型</h3><p>js 中只有<code>六种</code>原始数据类型和一个<code>Object</code>:</p><blockquote><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>String</li><li>Symbol (ECMAScript 6 新定义)</li><li>Object</li></ul></blockquote><p>大家认真记清这个描述，不要到时候把 Array、Date 都当成 js 的数据类型就尴尬了。那可能会有人问，那 Array 和 Date 算什么呢，他们都属于 Object，看下面分类：</p><h3 id="Object-分类"><a href="#Object-分类" class="headerlink" title="Object 分类"></a>Object 分类</h3><blockquote><p>Object 分为<strong>本地对象</strong>、<strong>内置对象</strong>和<strong>宿主对象</strong>三种</p></blockquote><h3 id="本地对象"><a href="#本地对象" class="headerlink" title="本地对象"></a>本地对象</h3><blockquote><p>定义：独立于宿主环境的 ECMAScript 实现提供的对象。简单的说就是 ECMA 定义的类。他们包括：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object   Function   Array   String</span><br><span class="line">Boolean   Number  Date RegExp</span><br><span class="line">Error   EvalError   RangeError  ReferenceError</span><br><span class="line">SyntaxError   TypeError URIError</span><br></pre></td></tr></table></figure><p>所以 Array 和 Date 都属于对象类型，它们是本地对象。</p><hr><h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><p>1.有人可能会问，为什么 String 也是 Object 类型，上面不是说了是原始类型吗？<br>答：原始类型中有字符串 String 不错，它只是表达了一种数据类型，但数据类型也有自己的类定义啊，是吧，上面的 String 说的就是它的类型定义，是个对象，所以当然也是引用类型了。其他同理。<br>看下面 demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">typeof</span> str1; <span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> str2; <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想获取str2的字符串，可以通过str2.toString()</span></span><br><span class="line"></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><blockquote><p>定义：“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已经被实例化了。<br>内置对象只有两个<code>Global</code>和<code>Math</code>,他们其实也是本地对象，根据定义每个内置对象都是本地对象。</p></blockquote><h3 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h3><blockquote><p>所有非本地对象都是宿主对象，即由 ECMAScript 实现的宿主环境提供的对象。所有<code>BOM</code>和<code>DOM</code>对象都是宿主对象。</p></blockquote><hr><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>最常见的判断方法：typeof,它的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">官方解释</a>：</p><blockquote><p>typeof 操作符返回一个字符串，表示未经计算的操作数的类型。<br>简单理解就是<code>typeof</code>是判断的是原始类型（值类型），但函数返回的是<code>function</code>，null 返回的也是<code>object</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Undefined; <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="keyword">typeof</span> num; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="typeof-各类型返回结果列表"><a href="#typeof-各类型返回结果列表" class="headerlink" title="typeof 各类型返回结果列表"></a>typeof 各类型返回结果列表</h3><table><thead><tr><th>类型</th><th>结果</th></tr></thead><tbody><tr><td>Undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Symbol （ECMAScript 6 新增）</td><td>“symbol”</td></tr><tr><td>宿主对象（由 JS 环境提供）</td><td>Implementation-dependent</td></tr><tr><td>函数对象（[[Call]] 在 ECMA-262 条款中实现了）</td><td>“function”</td></tr><tr><td>任何其他对象</td><td>“object”</td></tr></tbody></table><h3 id="为什么-typeof-null-是-object"><a href="#为什么-typeof-null-是-object" class="headerlink" title="为什么 typeof null 是 object"></a>为什么 typeof null 是 object</h3><blockquote><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签也成为了 0，typeof null 就错误的返回了”object”。</p></blockquote><h3 id="typeof-优缺点列表"><a href="#typeof-优缺点列表" class="headerlink" title="typeof 优缺点列表"></a>typeof 优缺点列表</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>判断原始类型比较方便</td><td>null 返回的是 object</td></tr><tr><td></td><td>方法返回的是 function</td></tr><tr><td></td><td>所有的引用类型都返回 object,Array、Date 等不能准确定位</td></tr></tbody></table><hr><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p>定义：“instanceof 运算符用来测试一个<strong>对象（第一个参数）</strong>在其原型链中是否存在一个构造函数（第二个参数）的 prototype 属性。”<br>简单理解就是：instanceof 是判断两个对象“最近”prototype 是否一样。<br>另外，instanceof 是判断对象是否属于某一类型，而不是获取的对象的类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1=<span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> str2=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">man.prototype=<span class="keyword">new</span> person();</span><br><span class="line"><span class="keyword">var</span> m1=<span class="keyword">new</span> person();</span><br><span class="line"><span class="keyword">var</span> m2=<span class="keyword">new</span> man();</span><br><span class="line"></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span>    <span class="comment">//false</span></span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span>    <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>      <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">window</span>.frames[<span class="number">0</span>].Array  <span class="comment">//false</span></span><br><span class="line">m1 <span class="keyword">instanceof</span> person      <span class="comment">//true</span></span><br><span class="line">m2 <span class="keyword">instanceof</span> man         <span class="comment">//true</span></span><br><span class="line">m2 intanceof person       <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="优缺点列表"><a href="#优缺点列表" class="headerlink" title="优缺点列表"></a>优缺点列表</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>判断对象的具体类型</td><td>只能判断对象，对原始类型不能判断</td></tr><tr><td></td><td>多全局对象时返回不正确</td></tr></tbody></table><h3 id="多全局对象解释"><a href="#多全局对象解释" class="headerlink" title="多全局对象解释"></a>多全局对象解释</h3><blockquote><p>简单来说:多全局对象就是跨窗口或跨 frame 操作。</p></blockquote><h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。<br>这可能会引发一些问题。<br>比如，表达式 [] instanceof window.frames[0].Array 会返回 false，因为 Array.prototype !== window.frames[0].Array.prototype，因此你必须使用 Array.isArray(myObj) 或者 Object.prototype.toString.call(myObj) === “[object Array]”来判断 myObj 是否是数组。</p><hr><h3 id="根据对象的-constructor-判断"><a href="#根据对象的-constructor-判断" class="headerlink" title="根据对象的 constructor 判断"></a>根据对象的 constructor 判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alert(c.constructor === <span class="built_in">Array</span>) ----------&gt; <span class="literal">true</span></span><br><span class="line">alert(d.constructor === <span class="built_in">Date</span>) -----------&gt; <span class="literal">true</span></span><br><span class="line">alert(e.constructor === <span class="built_in">Function</span>) -------&gt; <span class="literal">true</span></span><br><span class="line">注意： <span class="keyword">constructor</span> 在类继承时会出错</span><br><span class="line">eg：</span><br><span class="line">      function A()&#123;&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">      A.prototype = <span class="keyword">new</span> B(); <span class="comment">//A继承自B</span></span><br><span class="line">      <span class="keyword">var</span> aObj = <span class="keyword">new</span> A();</span><br><span class="line">      alert(aobj.constructor === B) -----------&gt; <span class="literal">true</span>;</span><br><span class="line">      alert(aobj.constructor === A) -----------&gt; <span class="literal">false</span>;</span><br><span class="line">而<span class="keyword">instanceof</span>方法不会出现该问题，对象直接继承和间接继承的都会报<span class="literal">true</span>：</span><br><span class="line">      alert(aobj <span class="keyword">instanceof</span> B) ----------------&gt; <span class="literal">true</span>;</span><br><span class="line">      alert(aobj <span class="keyword">instanceof</span> B) ----------------&gt; <span class="literal">true</span>;</span><br><span class="line">言归正传，解决construtor的问题通常是让对象的<span class="keyword">constructor</span>手动指向自己：</span><br><span class="line">      aobj.<span class="keyword">constructor</span> = A; //将自己的类赋值给对象的<span class="keyword">constructor</span>属性</span><br><span class="line">      alert(aobj.<span class="keyword">constructor</span> === A) -----------&gt; true;</span><br><span class="line">      alert(aobj.<span class="keyword">constructor</span> === B) -----------&gt; false; //基类不会报true了;</span><br></pre></td></tr></table></figure><p>缺点：继承的对象判断时，不准确。感觉鸡肋。</p><p>最靠谱的方法： Object.prototype.toString.call(obj)</p><ul><li>这种方法不存在多全局环境和 Array、null 返回 object 的情况，</li><li>原始类型和原始类型对应的引用类型声明的变量都能返回正确的值</li><li>但是这个方法对自定义类型无效，自定义类型返回的都是<code>Object</code>，所以自定义时还是使用<code>instanceof</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(str1); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(str2); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(man); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/test/</span>); <span class="comment">//[object RegExp]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>不存在多全局环境问题</td><td>只能判断本地对象和宿主对象</td></tr><tr><td>原始类型无论是字面量语法声明还是通过对应的引用类型声明都能正确判断</td><td>自定义类型都返回[object Object]</td></tr></tbody></table><hr><h3 id="jquery-type"><a href="#jquery-type" class="headerlink" title="jquery.type()"></a>jquery.type()</h3><p>就是对 prototype 的封装。源码附上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span> ?</span><br><span class="line">            <span class="built_in">String</span>( obj ) :</span><br><span class="line">            class2type[ toString.call(obj) ] || <span class="string">"object"</span>;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="对数组的判断"><a href="#对数组的判断" class="headerlink" title="对数组的判断"></a>对数组的判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">typeof</span> arr; <span class="comment">//object  分辨不出类型</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true //受多全局环境影响</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">//[object Array] //推荐</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">//true //推荐</span></span><br><span class="line">$.type(arr); <span class="comment">//array  //推荐</span></span><br></pre></td></tr></table></figure><h3 id="终极解决方法"><a href="#终极解决方法" class="headerlink" title="终极解决方法"></a>终极解决方法</h3><p>使用<code>Object.prototype.toString().call()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString().call(arr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生javascript实现观察者模式</title>
      <link href="/2020/02/28/%E5%8E%9F%E7%94%9Fjavascript%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/02/28/%E5%8E%9F%E7%94%9Fjavascript%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="ES5-自定义方式"><a href="#ES5-自定义方式" class="headerlink" title="ES5 自定义方式"></a>ES5 自定义方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handler = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Pub.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type, handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.handler[type]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handler[type] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.handler[type].push(handle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pub.prototype.emite = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="built_in">Array</span>.prototype.shift.apply(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handler[type]) &#123;</span><br><span class="line">    <span class="keyword">var</span> handles = <span class="keyword">this</span>.handler[type];</span><br><span class="line">    handles.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      element.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pub.prototype.off = <span class="function"><span class="keyword">function</span>(<span class="params">type, handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handler[type]) &#123;</span><br><span class="line">    <span class="keyword">var</span> handles = <span class="keyword">this</span>.handler[type];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handles.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handles[i] == handle) &#123;</span><br><span class="line">        handles.splice(i, <span class="number">1</span>);</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Pub();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`this is the input name:<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1.on(<span class="string">"add"</span>, handle);</span><br><span class="line">p1.on(<span class="string">"add"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`这是另一个事件`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.off(<span class="string">"add"</span>, handle);</span><br><span class="line">p1.emite(<span class="string">"add"</span>, <span class="string">"wangpeng"</span>);</span><br></pre></td></tr></table></figure><p>###ES6 的 Seter 构造器</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的delete属性</title>
      <link href="/2020/02/28/javascript%E7%9A%84delete%E5%B1%9E%E6%80%A7/"/>
      <url>/2020/02/28/javascript%E7%9A%84delete%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>delete 只是断开了属性和宿主当关系，而不会去操作宿主中的属性。[^1]</li><li>delete 只能删除自有属性，不能删除继承属性，所以 protorype 上的属性不能通过删除对象上的属性删除<br>《Javascript 权威指南》6.3 章</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>当需要删除对象的属性时，我们会使用<code>delete</code>关键字来删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> man = &#123;</span><br><span class="line">  name: <span class="string">"zhangsan"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  user: man,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> zhangsan = person.user;</span><br><span class="line"><span class="comment">//删除name属性</span></span><br><span class="line"><span class="keyword">delete</span> person.user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出person.user</span></span><br><span class="line"><span class="built_in">console</span>.log(person.user); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.name); <span class="comment">//zhangsan</span></span><br></pre></td></tr></table></figure><p>上面的例子说明了，只是断开了属性和宿主的联系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"lisi"</span>;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(man.name); <span class="comment">//zhangsan</span></span><br><span class="line"><span class="keyword">delete</span> man.name;</span><br><span class="line"><span class="built_in">console</span>.log(man.name); <span class="comment">//lisi</span></span><br></pre></td></tr></table></figure><p>上述代码说明，delete 只能删除对象自己的属性，不能删除继承的属性。</p><p>通过注释掉<code>this.name</code>更能说明问题，上面将输出都是<code>lisi</code>,因为实例自己没有自己的 name 属性，输出的是 prototype 上的属性，即使 delete 掉 man.name，protorype 上的属性仍然存在。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webkit技术内幕笔记</title>
      <link href="/2020/02/28/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/28/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么说函数是一等公民"><a href="#为什么说函数是一等公民" class="headerlink" title="为什么说函数是一等公民"></a>为什么说函数是一等公民</h3><blockquote><p>因为函数能够当做参数或返回值进行传递。</p></blockquote><h3 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h3><p><code>Javascript</code>语言的另一个重大特点就是，它是一种<strong>无类型语言</strong>，或者说是<strong>动态类型语言</strong>。相比较而言，C++或者 Java 等语言都是静态类型语言，它们在编译的时候就能够知道每个变量的类型。但是，JavaScript 的语言特性让我们没有办法在编译的时候知道<code>变量的类型</code>，所以只能<code>在运行的时候才能确定</code>，这导致 JavaScript 语言的规范面临着性能方面的巨大压力。<code>在运行时计算和决定类型，会带来很严重的性能损失</code>，这导致了 JavaScript 语言的运行效率比 C++或者 Java 都要低很多。 ###为什么这样会比静态类语言性能差<br>因为静态类型语言在编译时，就已经知道了参数的类型，并根据类型生成了<code>本地代码</code>；所以运行的时候从本地代码中读取就比较快。<br>而 javascript 是动态类型语言，只有当运行的时候才去编译、运行，上面的工作才开始做，这样效率当然会比较低了。</p><a id="more"></a><h3 id="JavaScript-和-C-语言的区别："><a href="#JavaScript-和-C-语言的区别：" class="headerlink" title="JavaScript 和 C++语言的区别："></a>JavaScript 和 C++语言的区别：</h3><ul><li><strong>编译确定位置：</strong>C++有明确的两个阶段，而编译这些位置的偏移信息都是编 译器在编译的时候就决定了的，当 C++代码编译成本地代码之后，对象的 属性和偏移信息都计算完成。<code>因为JavaScript没有类型，所以只有在对象创建的时候才有这些信息，因而只能在**执行阶段**确定，</code>而且 JavaScript 语言能够在执行时修改对象的属性（不是属性值，而是添加或者删除属性本身）。</li><li><strong>偏移信息共享：</strong>C++因为有类型定义，所以所有对象都是按照该类型来确定 的，而且不能在执行的时候动态改变类型，因为这些对象都是共享偏移信息 的。访问它们只需要按照编译时确定的偏移量即可。而对于 C++模板的支 持，其实是多份代码，因为本质上其道理是相同的。<code>JavaScript则不同，每 个对象都是自描述，属性和位置偏移信息都包含在自身的结构中。</code></li><li><strong>偏移信息查找：</strong>C++中查找偏移地址很简单，都是在编译代码时，对使用到 某类型的成员变量直接设置偏移量。而对于 JavaScript,使用到一个对象则需要通过<code>属性名匹配</code>才能查找到对应的值，这实在太费时间了。</li></ul><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>推动 JavaScript 运行速度提高的另一大利器是 JIT (Just-In-Time)技术，它不是 一项全新的技术，其作用是解决解释性语言的性能问题，主要思想是当解释器将源 代码解释成内部表示的时候（Java 字节码就是一个典型例子），JavaScript 的执行环境不仅是解释这些内部表示，而且将其中一些字节码（主要是使用率高的部分）转成本地代码（汇编代码），这样可以被 CPU 直接执行，而不是解释执行，从而极大地提高性能。JIT 技术被广泛地使用在各种语言的执行环境中，例如 Java 虚拟机，经过长时间的演进之后，目前使用在 JavaScript 的众多引擎中，例如 JavaScriptCore、V8、SpiderMonkey 等中。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>首先介绍一个学术解释，“闭包是一个拥有许多变量和绑定了这些变量的环境的 表达式（通常是一个函数），因而这些变量也是该表达式的一部分”。</p><p>通俗来说，就是当执行到一条语句的时候，哪些对象（或者其他环境因素）能够被使用。JavaScript 使用作用域链来实现闭包，作用域链由执行环境维护，JavaScript 中所有的标识符都是通过作用域链来查找值的。</p><h3 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h3><p>什么是 JavaScript 引擎？简单来讲，就是能够将 JavaScript 代码处理并执行的运行环境。要解释这一概念，需要了解一些编译原理的基础概念和现代语言需要的一些新编译技术。</p><p>JavaScript 和 java 的区别：</p><p>其一是类型。JavaScript 是无类型的语言,其对于对象的表示和属性的访问比 Java 存在更大的性能损失。不过现在已经出现了一些新的技术，参考 C++或者 Java 的类型系统的优点，构建隐式的类型信息，这些后面将逐一介绍。</p><p>其二，Java 语言通常是将源代码编译成字节码，这同执行阶段是分开的，也就是从源代码到抽象语法树再到字节码这段时间的长短是无所谓的（或者说不是特别 重要），所以尽可能地生成高效的字节码即可。而对于 JavaScript 而言，这些都是在网页和 JavaScript 文件下载后<code>同执行阶段</code>一起在网页的加载和渲染过程中来实施的， 所以对它们的处理时间也有着很高的要求。</p><p>JavaScript 引擎包括以下几个部分：</p><blockquote><ul><li><strong>编译器。</strong>主要工作是将源代码编译成抽象语法树，在某些引擎中还包含将抽 象语法树转换成字节码。</li><li><strong>解释器。</strong>在某些引擎中，解释器主要是接收字节码，解释执行这个字节码, 同时也依赖垃圾回收机制等。</li><li><strong>JIT 工具。</strong>一个能够能够 JIT 的工具，将字节码或者抽象语法树转换成本地 代码，当然它也需要依赖牢记</li><li><strong>垃圾回收器和分析工具（Profiler )。</strong>它们负责垃圾回收和收集引擎中的信息,帮助改善引擎的性能和功效。</li></ul></blockquote><h3 id="优化回滚"><a href="#优化回滚" class="headerlink" title="优化回滚"></a>优化回滚</h3><p>前面提到 V8 引擎为了性能上的优化，引入了更为高效的 Crankshaft 编译器。但 是为了性能考虑，该编译器通常会做比较乐观和大胆的预测，那就是编译器认为这 些代码比较稳定，变量类型不会发生改变，所以能够生成高效的本地代码。当然这 是理想情况，现实是引擎会发现一些变量的类型已经发生变化。在这种情况下，V8 使用一种机制来将它做的这些错误决定回滚到之前的一般情况，这个过程称为优化 回滚。<br>下面举个例子来说明为什么会出现这种情况吧。示例代码介绍了其中一种情况，函数 ABC 被调用很多次之后， VS 引擎可能会触发 Crankshaft 编译器来生成优化的代码，优化的代码认为示例代码的类型等信息都己经被获知了。但事实上，到目前为止，我们对于代码中的 unknown 变量的类型还一无所知，在这种情况下， VS 只能将该段代码回滚到一个通用的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ABC</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter&lt;<span class="number">1000</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> unknown=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    print(unknown)</span><br></pre></td></tr></table></figure><p>优化回滚是一个很费时的操作，所以能够不回滚，肯定不要回滚，而且回滚会将之前优化的代码恢复到一个没有经过特别优化的代码，这是一个非常不高效的过程，写代码的时候要特别注意尽量不要触发这一过程。</p><p>《webkit 技术内幕》第九章</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前后端漏洞分析与防御技巧--笔记</title>
      <link href="/2020/02/28/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/28/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>代替 node，启动的服务，如果修改后会自动编译启动，无需每次手动启动。</p><h3 id="jspm"><a href="#jspm" class="headerlink" title="jspm"></a>jspm</h3><p>前端包管理工具，npm 是 node 的包管理工具，服务端的。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>全称是：<code>Cross Site Scripting</code>,(跨站脚本攻击），为什么不叫 CSS，因为 CSS 是样式的缩写，<code>cross</code>在英文中通常也被缩写为<code>X</code>，所以这里直接把 cross 缩写成 X。</p><p>简单理解就是：通常情况下，你希望你网站中运行的逻辑都是来自本站，是你自己的东西才能在你网站中运行。但是如果运行了不是本站的脚本就发生了跨站脚本攻击。这里是<code>脚本</code>，不是请求。</p><p>//通常发给你服务器的请求是来自你自己的网站，但是 xss 就是发给你服务的请求，不是从你自己的网站，请求是从其他的网站发过来的。</p><h3 id="url-参数注入"><a href="#url-参数注入" class="headerlink" title="url 参数注入"></a>url 参数注入</h3><ol><li>如果 url 中的参数在网页中直接当做变量来显示，则可以被脚本攻击。如果参数的值中包含脚本，则在显示变量值时，传入的脚本则会被执行，引起 XSS。</li></ol><p>如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://test.com?name=zhangsan&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//下面使用hmtl模板或jsx语法为例</span><br><span class="line">&lt;div&gt;访问的本站是&#123;name&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述代码则会运行传入的脚本。</p><ol start="2"><li>还可以直接链接到其他网站的 js 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://test.com?name=zhangsan&lt;script src=<span class="string">'http://code.jquery.com/jquery-2.1.1.min.js'</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面的请求发出后，参数中的 jquery 链接文件就会被下载并执行。可以在网络请求中看到下载的链接。<br>如果上面的链接换成了恶意写好的代码，比如获取你的用户名和密码，发送违规请求等，那危害就大了。</p><h3 id="脚本攻击能干什么"><a href="#脚本攻击能干什么" class="headerlink" title="脚本攻击能干什么"></a>脚本攻击能干什么</h3><ol><li>获取页面数据</li><li>获取 Cookies</li><li>劫持前端逻辑</li><li>发送请求</li><li>偷取网站任意数据</li><li>偷取用户资料</li><li>偷取用户名和登录状态</li><li>欺骗用户</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>反射类：url 参数直接注入</li><li>存储类：存储到 DB 后读取时注入</li></ul><h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>反射类上面已经举例说明了，下面看看存储类。<br>比如我们在评论里面写入脚本，评论被显示时脚本就会被执行。</p><h3 id="XSS-注入点"><a href="#XSS-注入点" class="headerlink" title="XSS 注入点"></a>XSS 注入点</h3><ol><li>HTML 节点，比如上面传的参数直接在页面中显示和在评论区中输入脚本</li><li>HMTL 属性，比如有些 html 的属性是动态输入的。比如根据输入的地址显示对应的图片。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#&#123;imgPath&#125;"</span> /&gt;</span></span><br><span class="line">如果输入的是`1" onerror="alert(1)"`,则会变成下面的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当然 src 还可以是一个 js 文件链接。</p><ol start="3"><li>JavaScript 代码，比如上面的评论中直接写脚本。</li><li>富文本<br>富文本就是在文本框中输入脚本或恶意链接。</li></ol><h3 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h3><ol><li><p>浏览器自带防御<br>服务端在返回时，可以设置请求头部：<code>X-XSS-Protection</code>,默认是开启的，开启后，上面 url 中注入的脚本就会被认出，请求就会被拦截。<br>这个只能防御有限，只能防止反射性的注入。 如果传的参数没有带<script>标签，直接写脚本内容则不会被识别出来。</p></li><li><p>内容进行转义<br>把一些特殊字符转换成 html 字符实体</p><blockquote><p>比如把<code>&lt;</code> 转换成 <code>&amp;lt;</code> , <code>&gt;</code> 转换成 <code>&amp;gt;</code><br>双引号<code>&quot;</code>转换成<code>&amp;quto;</code><br>单引号<br>空格<br>JavaScript 代码的话，可以转换成 json 字符串或把双引号、斜杠等等都给转义了。<br>富文本的话，可以把相关的字符也进行转换或设置白名单来避免攻击</p></blockquote></li></ol><p>设置 CSP<br>在响应头部设置 CSP 参数。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>Cross Site Request Forgy,跨站请求伪造。</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>原理其实很简单，其实就是利用了 cookie 会被请求自动带上的规则发起的攻击。<br>比如你登录了 A，这些你的敏感信息都在 cookie 中存储。这时你访问了一个攻击 A 网站的 B 网站，B 网站向 A 网站发送请求（比如超链接的 href 直接就是一个请求地址），请求会自动带上 A 网站的 cookie 信息。<br>因为验证信息在 cookie 中，所以 A 网站的服务端就验证通过了。</p><h3 id="疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？"><a href="#疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？" class="headerlink" title="疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？"></a>疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？</h3><p>答案是：NO，同源策略虽然能限制 cookie 被非同一网站使用，但是也并不是所有的都遵循同源策略。</p><p>同源策略限制范围：</p><blockquote><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送。</p></blockquote><p>不遵循同源策略的标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  &lt;img&gt;  &lt;iframe&gt;中的src，</span><br><span class="line">还有超链接a的href都可以任意链接网络资源，相当于对所要求的源进行了一次请求。</span><br></pre></td></tr></table></figure><p>实例代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.3.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#btnCSRF"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          $.<span class="keyword">get</span>("http://localhost:3001/setVal");</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>3002<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://localhost:3001/setVal"</span>&gt;</span>百元大奖<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btnCSRF"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点击中大奖"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户 node 起了两个服务，端口分别是 3001 和 3002，上面的是 3002 的页面代码；<br>当点击超链接“百元大奖”时，3001 服务端是能获取到请求传过来的 cookie，说明 cookie 被自动带上了。<br>当点击按钮“点击中大奖”发出 ajax 请求时，没有报错，但是确实没有 cookie，验证了上述说明是正确的。</p><h3 id="防御-CSRF"><a href="#防御-CSRF" class="headerlink" title="防御 CSRF"></a>防御 CSRF</h3><ol><li>设置 sameSite,禁止其他网站携带 cookie<blockquote><p>测试没起作用，我的网站只是端口不同，都是在 localhost 下测试，不知道是不是这个原因</p></blockquote></li><li>在页面中使用验证码或 token，验证码裤 ccap</li><li>referer 判断请求来源，但 referer 中可以通过参数来模拟关键字<br><a href="http://www.baidu.com/name?pp=&quot;www.test.com&quot;" target="_blank" rel="noopener">http://www.baidu.com/name?pp=&quot;www.test.com&quot;</a> ###防止 cookie 泄露信息 ###签名<br>所谓签名就是把信息加密<br>###httponly<br>禁止 js 读取 cookie</li></ol><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>现象就是你点击某个按钮时，并没有发生想象的结果。而是触发了不可想象的事件。<br>原理就是网页使用一个 iframe 嵌套一个的其他的网页，并把 iframe 隐藏，iframe 页面中的按钮正好和你看到页面上的引诱按钮重合，其实你看到的引诱按钮只是一个背景图片，当点击引诱按钮时，iframe 页面中的按钮就被触发了，这就是点击劫持的原理。</p><h3 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h3><p>点击劫持其实就是网页被 iframe 内嵌了，如果禁止内嵌就不会发生点击劫持。<br>方法：</p><blockquote><p>1.javascript 禁止内嵌<br>默认情况下 top==window,当页面被内嵌后，top!==window,并且他们的 location 也是不相等的，因此可以用 location 来判断页面是否被内嵌。<br>但是 js 如果被禁用了，这方法就没用了。<br>2.X-FRAME-OPTIONS 禁止内嵌<br>在 response 的 header 中进行设置。<br>// ALLOWORIGIN 相同域名可以内嵌，ALLOW-FROM 指定网站可以内嵌<br>res.set({"X-Frame-Options ","DENY"}) 3.其他辅助手段</p></blockquote><h3 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h3><h3 id="anyproxy-工具"><a href="#anyproxy-工具" class="headerlink" title="anyproxy 工具"></a>anyproxy 工具</h3><h3 id="SwitchyOmega-插件"><a href="#SwitchyOmega-插件" class="headerlink" title="SwitchyOmega 插件"></a>SwitchyOmega 插件</h3><p><a href="https://www.css88.com/archives/7628" target="_blank" rel="noopener">https://www.css88.com/archives/7628</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾冒泡算法</title>
      <link href="/2020/02/28/%E5%9B%9E%E9%A1%BE%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/28/%E5%9B%9E%E9%A1%BE%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>刚开始学编程的时候就学了冒泡，所以一直觉的是很简单的东西，但你真的能随手写出来吗？真的还记得原理吗？</p><h3 id="第一种实现"><a href="#第一种实现" class="headerlink" title="第一种实现"></a>第一种实现</h3><p>这是根据核心思想写出来的，后来和书上的一对，写法不同，但是原理和结果是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> l = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> h = i + <span class="number">1</span>; h &lt;= l; h++) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[h]) &#123;</span><br><span class="line">      arr[i] = arr[h];</span><br><span class="line">      arr[h] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString());</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p>9,8,8,7,6,6,5,4,4,4,3,2,1,1<br>91 ###原理<br>实现思想就是用依次用每个位置的数和后面的数进行对比和互换。<br>比如降序排列，第一个位置时，用 1 和后面的各个数进行对比，如果比 1 大则互换两个位置的数，直到最后。</p></blockquote><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>这是书上的方法也是冒泡的真正的原理。</p><blockquote><p>就是相邻的两个元素比较，还以降序为例，如果后面的比前面的大，则互换他们的顺序，比如第一个和第二个对比，然后第二个和第三对比，依次类推。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> l = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>; h &lt; l - i; h++) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[h];</span><br><span class="line">    <span class="keyword">if</span> (arr[h] &lt; arr[h + <span class="number">1</span>]) &#123;</span><br><span class="line">      arr[h] = arr[h + <span class="number">1</span>];</span><br><span class="line">      arr[h + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString());</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p>9,8,8,7,6,6,5,4,4,4,3,2,1,1<br>91</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>两种方式结果一样，并且循环的次数也一样，但是如果面试的话还是推荐第二种，保险，哈哈<br>两种原理其实是一样的，第二个本质也是把数据一个一个<strong>从后往前</strong>放，和第一种放的顺序相反，所以本质一样。</p></blockquote><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数<img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D12/sign=5e6ca6622c738bd4c021b633a08bb91b/b3b7d0a20cf431ad4f379a864936acaf2fdd98ac.jpg" alt="">)和记录移动次数<img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D16/sign=c765e07cd5ca7bcb797bc329bf09e8ac/48540923dd54564e27333d86b1de9c82d1584f3f.jpg" alt="">)均达到最小值：<img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D84/sign=2cfb4bf49182d158bf8254b5810a024c/8326cffc1e178a8244f3b2bafb03738da877e8da.jpg" alt="">)，<img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D66/sign=1745c99097cad1c8d4bbff217e3e11cd/b21c8701a18b87d6007472a0050828381f30fd5f.jpg" alt="">。<br>所以，冒泡排序最好的时间复杂度为<img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D33/sign=feddd1e257fbb2fb302b5e114e4a94f7/b58f8c5494eef01f9d1ac17ae2fe9925bc317d07.jpg" alt="">。<br>若初始文件是反序的，需要进行<img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D32/sign=411c7ed7d309b3deefbfe26acdbf0492/8b82b9014a90f60364df45f83b12b31bb051ed26.jpg" alt="">)趟排序。每趟排序要进行<img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D30/sign=3af139940cf41bd5de53eef450da752f/503d269759ee3d6d1214597441166d224e4adebb.jpg" alt="">)次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D171/sign=f38fc3a1bb389b503cffe455b434e5f1/838ba61ea8d3fd1f846a7b85324e251f95ca5f2a.jpg" alt=""><br><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D186/sign=41bfe6dab119ebc4c4787291b427cf79/7af40ad162d9f2d36fa2fd50abec8a136227ccda.jpg" alt=""></p><blockquote><p>时间复杂度可以忽略掉前面的系数和减去的具体数值，因为在指数级前面这些可以忽略不计。</p></blockquote><p>冒泡排序的最坏时间复杂度为 <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D40/sign=17b28fa860d0f703e2b294dc09fa9d5c/e4dde71190ef76c63a4e22949f16fdfaae5167f5.jpg" alt="">。<br>综上，因此冒泡排序总的平均时间复杂度为 <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D40/sign=17b28fa860d0f703e2b294dc09fa9d5c/e4dde71190ef76c63a4e22949f16fdfaae5167f5.jpg" alt="">。</p><p>这是一个非常高的时间复杂度。冒泡排序早在 1956 年就有人开始研究，之后有很多人都尝试过 对冒泡排序进行改进，但结果却令人失望。如 Donald E. Knuth(中文名为高德纳，1974 年 图灵奖获得者)所说:“冒泡排序除了它迷人的名字和导致了某些有趣的理论问题这一事实 之外，似乎没有什么值得推荐的。”</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《啊哈算法》纸盘游戏-小猫钓鱼-js版</title>
      <link href="/2020/02/28/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E7%BA%B8%E7%9B%98%E6%B8%B8%E6%88%8F-%E5%B0%8F%E7%8C%AB%E9%92%93%E9%B1%BC-js%E7%89%88/"/>
      <url>/2020/02/28/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E7%BA%B8%E7%9B%98%E6%B8%B8%E6%88%8F-%E5%B0%8F%E7%8C%AB%E9%92%93%E9%B1%BC-js%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我的输出结果和书上不一致，在网上查了下，有的人士和我的结果一样，我把每一步都打印出来并看了结果，我的过程和结果是没问题的。</p><h3 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h3><blockquote><p>将一副扑克牌平均分成两份，每人拿一份。小哼先拿出手中的第一张扑克牌放在桌上，然后小哈也拿出手中的第一张扑克牌，并放在小哼刚打出的扑克牌的上面，就像这样两人交替出牌。出牌时，如果某人打出的牌与桌上某张牌的牌面相同，即可将两张相同的牌及其中间所夹的牌全部取走，并依次放到自己手中牌的末尾。当任意一人 手中的牌全部出完时，游戏结束，对手获胜。</p></blockquote><p>谁先没牌谁输；</p><p>依次放到自己的手中；即从最后的牌开始拿，比如 1、3、5、1，则拿回去的顺序是倒的，即：1、5、3、1 放到自己的牌的最后。</p><h3 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> man = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> woman = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> dest = [];</span><br><span class="line"><span class="built_in">console</span>.log(man);</span><br><span class="line"><span class="built_in">console</span>.log(woman);</span><br><span class="line"><span class="keyword">while</span> (man.length &gt; <span class="number">0</span> &amp;&amp; woman.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> m = man.shift();</span><br><span class="line">  <span class="keyword">let</span> w = woman.shift();</span><br><span class="line">  <span class="keyword">let</span> isMan = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> isWoman = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"dest"</span>, dest);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"man"</span>, m);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"manArr"</span>, man);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"woman"</span>, w);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"womanArr"</span>, woman);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"*******************************8"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dest.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m === dest[i]) &#123;</span><br><span class="line">      isMan = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// for</span></span><br><span class="line">  <span class="keyword">if</span> (isMan) &#123;</span><br><span class="line">    man.push(m);</span><br><span class="line">    <span class="keyword">while</span> (dest.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = dest.pop();</span><br><span class="line">      man.push(cur);</span><br><span class="line">      <span class="keyword">if</span> (cur === m) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dest.push(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dest.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (w === dest[i]) &#123;</span><br><span class="line">      isWoman = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// for</span></span><br><span class="line">  <span class="keyword">if</span> (isWoman) &#123;</span><br><span class="line">    woman.push(w);</span><br><span class="line">    <span class="keyword">while</span> (dest.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = dest.pop();</span><br><span class="line">      woman.push(cur);</span><br><span class="line">      <span class="keyword">if</span> (cur === w) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dest.push(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// while</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"dest"</span>, dest);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"man"</span>, man);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"woman"</span>, woman);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"%s赢了"</span>, woman.length === <span class="number">0</span> ? <span class="string">"男"</span> : <span class="string">"女"</span>);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dest [ <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span> ]</span><br><span class="line">man []</span><br><span class="line">woman [ <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span> ]</span><br><span class="line">女赢了</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>刚开始里面用 for 循环来做，但是 for 循环会有很多坑。另外切记不要把循环中的判断放到一个循环中。<br>都是细节问题，这个需要自己手动写去看，其实并不难。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法-JavaScript版</title>
      <link href="/2020/02/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E7%89%88/"/>
      <url>/2020/02/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>比如有一个这样的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br></pre></td></tr></table></figure><p>从数组中找一个<strong>基准数</strong>,通常为第一个元素，比如 4，然后把数组中的所有大于基准数的都放到右边，小于的都放到左边。</p><p>第一轮结束后，虽然左边都是小于基准数的，右边都是大于基准数的，但是他们仍是乱序的，所以需要把两边的继续做上面的交换。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>根据上面的原理有什么好的方式较快的实现呢，总不能一个一个从头循环来做吧，那和冒泡区别就不大了。</p><blockquote><p>从数组的两端进行探测，如果发现左边的大于基准数，则和右边的小于基准数的进行互换。<br>注意：要先从右开始探测。</p></blockquote><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> len = arr1.length - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> l = left;</span><br><span class="line">  <span class="keyword">let</span> r = right;</span><br><span class="line">  <span class="keyword">let</span> base = arr[left];</span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[r] &gt;= base &amp;&amp; l &lt; r) &#123;</span><br><span class="line">      r--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (arr[l] &lt;= base &amp;&amp; l &lt; r) &#123;</span><br><span class="line">      l++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = arr[l];</span><br><span class="line">      arr[l] = arr[r];</span><br><span class="line">      arr[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = arr[l];</span><br><span class="line">  arr[l] = base;</span><br><span class="line"></span><br><span class="line">  quickSort(arr, left, l - <span class="number">1</span>);</span><br><span class="line">  quickSort(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quickSort(arr1, <span class="number">0</span>, len);</span><br><span class="line"><span class="built_in">console</span>.log(arr1.toString());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写react优惠券组件</title>
      <link href="/2020/02/28/%E6%89%8B%E5%86%99react%E4%BC%98%E6%83%A0%E5%88%B8%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/02/28/%E6%89%8B%E5%86%99react%E4%BC%98%E6%83%A0%E5%88%B8%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="先看效果图"><a href="#先看效果图" class="headerlink" title="先看效果图"></a>先看效果图</h2><p><img src="https://i.loli.net/2020/02/28/HATeY8R5BGwrh9N.jpg" alt="优惠卷"></p><blockquote><p>由于是截图，大小有些失真</p></blockquote><a id="more"></a><h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>看到这个图，思考一下，就能明白，其实就两个难点：</p><blockquote><ol><li>左边的锯齿状是如何实现</li><li>中间的凹陷是如何实现</li></ol></blockquote><p>上述两个难点解决了，相信有 css 基础的都能写出这个组件。</p><h2 id="实现锯齿效果"><a href="#实现锯齿效果" class="headerlink" title="实现锯齿效果"></a>实现锯齿效果</h2><h3 id="方法一：伪元素-before-和-after"><a href="#方法一：伪元素-before-和-after" class="headerlink" title="方法一：伪元素 before 和 after"></a>方法一：伪元素 before 和 after</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sawtooth</span> &#123;</span><br><span class="line">  <span class="comment">/* 相对定位，方便让before和after伪元素绝对定位偏移 */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#e24141</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">170px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sawtooth</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.sawtooth</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/* 绝对定位进行偏移 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sawtooth</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="comment">/* 圆点型的border */</span></span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">10px</span> dotted white;</span><br><span class="line">    <span class="comment">/* 偏移一个半径，让圆点的一半覆盖div */</span></span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sawtooth</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="comment">/* 圆点型的border */</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">10px</span> dotted white;</span><br><span class="line">    <span class="comment">/* 偏移一个半径，让圆点的一半覆盖div */</span></span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class="sawtooth"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://i.loli.net/2020/02/28/bHOwqeIPYvtiU9E.jpg" alt="图片描述"></p><h3 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h3><p>这个就是在开头和最后画了一个<code>点状边框</code>，然后平移边框，让边框的一部分覆盖原来的边框，利用圆点的颜色和背景色一样的特点，制作锯齿效果。如果不平移边框效果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sawtooth</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="comment">/* 圆点型的border */</span></span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">10px</span> dotted white;</span><br><span class="line">  <span class="comment">/* 偏移一个半径，让圆点的一半覆盖div */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sawtooth</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="comment">/* 圆点型的border */</span></span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">10px</span> dotted white;</span><br><span class="line">  <span class="comment">/* 偏移一个半径，让圆点的一半覆盖div */</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/28/cN8ehzMyUBd2w4i.png" alt="图片描述"></p><blockquote><p>看了上图实现原理是不是一目了然了。但这也有一些缺点： 1.锯齿的颜色必须和背景色一样 2.无法画锯齿朝里的方式 ###方法二 radial-gradient 设置背景<br>###radial-gradient 讲解<br>用径向渐变创建图像。<br>简单语法：<code>radial-gradient(circle, red 10px, blue 20px, yellow 30px);</code><br>形状是圆（也可以是椭圆），开始位置的颜色是 red，中间颜色是 blue，最后颜色是黄色。<br>10px 表示从圆心开始 10px 范围内都是红色；<br>20px 表示距离圆心 20px 的位置为 blue，然后向两边扩散，直到里面 10px 的红色区域，和向外 30px 地方的 yellow 区域；<br>30px 表示从 30px 开始往外都是 yellow。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle, red <span class="number">10px</span>, blue <span class="number">20px</span>, yellow <span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-radial-gradient-画圆点背景"><a href="#使用-radial-gradient-画圆点背景" class="headerlink" title="使用 radial-gradient 画圆点背景"></a>使用 radial-gradient 画圆点背景</h3><blockquote><ul><li>圆心设置成透明</li><li>把过度颜色都设置成锯齿的颜色</li><li>通过背景尺寸属性设置背景图的颜色，然后 repeate</li></ul></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">106px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle at center, transparent <span class="number">6px</span>, #<span class="number">28</span>acff <span class="number">7px</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/28/Gg8pnxIwQVTYme9.png" alt="图片描述"></p><p>这样一个带圆点背景的 div 就出来了。然后通过设置宽度，只显示半个圆，左边的锯齿就出来了。width 设置成 10px 如下效果</p><p><img src="https://i.loli.net/2020/02/28/zHDwufI4nMtCFX3.png" alt="图片描述"></p><h2 id="上边凹槽的实现"><a href="#上边凹槽的实现" class="headerlink" title="上边凹槽的实现"></a>上边凹槽的实现</h2><p>这个实现就比较简单了，通过绝对定位，用一个圆形元素覆盖父元素的边框。 ###问题：子元素无法覆盖父元素<br>在实现时遇到一个问题，就是子元素移动过去了，但是无法覆盖父元素的边框。这时，需要在组件外再套一层 div，这个 div 设置成相对定位，然后把圆 div 设置成相对定义，再移动位置就能覆盖里面的组件 div 了。 ##开发优惠卷<br>通过上述的讲解，需要实现优惠卷所需要的知识点就都讲完了，下面让我们来实现开始效果的优惠卷吧。 ###结构分析</p><ol><li>一个 div 顶级容器,设置成相对定位。（解决无法覆盖问题）</li><li>一个 div 组件容器，放到上面的 div 中</li><li>锯齿 div（放到 2 中的的 div）</li><li>粗体显示折扣的 div（放到 2 中的的 div）</li><li>虚线 div（放到 2 中的的 div）</li><li>折扣详情 div（放到 2 中的的 div）</li><li>两个圆形 div，放到 1 或 2 中 div 都可以。</li></ol><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parentContainer</span> &#123;</span><br><span class="line"><span class="attribute">position</span>:relative;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:flex;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">3px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">105px</span>;</span><br><span class="line"><span class="attribute">border-left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">106px</span>;</span><br><span class="line"><span class="attribute">left</span>:-<span class="number">1px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">0px</span> solid <span class="number">#ddd</span>;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">3px</span>;</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">radial-gradient</span>(circle at center,transparent <span class="number">6px</span>,#<span class="number">28</span>ACFF <span class="number">4px</span>);</span><br><span class="line"><span class="attribute">background-size</span>:<span class="number">20px</span> <span class="number">15px</span>;</span><br><span class="line"><span class="attribute">z-index</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.couponName</span> &#123;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">0px</span> solid red;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">106px</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line"><span class="attribute">font-family</span>:PingFangSC-Medium;</span><br><span class="line"><span class="attribute">font-weight</span>:<span class="number">500</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">40</span>,<span class="number">172</span>,<span class="number">255</span>,<span class="number">1</span>);</span><br><span class="line"><span class="attribute">margin-left</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin-right</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.subName</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.topSemicircle</span> &#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">80px</span>;</span><br><span class="line"><span class="attribute">top</span>:-<span class="number">16px</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottomSemicircle</span> &#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">left</span>:<span class="number">80px</span>;</span><br><span class="line"><span class="attribute">bottom</span>:-<span class="number">16px</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dashed</span> &#123;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> dashed <span class="number">#ddd</span>;</span><br><span class="line"><span class="attribute">margin-top</span>:<span class="number">11px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>:<span class="number">11px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:flex;</span><br><span class="line"><span class="attribute">flex-direction</span>:column;</span><br><span class="line"><span class="attribute">justify-content</span>:center;</span><br><span class="line"><span class="attribute">align-items</span>:flex-start;</span><br><span class="line"><span class="attribute">padding-left</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.desc</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">font-family</span>:PingFangSC-Regular;</span><br><span class="line"><span class="attribute">font-weight</span>:<span class="number">400</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">170</span>,<span class="number">170</span>,<span class="number">170</span>,<span class="number">1</span>);</span><br><span class="line"><span class="attribute">margin-top</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class="parentContainer"&gt;</span><br><span class="line">  &lt;div class="container"&gt;</span><br><span class="line">    &lt;div class="left"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="couponName"&gt;8&lt;span class="subName"&gt;折&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="dashed"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="right"&gt;</span><br><span class="line">      &lt;div&gt;折扣卷7.5折&lt;/div&gt;</span><br><span class="line">      &lt;div class="desc"&gt;400张&lt;/div&gt;</span><br><span class="line">      &lt;div class="desc"&gt;有效时间：2018.09.21-2018.10.21&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="topSemicircle"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="bottomSemicircle"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以把代码赋值到下面的在线工具中看下效果</p><p><a href="https://c.runoob.com/front-end/61" target="_blank" rel="noopener">https://c.runoob.com/front-end/61</a></p><h3 id="React-Code"><a href="#React-Code" class="headerlink" title="React Code"></a>React Code</h3><blockquote><p>根据自己需要再写成 react 版本，就易如反掌了。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">//less</span><br><span class="line"><span class="selector-class">.parentContainer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">312px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">105px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">106px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(</span><br><span class="line">    circle at center,</span><br><span class="line">    transparent <span class="number">6px</span>,</span><br><span class="line">    #<span class="number">28</span>acff <span class="number">4px</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.leftInvalid</span> &#123;</span><br><span class="line">  .left;</span><br><span class="line">  <span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(</span><br><span class="line">    <span class="selector-tag">circle</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>,</span><br><span class="line">    <span class="selector-tag">transparent</span> 6<span class="selector-tag">px</span>,</span><br><span class="line">    <span class="selector-id">#aaaaaa</span> 4<span class="selector-tag">px</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.couponName</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0px</span> solid red;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">106px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: PingFangSC-Medium;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">500</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">40</span>, <span class="number">172</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">62px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.couponNameInvalid</span> &#123;</span><br><span class="line">  .couponName;</span><br><span class="line">  <span class="selector-tag">color</span>: <span class="selector-id">#aaaaaa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">51</span>, <span class="number">51</span>, <span class="number">51</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.invalidTitle</span> &#123;</span><br><span class="line">  .title;</span><br><span class="line">  <span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(170, 170, 170, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.subName</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.semicircle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">98px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.topSemicircle</span> &#123;</span><br><span class="line">  .semicircle;</span><br><span class="line">  <span class="selector-tag">top</span>: <span class="selector-tag">-16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bottomSemicircle</span> &#123;</span><br><span class="line">  .semicircle;</span><br><span class="line">  <span class="selector-tag">bottom</span>: <span class="selector-tag">-16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dashed</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">11px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">11px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.desc</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: PingFangSC-Regular;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">170</span>, <span class="number">170</span>, <span class="number">170</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//组件代码</span><br><span class="line">import React, &#123; PureComponent &#125; from 'react'</span><br><span class="line">import styles from './index.less'</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> <span class="selector-tag">class</span> <span class="selector-tag">CouponCard</span> <span class="selector-tag">extends</span> <span class="selector-tag">PureComponent</span> &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="selector-tag">const</span> &#123;</span><br><span class="line">      valid = true,</span><br><span class="line">      data = &#123;</span><br><span class="line">        <span class="selector-tag">id</span>: 2323,</span><br><span class="line">        couponDescription: '折扣卷8.5折',</span><br><span class="line">        validDate: '2018.08.22-2018.09.12',</span><br><span class="line">        <span class="selector-tag">number</span>: 23,</span><br><span class="line">        <span class="selector-tag">amount</span>: 8<span class="selector-class">.5</span>,</span><br><span class="line">        unit: '折',</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125; = this.props</span><br><span class="line">    const amounts = data.amount.toString().split('.')</span><br><span class="line">    <span class="selector-tag">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.parentContainer&#125;&gt;</span><br><span class="line">        &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line">          &lt;div className=&#123;valid ? styles.left : styles.leftInvalid&#125; /&gt;</span><br><span class="line">          &lt;div className=&#123;valid ? styles.couponName : styles.couponNameInvalid&#125;&gt;</span><br><span class="line">            &#123;amounts[0]&#125;</span><br><span class="line">            &lt;span className=&#123;styles.subName&#125;&gt;</span><br><span class="line">              &#123;amounts[1] ? `.$&#123;amounts[1]&#125;` : ''&#125;</span><br><span class="line">              &#123;data.unit&#125;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div className=&#123;styles.dashed&#125; /&gt;</span><br><span class="line">          &lt;div className=&#123;styles.right&#125;&gt;</span><br><span class="line">            &lt;div className=&#123;valid ? styles.title : styles.invalidTitle&#125;&gt;</span><br><span class="line">              折扣卷&#123;data.amount&#125;</span><br><span class="line">              &#123;data.unit&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=&#123;styles.desc&#125;&gt;&#123;data.number&#125;张&lt;/div&gt;</span><br><span class="line">            &lt;div className=&#123;styles.desc&#125;&gt;有效时间：&#123;data.validDate&#125;&lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div className=&#123;styles.topSemicircle&#125; /&gt;</span><br><span class="line">          &lt;div className=&#123;styles.bottomSemicircle&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/holmofy/article/details/79648343" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何这没有显示器的情况下获取树莓派IP？</title>
      <link href="/2020/02/28/%E5%A6%82%E4%BD%95%E8%BF%99%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%8E%B7%E5%8F%96%E6%A0%91%E8%8E%93%E6%B4%BEIP%EF%BC%9F/"/>
      <url>/2020/02/28/%E5%A6%82%E4%BD%95%E8%BF%99%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%8E%B7%E5%8F%96%E6%A0%91%E8%8E%93%E6%B4%BEIP%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>因为没有显示器，所以买了树莓派，就在公司配置好了树莓拍的参数，包括配置好连接家里的无线，这样到家开机就直接连上 wifi，就在同一个局域网中了。</p><h3 id="寻找树莓派的-IP"><a href="#寻找树莓派的-IP" class="headerlink" title="寻找树莓派的 IP"></a>寻找树莓派的 IP</h3><p>在网上找了很多方法，什么<code>arp -a</code>或者<code>nmap</code>等等，都没成功，麻烦，还都装一堆东西。</p><p><code>arp -a</code>只能获取到和你本机通讯过的机器；</p><h3 id="最实际都办法"><a href="#最实际都办法" class="headerlink" title="最实际都办法"></a>最实际都办法</h3><p>一般树莓派的主机名默认就是<code>raspberrypi</code>，并使用<code>.local</code>后缀。</p><p>所以直接<code>ping</code>这个机器，ping 通都同时验证了服务没问题，并且还知道了 IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codexiaengdeAir:~ zhangsan$ ping raspberrypi.local</span><br><span class="line">PING raspberrypi.local (192.168.199.124): 56 data bytes</span><br><span class="line">64 bytes from 192.168.199.124: icmp_seq=0 ttl=64 time=3.175 ms</span><br><span class="line">64 bytes from 192.168.199.124: icmp_seq=1 ttl=64 time=117.279 ms</span><br><span class="line">Request timeout <span class="keyword">for</span> icmp_seq 2</span><br><span class="line">64 bytes from 192.168.199.124: icmp_seq=3 ttl=64 time=7.085 ms</span><br><span class="line">64 bytes from 192.168.199.124: icmp_seq=4 ttl=64 time=2.577 ms</span><br></pre></td></tr></table></figure><p>看到上面都结果，就能知道 IP 了。</p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>我用的是 mac，直接使用自带的终端连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@192.168.199.124</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 电脑技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react+百度地图实现自定义图标</title>
      <link href="/2020/02/28/react-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87/"/>
      <url>/2020/02/28/react-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>react</li><li>百度地图使用的是：rc-bmap</li></ol><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.loli.net/2020/02/28/hPBmSnrD2d65eHO.jpg" alt="图片描述"></p><p>实现图中提示框的效果。<br>看到这个，用过百度地图的第一个会想到 marker，其实不是，用的是 Label，其实难点不在这，这个看看 API，都能很快琢磨出来。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ol><li>如何显示成带图标的那个外框</li><li>里面的内容如何换行，及设置样式</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看了 API,<code>Marker</code>不能显示内容,但<code>Marker</code>可以使用<code>Label</code>属性，其实也是用的<code>Label</code>；<br>所以开始研究 Label，首先<code>Label</code>是显示内容的，但是<code>label</code>的<code>content</code>属性只能是<code>string</code>,这就麻烦了，怎么控制字体显示呢，怎么设置样式呢？<br>原来是使用了 jsx 的语法来写，显示的是<code>[Object Object]</code>，显然不支持啊。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>最后根据经验试了下 html 字符串，字符串上套了层 div，原以为 div 会显示出来，结果没有。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Label</span><br><span class="line">  content=&#123;<span class="string">`&lt;div&gt;骑手正在取件途中&lt;/div&gt;&lt;div&gt;1.8公里&lt;/div&gt;`</span>&#125;</span><br><span class="line">  point=&#123;point&#125;</span><br><span class="line">  offset=&#123;courierOffset&#125;</span><br><span class="line">  massClear=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">  zIndex=&#123;<span class="number">100</span>&#125; <span class="comment">// 同html的z-index</span></span><br><span class="line">  style=&#123;labelStyle&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>于是就知道这个是支持<code>hmtl字符串</code>的；<br>这样换行控制是解决了，接下来是样式,按照 jsx 的语法写，没效果，想着也合理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=&#123;`&lt;div&gt;骑手正在取件途中&lt;/div&gt;&lt;div className=&#123;<span class="variable">$&#123;styles.label&#125;</span>&#125;&gt;1.8公里&lt;/div&gt;`&#125;</span><br></pre></td></tr></table></figure><p>于是又试了直接写 class</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=&#123;`&lt;div&gt;骑手正在取件途中&lt;/div&gt;&lt;div class=<span class="string">'label'</span>&gt;1.8公里&lt;/div&gt;`&#125;</span><br></pre></td></tr></table></figure><p>这样感觉也不合理，因为样式需要 babel 编译的，直接这样写，是识别不了的。<br>因此就有了<strong>解决方案</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=&#123;`&lt;div&gt;骑手正在取件途中&lt;/div&gt;&lt;div class=<span class="string">'$&#123;styles.label&#125;'</span>&gt;1.8公里&lt;/div&gt;`&#125;</span><br></pre></td></tr></table></figure><h3 id="外框的实现"><a href="#外框的实现" class="headerlink" title="外框的实现"></a>外框的实现</h3><p>外框其实通过设置 Label 的 style 来实现。</p><h3 id="相关-code"><a href="#相关-code" class="headerlink" title="相关 code"></a>相关 code</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> courierLabelBG <span class="keyword">from</span> <span class="string">"./images/courier_label_bg.svg"</span>; <span class="comment">//图片中带有前面的小车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point = &#123;</span><br><span class="line">  lng: <span class="number">116.404</span>,</span><br><span class="line">  lat: <span class="number">39.915</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; Description &#125; = DescriptionList;</span><br><span class="line"><span class="keyword">const</span> ButtonGroup = Button.Group;</span><br><span class="line"><span class="keyword">const</span> labelStyle = &#123;</span><br><span class="line">  backgroundImage: <span class="string">`url(<span class="subst">$&#123;courierLabelBG&#125;</span>)`</span>,</span><br><span class="line">  backgroundRepeat: <span class="string">"no-repeat"</span>,</span><br><span class="line">  backgroundSize: <span class="string">"cover"</span>,</span><br><span class="line">  backgroundColor: <span class="string">"rgba(0, 0, 0, 0)"</span>,</span><br><span class="line">  border: <span class="string">"none"</span>,</span><br><span class="line">  color: <span class="string">"rgba(51,51,51,1);"</span>,</span><br><span class="line">  paddingLeft: <span class="string">"54px"</span>,</span><br><span class="line">  paddingTop: <span class="string">"8px"</span>,</span><br><span class="line">  fontWeight: <span class="string">"400"</span>,</span><br><span class="line">  width: <span class="string">"181px"</span>,</span><br><span class="line">  height: <span class="string">"52px"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> courierOffset = &#123;</span><br><span class="line">  width: <span class="number">-92</span>,</span><br><span class="line">  height: <span class="number">-54</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;<span class="built_in">Map</span> ak=<span class="string">"WAeVpuoSBH4NswS30GNbCRrlsmdGB5Gv"</span> scrollWheelZoom&gt;</span><br><span class="line">  &lt;Label</span><br><span class="line">    content=&#123;<span class="string">`&lt;div&gt;骑手正在取件途中&lt;/div&gt;&lt;div class='<span class="subst">$&#123;styles.courierLabel&#125;</span>'&gt;1.8公里&lt;/div&gt;`</span>&#125;</span><br><span class="line">    point=&#123;point&#125;</span><br><span class="line">    offset=&#123;courierOffset&#125;</span><br><span class="line">    massClear=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">    zIndex=&#123;<span class="number">100</span>&#125; <span class="comment">// 同html的z-index</span></span><br><span class="line">    style=&#123;labelStyle&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;<span class="regexp">/Map&gt;;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派3B+配置国内源和安装docker</title>
      <link href="/2020/02/28/%E6%A0%91%E8%8E%93%E6%B4%BE3B-%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90%E5%92%8C%E5%AE%89%E8%A3%85docker/"/>
      <url>/2020/02/28/%E6%A0%91%E8%8E%93%E6%B4%BE3B-%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90%E5%92%8C%E5%AE%89%E8%A3%85docker/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我的是 3b+版本，系统版本是<code>stretch</code>,如下命令可以查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure><a id="more"></a><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Raspbian</span><br><span class="line">Description:Raspbian GNU/Linux 9.4 (stretch)</span><br><span class="line">Release:9.4</span><br><span class="line">Codename:stretch</span><br></pre></td></tr></table></figure><blockquote><p>我的系统体系结构是<code>armhf</code>,这是这下面安装 docker 的时候提示的，安装 amd64 报错了。 ###设置树莓派国内源 1.使用管理员权限修改<code>/etc/apt/sources.list</code>文件：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>用#注释掉原文件内容，添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure><p>2.使用管理员权限，编辑<code>/etc/apt/sources.list.d/raspi.list</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/apt/sources.list.d/raspi.list</span><br></pre></td></tr></table></figure><p>用#注释掉原文件内容，添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line">deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br></pre></td></tr></table></figure><h3 id="更新-验证"><a href="#更新-验证" class="headerlink" title="更新+验证"></a>更新+验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>如果上面的命令执行没有再提示什么没找到什么什么的信息，并更新完成就说明上面配置管用，并配置成功了</p><h3 id="配置-docker"><a href="#配置-docker" class="headerlink" title="配置 docker"></a>配置 docker</h3><p>根据官网先做如下配置,运行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">     apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     gnupg2 \</span><br><span class="line">     software-properties-common</span><br></pre></td></tr></table></figure><p>下一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>下一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>接下来按照官网的配置 docker 的仓库，不起作用，就在网上找了手动下载的方法</p><p>设置 docker 源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb [arch=armhf] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">     <span class="variable">$(lsb_release -cs)</span> stable"</span> | \</span><br><span class="line">    sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure><p>更新 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h3 id="docker-命令不加-sudo"><a href="#docker-命令不加-sudo" class="headerlink" title="docker 命令不加 sudo"></a>docker 命令不加 sudo</h3><ol><li>如果还没有 docker group 就添加一个：</li></ol><p><code>sudo groupadd docker</code></p><ol start="2"><li>将用户加入该 group 内。然后退出并重新登录就生效啦。</li></ol><p><code>sudo gpasswd -a ${USER} docker</code></p><ol start="3"><li>重启 docker</li></ol><p><code>sudo service docker restart</code></p><p><a href="https://docs.docker.com/install/linux/docker-ce/debian/#install-docker-ce-1" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/debian/#install-docker-ce-1</a><br><a href="https://blog.csdn.net/la9998372/article/details/77886806" target="_blank" rel="noopener">https://blog.csdn.net/la9998372/article/details/77886806</a></p>]]></content>
      
      
      <categories>
          
          <category> 电脑技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现链表</title>
      <link href="/2020/02/28/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/02/28/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h3><p>链表是一个集合，是 C 或 C++中的概念。和数组有什么区别呢？<br>链表每个元素有两部分组成，第一部分是存储的值，第二部分是记录了下一个元素的位置信息。在 C 中即使下一个元素的指针，其实就通过第二个属性能直接拿到下一个元素的值。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">value:<span class="string">""</span>,</span><br><span class="line">next:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个元素通过他的<code>next</code>就知道下一个值是什么。就像一个链子，上一个元素连着下一个元素。<br>向链表中插入一个值，不需要把后面的每个元素往后移动位置。</p><ol><li>只需要把修改插入位置前一个元素的 next 属性指向插入的值；</li><li>插入的值的 next 只插入之后的那个元素即可。</li></ol><p>因为在 JavaScript 中不能像 C 一样那样直接操作指针，所以现在用数组模拟一个链表。</p><h3 id="javascript-版本的链表"><a href="#javascript-版本的链表" class="headerlink" title="javascript 版本的链表"></a>javascript 版本的链表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//比如有一个集合</span><br><span class="line"><span class="built_in">let</span> left = [2, 3, 4, 5, 8, 9];</span><br><span class="line">//用另一个集合对应位置的值来记录下一个元素的索引。每个值存储的是需要获取值的索引，如果没有对应的则存-1；</span><br><span class="line">//这个集合的奥妙在于，它的**索引**和**值**是能串联起来的“一条绳”,索引和值前后衔接。</span><br><span class="line">// [1, 2, 3, 4, 5, -1]</span><br><span class="line">//  0  1  2  3  4   5</span><br><span class="line"><span class="built_in">let</span> right = [1, 2, 3, 4, 5, -1];</span><br><span class="line">//一个要插入的值</span><br><span class="line"><span class="built_in">let</span> middle = 6;</span><br><span class="line"><span class="built_in">let</span> len = left.length;</span><br><span class="line">left.push(middle);</span><br><span class="line"><span class="built_in">let</span> t = 0;</span><br><span class="line"><span class="keyword">while</span> (t != -1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (left[right[t]] &gt; middle) &#123;</span><br><span class="line">    right[len] = right[t];</span><br><span class="line">    right[t] = len;</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t = right[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"输出结果："</span>);</span><br><span class="line">console.log(left);</span><br><span class="line">console.log(right);</span><br><span class="line">t = 0;</span><br><span class="line"><span class="keyword">while</span> (t != -1) &#123;</span><br><span class="line">  console.log(left[t]);</span><br><span class="line">  //这就体现出了索引和值前后衔接的关系了。注意right的索引用的也是t</span><br><span class="line">  t = right[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 5 6 8 9</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>原始：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 4, 5, 8, 9];</span><br><span class="line">[1, 2, 3, 4, 5, -1]</span><br></pre></td></tr></table></figure><p>插入后：<br>所谓的插入是保证输出的顺序像插入的效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 4, 5, 8, 9, 6];</span><br><span class="line">[1, 2, 3, 6, 5, -1, 4]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个mac之间快速传递文件</title>
      <link href="/2020/02/28/%E4%B8%A4%E4%B8%AAmac%E4%B9%8B%E9%97%B4%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6/"/>
      <url>/2020/02/28/%E4%B8%A4%E4%B8%AAmac%E4%B9%8B%E9%97%B4%E5%BF%AB%E9%80%9F%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-电脑设置"><a href="#1-电脑设置" class="headerlink" title="1.电脑设置"></a>1.电脑设置</h3><p>两台笔记本都需要开通<strong>“远程登录”</strong>，设置步骤：</p><blockquote><p><code>系统偏好设置</code>-&gt;<code>共享</code>-&gt;<code>远程登录</code></p></blockquote><p>结果如图</p><p><img src="https://upload-images.jianshu.io/upload_images/1348523-b21af7583a4bbbbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置截图"></p><h3 id="SCP-拷贝"><a href="#SCP-拷贝" class="headerlink" title="SCP 拷贝"></a>SCP 拷贝</h3><blockquote><p>scp 是 secure copy 的简写，用于在 Linux 下进行远程拷贝文件的命令，和它类似的命令有 cp，不过 cp 只是在本机进行拷贝不能跨服务器，而且 scp 传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system 时，用 scp 可以帮你把文件移出来。另外，scp 还非常不占资源，不会提高多少系统负荷，在这一点上，rsync 就远远不及它了。虽然 rsync 比 scp 会快一点，但当小文件众多的情况下，rsync 会导致硬盘 I/O 非常高，而 scp 基本不影响系统正常使用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">2．命令功能：</span><br><span class="line">scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</span><br><span class="line">linux的scp命令可以在linux服务器之间复制文件和目录。</span><br><span class="line"></span><br><span class="line">3．命令参数：</span><br><span class="line">-1  强制scp命令使用协议ssh1</span><br><span class="line">-2  强制scp命令使用协议ssh2</span><br><span class="line">-4  强制scp命令只使用IPv4寻址</span><br><span class="line">-6  强制scp命令只使用IPv6寻址</span><br><span class="line">-B  使用批处理模式（传输过程中不询问传输口令或短语）</span><br><span class="line">-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span><br><span class="line">-p 保留原文件的修改时间，访问时间和访问权限。</span><br><span class="line">-q  不显示传输进度条。</span><br><span class="line">-r  递归复制整个目录。</span><br><span class="line">-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</span><br><span class="line">-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。</span><br><span class="line">-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。</span><br><span class="line">-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</span><br><span class="line">-l <span class="built_in">limit</span>  限定用户所能使用的带宽，以Kbit/s为单位。</span><br><span class="line">-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，</span><br><span class="line">-P port  注意是大写的P, port是指定数据传输用到的端口号</span><br><span class="line">-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><ol><li>拷贝文件<br>命令格式：<br><code>scp local_file remote_username@remote_ip:remote_folder</code><br>或者<br><code>scp local_file remote_username@remote_ip:remote_file</code><br>或者<br><code>scp local_file remote_ip:remote_folder</code><br>或者<br><code>scp local_file remote_ip:remote_file</code></li></ol><p>第 1,2 个指定了用户名，命令执行后需要输入用户密码，第 1 个仅指定了远程的目录，文件名字不变，第 2 个指定了文件名</p><p>第 3,4 个没有指定用户名，命令执行后需要输入用户名和密码，第 3 个仅指定了远程的目录，文件名字不变，第 4 个指定了文件名</p><blockquote><p>如果要把远程的拷贝到本地，把第一个路径使用远程的格式即可，如：<br><code>scp remote_username@remote_ip:remote_folder local_file</code></p></blockquote><ol start="2"><li>拷贝目录<br>命令格式：<br><code>scp -r local_folder remote_username@remote_ip:remote_folder</code><br>或者<br><code>scp -r local_folder remote_ip:remote_folder</code></li></ol><p>第 1 个指定了用户名，命令执行后需要输入用户密码；<br>第 2 个没有指定用户名，令执行后需要输入用户名和密码；</p><h3 id="远程连接中文乱码"><a href="#远程连接中文乱码" class="headerlink" title="远程连接中文乱码"></a>远程连接中文乱码</h3><ol><li>查看本地编码<br>在终端输入<code>locale</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LANG=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">LC_COLLATE=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">LC_CTYPE=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">LC_MONETARY=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">LC_NUMERIC=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">LC_TIME=<span class="string">"zh_CN.UTF-8"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure><p>但是我两台 mac 的编码是完全一样的，只是一个是 mac air ，一个是 mac pro，pro 连接 air 显示没问题，air 连接 pro 汉字乱码。</p><h3 id="乱码解决"><a href="#乱码解决" class="headerlink" title="乱码解决"></a>乱码解决</h3><p>在 pro 机器上，也就是远程的机器上执行如下命令：<br>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>添加如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><p>接着重启一下终端，或者输入 <code>source ~/.zshrc</code> 使设置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>其实还是会受到带宽的影响，我的最多就是 8M 左右，最大的网速，但如果是一个不联网的局域网不知道会不会更快，得到飞鸽的那种上 G 的速度</p>]]></content>
      
      
      <categories>
          
          <category> 电脑技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式开发-1</title>
      <link href="/2020/02/25/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91-1/"/>
      <url>/2020/02/25/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91-1/</url>
      
        <content type="html"><![CDATA[<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>记录在学习响应式布局时学到的只是点。</p><h2 id="响应式网站概念"><a href="#响应式网站概念" class="headerlink" title="响应式网站概念"></a>响应式网站概念</h2><ul><li>flexible grid layout 弹性网格布局</li><li>flexible image 弹性图片</li><li>media queries 媒体查询</li></ul><blockquote><p>响应式网站是一个设计理念，它是多项技术的综合体。</p></blockquote><p>在使用弹性盒子 flex 布局时，会有他的局限性，虽然会弹性伸缩，但是样式不能保证。</p><a id="more"></a><h2 id="响应式网站的有点"><a href="#响应式网站的有点" class="headerlink" title="响应式网站的有点"></a>响应式网站的有点</h2><ul><li>减少工作量<ol><li>网站、设计、代码、内容都只需要一份</li><li>多出来的工作量只是 JS 脚本、CSS 样式做一些改动</li></ol></li><li>节省时间<ol><li>迅速发布、快速迭代、敢于试错、小步快跑</li></ol></li><li>跨终端<br>每个设备都你能得到正确的设计，面向未来 -搜索优化<br>不需要为不同的终端申请不同的域名，共用一个网址</li></ul><h2 id="响应式网站的缺点"><a href="#响应式网站的缺点" class="headerlink" title="响应式网站的缺点"></a>响应式网站的缺点</h2><ol><li>会加载更多的样式和脚本资源</li><li>设计比较难精准定位和控制</li><li>老版本浏览兼容不好</li></ol><h2 id="查看浏览器时长份额"><a href="#查看浏览器时长份额" class="headerlink" title="查看浏览器时长份额"></a>查看浏览器时长份额</h2><ol><li><a href="https://www.caniuse.com/" target="_blank" rel="noopener">caniuse</a><br>这个统计的全世界的</li><li><a href="https://gs.statcounter.com/" target="_blank" rel="noopener">https://gs.statcounter.com/</a><br>这个可以选择区域</li></ol><h2 id="css3-媒体属性简介"><a href="#css3-媒体属性简介" class="headerlink" title="css3 媒体属性简介"></a>css3 媒体属性简介</h2><ul><li>width:视口宽度</li><li>height:视口高度</li><li>device-width:渲染表面的宽度，就是设备屏幕的宽度</li><li>device-height:渲染表面的高度，就是设备屏幕的高度</li><li>orientation:检查设备是处于横向还是纵向</li><li>aspect-radio:基于视口宽度和高度的宽高比<br>比如 width/height 16/9 或者 4/3</li><li>color:每种颜色的位数 bits，如 min-color:16 位、8 位</li><li>resolution:检测屏幕或打印机的分辨率<br>如：min-resolution:300dpi</li></ul><p>以上属性都可以添加<code>min-</code>和<code>max-</code>前缀</p><h3 id="视口宽度和设备宽度的区别"><a href="#视口宽度和设备宽度的区别" class="headerlink" title="视口宽度和设备宽度的区别"></a>视口宽度和设备宽度的区别</h3><p>在传统 PC 上，桌面浏览器的视口(viewport)就是浏览器主窗口的区域。但在手机端，浏览器的有三个视口的概念</p><ol><li>布局视口(layout viewport)</li><li>可视视口(visual viewport)</li><li>理想视口(ideal viewport)</li></ol><h3 id="为什么会有三个视口呢？"><a href="#为什么会有三个视口呢？" class="headerlink" title="为什么会有三个视口呢？"></a>为什么会有三个视口呢？</h3><p>因为浏览器原先是为 PC 设计的，最小宽度也是 960 像素，当移动端出来后，当时 iPhone 的屏幕宽度才 320px，移动端显示这些页面，很不友好，体验较差；这时乔帮主就引入一个布局视口的概念，这个视口先不在手机上显示，用一个虚拟的布局视口把网页显示出来，一般把这个布局视口宽度设置成 960px；然后通过缩放布局视口，比如 0.3 倍，就可以在可视视口查看网页内容。可以放大、滑动来查看网页的不同部分内容。放大和滑动的都是布局视口。</p><p><img src="https://i.loli.net/2020/02/27/Io14W7J3gwVKs6H.png" alt="image.png"></p><ul><li>黑色阴影部分就是布局视口，它的宽度一直是 960px，</li><li>看到内容的地方就是可视视口</li></ul><p><strong>理想视口</strong>就是布局视口在一个设备上的最佳尺寸。理想视口下的页面便于浏览器浏览、阅读。不需要缩放就可以很方便浏览页面。</p><p>###设置理想视口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meda name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>布局视口的宽度和设备可视视口的宽度一致。这样在设计时，就根据设备的宽度进行设计即可。不要再进行缩放来显示内容。<br>很多网站直接禁止了缩放，比如百度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meda name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,minimux-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;no&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h2 id="响应式网站设计实践原则"><a href="#响应式网站设计实践原则" class="headerlink" title="响应式网站设计实践原则"></a>响应式网站设计实践原则</h2><ol><li>progressive enhancement 渐进增强<br>先构建一个简单的基本效果，然后根据不同的浏览器和分辨率的特点，逐渐增加新功能，比如增加个圆角、阴影、动画等等。</li><li>graceful degradation 优雅降级<br>这个正好相反，我们先构建一个最优雅最漂亮的效果，然后根据不同浏览器不支持的效果，去掉响应的效果。</li></ol><p>建议采用<strong>优雅降级</strong>方案。<br>先根据小屏进行设计还是大屏进行设计？<br>这个根据实际情况来确定。<br>确定要支持的浏览器范围。</p><h2 id="如何组织项目目录结构"><a href="#如何组织项目目录结构" class="headerlink" title="如何组织项目目录结构"></a>如何组织项目目录结构</h2><ul><li>约定优于配置</li><li>约定代码结构或命名规范来减少配置数量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 响应式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 响应式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式开发</title>
      <link href="/2020/02/25/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2020/02/25/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="ResponsiveWeb"><a href="#ResponsiveWeb" class="headerlink" title="ResponsiveWeb"></a>ResponsiveWeb</h1><p>一个响应式网站</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── doc                    # 项目文档</span><br><span class="line">└── src                    # 源代码</span><br><span class="line">    ├── css                # 样式文件</span><br><span class="line">    │   ├── main.css       # 公用样式</span><br><span class="line">    │   └── normalize.css  # reset的样式</span><br><span class="line">    ├── img                # 存放图片的文件夹</span><br><span class="line">    ├── js                 # 存放js的文件夹</span><br><span class="line">    │   ├── main.js        # main页面js</span><br><span class="line">    │   └── ventor         # 第三方库文件</span><br><span class="line">    ├── index.html         # 首页</span><br><span class="line">    └── login.html         # 登录页</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="一些有用的文件"><a href="#一些有用的文件" class="headerlink" title="一些有用的文件"></a>一些有用的文件</h2><h3 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h3><p>当放生 404 时，可以以更友好的方式展现，而不是使用系统给的错误页面。</p><h3 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h3><p>这个是搜索引擎在访问网站时第一个要查看的文件。<code>robots.txt</code> 告诉搜索引擎的爬虫程序，在服务器上什么文件可以被查看，什么文件不可用被查看。</p><p>比如下面就是指定除了<code>admin</code>文件夹都可以访问。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /admin/</span><br></pre></td></tr></table></figure><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="favicon.ico"></a>favicon.ico</h3><p>这个是网站默认的图标，</p><h3 id="humans-txt"><a href="#humans-txt" class="headerlink" title="humans.txt"></a>humans.txt</h3><p>上面的 robots.txt 是给机器人看的，这个是给人类看的，包含了创建网站人员的信息等。<br><a href="http://humanstxt.org/ZH" target="_blank" rel="noopener">humanstxt 的介绍信息</a></p><h3 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h3><p>这个是配置 IDE 的参数，创建这个文件后，IDE 工具会使用这里面的配置，这样即使更换工具，配置还是一样的。<br><a href="https://editorconfig.org/" target="_blank" rel="noopener">官网地址</a></p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>配置一些 git 需要忽略的文件</p><h2 id="html-头部元素的讲解"><a href="#html-头部元素的讲解" class="headerlink" title="html 头部元素的讲解"></a>html 头部元素的讲解</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lang规定了页面内容的语言，默认是en，这里指定简体中文，也可以使用zh，zh-CN是简体中文，zh支持更广泛的中文，比如繁体、方言等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置网页编码，这个尽可能早的声明，比如放在了title下面，title的可能无法应用这个编码，导致乱码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置视口，这里设置了可视视口和设备视口相等，并且默认不放大缩小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置兼容性，指定浏览器以哪种版本来渲染，比如下面就是ie以edge的方式来渲染--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lte IE8]&gt;</span></span><br><span class="line"><span class="comment">&lt;p&gt;你的浏览器版本过低，请到 &lt;a href="https://browsehappy.com/"&gt;这里&lt;/a&gt; 进行升级&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;[endif]--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里只考虑 IE8 以上版本，上面 body 中的写法是 IE 浏览器中认识的注释提示，如果版本低于 IE8,就会看到提示内容。</p></blockquote><h2 id="cssreset-css-vs-Normalize-css"><a href="#cssreset-css-vs-Normalize-css" class="headerlink" title="cssreset.css vs Normalize.css"></a>cssreset.css vs Normalize.css</h2><p>这两个都是格式化 html 标签样式的库，第一个是把所有 html 的默认样式都去掉了，主要是去掉一些 margin、padding，并且统一了各个浏览器的显示样式。建议使用 Normalize.css</p><p><a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">cssreset.css</a><br><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css 地址</a></p><h2 id="px、em、rem"><a href="#px、em、rem" class="headerlink" title="px、em、rem"></a>px、em、rem</h2><p>[区别请看这]<br>响应式布局建议使用 rem 或者 em。</p><p>使用 rem 时需要注意一点，浏览器对每种字体的大小有个最小下限，比如汉字是 12px，英文是 10px，一次如果 rem 换算后低于这个下限，可能和预期会不一样。</p><h3 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h3><p>高度塌陷就是因为使用了 float 浮动布局，导致父元素的高度预和预想的不一致，因为在计算高度时，浮动的子元素是不包含在内的。</p><p>解决方法：</p><p>1.增加一个空的子元素，设置<code>clear:both</code>样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    ....其他内容</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/&gt;</span></span><br></pre></td></tr></table></figure><p>但这种方式需要无意义的空标签，违背了结构和表现分离的精髓，所以这种方式现在已经不用了。</p><p>2.给父元素增加一个<code>overflow:auto</code>，或者也变成浮动。(就是把父元素变成<code>bfc</code>了)</p><p>3.使用 after 伪元素，在父元素上增加下面的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  content: " "; //使用一个空格或者.</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">table</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用 bfc</p><p>把容器变成 bfc 就可以了。</p><h3 id="html-中的空白字符"><a href="#html-中的空白字符" class="headerlink" title="html 中的空白字符"></a>html 中的空白字符</h3><p>在对<code>li</code>设置成<code>inline-block</code>时，各个元素之间会有 3 像素的空隙，这个就是 html 中的空白字符，就是在编写 html 文件时，各个元素之间的换行符引起的。</p><p>解决方案：</p><ol><li>把所有的<code>li</code>元素都写在一行，这可读性太差</li><li>把父元素的字体大小设置成 0，因为空白字符也属于字符</li><li>把元素的关闭标签和下一个的开始标签写到一块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;aaaa</span><br><span class="line">    &lt;&#x2F;li&gt;&lt;li&gt;bbb</span><br><span class="line">    &lt;&#x2F;li&gt;&lt;li&gt;ccc&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>但是很多格式化工具都给格式化回去了。</p><ol start="4"><li>不闭合</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;&lt;a&gt;aaa&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;li&gt;&lt;a&gt;bbb&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>设置间隙为负值</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设置 inline-block 的容器，font-size 设置成 0，不然有间隙。</p></blockquote><h2 id="文字不换行"><a href="#文字不换行" class="headerlink" title="文字不换行"></a>文字不换行</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>下面是让图片显示成灰色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">filter</span>: <span class="selector-tag">grayscale</span>(100%);</span><br></pre></td></tr></table></figure><h2 id="更改浏览器分辨率插件"><a href="#更改浏览器分辨率插件" class="headerlink" title="更改浏览器分辨率插件"></a>更改浏览器分辨率插件</h2><p><code>Viewport Resizer</code></p><h2 id="使用媒体查询设置不同大小屏幕的样式"><a href="#使用媒体查询设置不同大小屏幕的样式" class="headerlink" title="使用媒体查询设置不同大小屏幕的样式"></a>使用媒体查询设置不同大小屏幕的样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.header</span> <span class="selector-class">.top</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.header</span> <span class="selector-class">.top</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="媒体查询使用相对单位时的坑"><a href="#媒体查询使用相对单位时的坑" class="headerlink" title="媒体查询使用相对单位时的坑"></a>媒体查询使用相对单位时的坑</h3><p>上面已经把 html 的字体大小设置成了 1rem=10px 的关系</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">80rem</span>) &#123;</span><br><span class="line">  <span class="selector-class">.header</span> <span class="selector-class">.top</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的设置会发现，80rem 转换后并不是 800px，而是一千多，这是为什么呢？<br>这是因为媒体查询的级别很高，它不是 html 下面的一个子元素，所以设置 html 的字体大小对它没影响，他使用的是浏览器的字体大小。chrome 默认是 16px；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">50em</span>) &#123;</span><br><span class="line">  <span class="selector-class">.header</span> <span class="selector-class">.top</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的同学发现了，上面单位改成了 em，而不是 rem，因为这个不需要针对 html，所以使用 em 也一样，并且 rem 的兼容性没有 em 好。</p><h2 id="使用媒体查询设置打印样式"><a href="#使用媒体查询设置打印样式" class="headerlink" title="使用媒体查询设置打印样式"></a>使用媒体查询设置打印样式</h2><p>可以通过媒体查询设置打印显示的样式。</p><h2 id="根据不同分辨率加载不同大小的图片"><a href="#根据不同分辨率加载不同大小的图片" class="headerlink" title="根据不同分辨率加载不同大小的图片"></a>根据不同分辨率加载不同大小的图片</h2><p>因为移动端屏幕小，不需要 pc 那样大的图片，并且大图片会导致加载慢，还费流量；所以需要根据不同的分辨率，加载不同尺寸的图片。如何解决呢？</p><h3 id="使用-js-或者服务端返回"><a href="#使用-js-或者服务端返回" class="headerlink" title="使用 js 或者服务端返回"></a>使用 js 或者服务端返回</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> windowWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">if</span>(windowWidth&lt;=<span class="number">480</span>px)&#123;</span><br><span class="line">    $(<span class="string">'imgId'</span>).attr(<span class="string">'src'</span>,<span class="string">'480.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者把尺寸信息放到 cookie 中传给服务端，服务端返回对应图片的地址。</p><h3 id="使用新标记-srcset"><a href="#使用新标记-srcset" class="headerlink" title="使用新标记 srcset"></a>使用新标记 srcset</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img &#123; display: block; width: 100%; &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"测试不同分辨率显示图片"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"/img/ad001.png"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">"./img/ad001.png 480w, ./img/ad001-m.png 800w, ./img/ad001-l.png 1600w"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>当屏幕分辨率小于等于 480px 时，使用 <code>ad001.png</code>，当大于 480px 小于等于 800px 时使用 <code>ad001-m.png</code>;<br>当分辨率被调整到大一级时再缩小回来，也会使用加载后最大的图片来显示，并不会再替换到对应小分辨率设置的图片。因为当加载过大的图片后，就被认为缓存了，再次加载不会造成影响。</p><blockquote><p>注意：<code>img</code> 需要设置成块级元素，不然不管用。</p></blockquote><p>这样有个问题，比如 img 图片是放在一个容器中，img 只是容器的 50%宽，这时图片的加载判断依据还是屏幕的大小，这其实不是很合适，当屏幕是 700px 时，按上面的条件，这时加载的是 800px 的图片，但是图片实际显示大小确实 350px，小于 480px，所以应该加载 480px 的图片。那么该如何设置图片判断的实际尺寸呢？这就需要用到另一个属性<code>sizes</code></p><h3 id="使用新标记-srcset-配合-sizes"><a href="#使用新标记-srcset-配合-sizes" class="headerlink" title="使用新标记 srcset 配合 sizes"></a>使用新标记 srcset 配合 sizes</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"测试不同分辨率显示图片"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"/img/ad001.png"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">"./img/ad001.png 480w, ./img/ad001-m.png 800w, ./img/ad001-l.png 1600w"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sizes</span>=<span class="string">"50vw"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>上面 sizes 设置成<code>50vw</code>，就是说图片按照视频宽度的 50%显示。这样上面的情况图片大小改变就符合实际了。</p><p><code>sizes</code>的值是媒体查询和宽度组成，媒体查询可省略，默认就是所有的分辨率都适应，可以针对不同的分辨率设置不同的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"测试不同分辨率显示图片"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"/img/ad001.png"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">"./img/ad001.png 480w, ./img/ad001-m.png 800w, ./img/ad001-l.png 1600w"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sizes</span>=<span class="string">"(min-width:800px) 800px, 100vw"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>上面的配置就是当屏幕分辨率大于等于 800px 时，图片都是 800px，否则 100%视图宽度显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizes&#x3D;&quot;(min-width:800px) calc(100vw - 30em), 100vw&quot;</span><br></pre></td></tr></table></figure><p>计算大小，注意：减号两边带上空格</p><h3 id="使用新标记-picture"><a href="#使用新标记-picture" class="headerlink" title="使用新标记 picture"></a>使用新标记 picture</h3><p>HTML <code>picture</code> 元素通过包含零或多个 <code>source</code> 元素和一个 <code>img</code> 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 <code>source</code> 元素，如果没有匹配的，就选择 <code>img</code> 元素的 <code>src</code> 属性中的 <code>URL</code> 。然后，所选图像呈现在<code>img</code>元素占据的空间中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(max-width:30em)"</span> <span class="attr">srcset</span>=<span class="string">"./img/ad002.png 480w"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(max-width:50em)"</span> <span class="attr">srcset</span>=<span class="string">"./img/ad002-m.png 800w"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(max-width:87em)"</span> <span class="attr">srcset</span>=<span class="string">"./img/ad002-l.png 1600w"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(orientation:landscape)"</span> <span class="attr">srcset</span>=<span class="string">"./img/ad002-m.png 800w"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/svg+xml"</span> <span class="attr">srcset</span>=<span class="string">"logo.svg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/webp"</span> <span class="attr">srcset</span>=<span class="string">"logo.webp 400w, logo-m.webp 800w"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/ad002.png"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据不同的媒体条件加载不同的图片。<br>上面第四个是横屏的设置。<br>注意几点：</p><ol><li>media 的值必须被小括号括起来，不然不起作用、</li><li>必须有 img 标签</li></ol><p><code>picture</code> 比 <code>img</code> 使用 <code>srcset</code> 要智能，即使放到最大再缩小回来，还是会加载对应条件的图片。</p><p>使用 svg 的图片</p><h3 id="使用-svg-格式的图片"><a href="#使用-svg-格式的图片" class="headerlink" title="使用 svg 格式的图片"></a>使用 svg 格式的图片</h3><p>矢量图，它是根据一定的规则来绘制图片，而不是像素。在不同的分辨率下不会失真，且图片尺寸小。</p><p>在线绘制网站</p><p><a href="https://editor.method.ac/" target="_blank" rel="noopener">第一个</a><br><a href="https://icomoon.io/" target="_blank" rel="noopener">第二个</a></p><h3 id="兼容性对比"><a href="#兼容性对比" class="headerlink" title="兼容性对比"></a>兼容性对比</h3><p>IE 浏览器完全不支持 srcset 和 picture，安卓浏览器支持也不好，而 svg 是支持比较好的。但是有些图片色彩比较丰富，必须使用位图，使用位图，我们就是用 pictrue 或者 srcset 来做，然后通过 polyfill 来解决兼容性的问题。图片的 polyfill 我们使用 <a href="https://github.com/scottjehl/picturefill" target="_blank" rel="noopener">Pictruefill</a>的工具库来解决，下载并引用这个 js 库即可。=</p><blockquote><p>polyfill 就是泥瓦匠的那个腻子，往墙上抹水泥的那个。</p></blockquote><h3 id="压缩图片网站"><a href="#压缩图片网站" class="headerlink" title="压缩图片网站"></a>压缩图片网站</h3><p><a href="https://iconizr.com/" target="_blank" rel="noopener">压缩 svg 网站</a></p><p><a href="https://tinypng.com/" target="_blank" rel="noopener">压缩 png 网站</a></p><h2 id="什么是-DPR"><a href="#什么是-DPR" class="headerlink" title="什么是 DPR"></a>什么是 DPR</h2><p>dpr 是设备像素比，就是物理像素和显示像素的比。</p><h2 id="搭建服务"><a href="#搭建服务" class="headerlink" title="搭建服务"></a>搭建服务</h2><p>使用 http-server，也可以 serve 这些线程的 node.js 服务包</p><h2 id="云测试网站"><a href="#云测试网站" class="headerlink" title="云测试网站"></a>云测试网站</h2><p><a href="https://testin.cn/" target="_blank" rel="noopener">https://testin.cn/</a></p><p><a href="http://genymotion.net/" target="_blank" rel="noopener">移动端虚拟机</a></p><h2 id="使用-hacks-来解决兼容性"><a href="#使用-hacks-来解决兼容性" class="headerlink" title="使用 hacks 来解决兼容性"></a>使用 hacks 来解决兼容性</h2><p><a href="http://browserhacks.com/" target="_blank" rel="noopener">查看各浏览器或设备的 hacks 信息</a></p><p>使用 pollyfill 或 shiv 来解决兼容性</p><ul><li><a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="noopener">html5shiv</a></li><li><a href="https://github.com/scottjehl/Respond" target="_blank" rel="noopener">一个有名的 pollyfile-Respond</a></li></ul><p>手动来检测是否支持一些特性<br><a href="https://modernizr.com/" target="_blank" rel="noopener">https://modernizr.com/</a></p><p><a href="http://browsersync.cn/" target="_blank" rel="noopener">省时的浏览器同步测试工具</a><br>就是启动一个会自动刷新的服务，但是多个设备上的网页操作是同步的，比如开了三个浏览器，滚动一个，其他两个也会滚动。包括更改内容，等等都是同步的。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p><a href="https://javascript-minifier.com/" target="_blank" rel="noopener">代码压缩网站</a></p><p>使用一些第三方构建工具</p><ul><li>[gulp]</li><li>[webpack]</li></ul><h2 id="响应式框架"><a href="#响应式框架" class="headerlink" title="响应式框架"></a>响应式框架</h2><ul><li><a href="https://www.bootcss.com/" target="_blank" rel="noopener">Bootstrap</a></li><li><a href="">Foundation</a></li><li><a href="https://semantic-ui.com/" target="_blank" rel="noopener">Semantic UI</a></li><li><a href="http://www.purecss.cn/" target="_blank" rel="noopener">PureCSS</a></li></ul><h2 id="原型设计的工具"><a href="#原型设计的工具" class="headerlink" title="原型设计的工具"></a>原型设计的工具</h2><ul><li>Balsamlq Mockups 3</li><li>axure</li><li>sketch (mac)</li></ul><h2 id="交互工具"><a href="#交互工具" class="headerlink" title="交互工具"></a>交互工具</h2><ul><li><a href="http://www.flinto.com.cn/" target="_blank" rel="noopener">flinto</a></li><li><a href="https://principleformac.com/" target="_blank" rel="noopener">principleformac</a></li></ul><p>让图片动起来，用 UI 的设计图把交互工程连起来，还能导出 gif 动画。</p>]]></content>
      
      
      <categories>
          
          <category> 响应式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 响应式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem和em的区别</title>
      <link href="/2020/02/21/rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/02/21/rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h3><blockquote><ul><li>EM 是根据<code>自身字体</code>大小来转换成像素；</li><li>很多时候感觉是根据父节点来计算的，其实是子节点继承了父节点的字体大小，无论什么情况都是先计算出本身字体大小，然后再根据自身字体的大小把 em 转换成像素</li><li>如果本身的字体也是设置的 em，则先根据父节点的字体算出自身字体的大小</li></ul></blockquote><a id="more"></a><h3 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h3><blockquote><p>rem 是根据 html 标签的字体大小来转换成对应的像素，而 html 的字体大小又是相对于浏览器设置的字体大小，默认是 16px；<br>如果 html 的字体大小也设置成 rem，那么这个需要根据浏览器的字体进行转换。</p></blockquote><p>###demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; style&#x3D;&quot;font-size:20px;&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">        &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">        &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .divBorder &#123;</span><br><span class="line">                border: 1px solid black;</span><br><span class="line">                margin: 5px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .emContainer &#123;</span><br><span class="line">                font-size: 30px;</span><br><span class="line">                border: 1px solid black;</span><br><span class="line">                margin: 5px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .继承根节点 &#123;</span><br><span class="line">                margin-left: 0.8em;</span><br><span class="line">                border: 1px solid red;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .继承 &#123;</span><br><span class="line">                margin-left: 0.8em;</span><br><span class="line">                border: 1px solid yellow;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .本身设置字体 &#123;</span><br><span class="line">                font-size: 40px;</span><br><span class="line">                margin-left: 0.6em;</span><br><span class="line">                border: 1px solid green;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .本身设置em字体 &#123;</span><br><span class="line">                font-size: 1.5em;</span><br><span class="line">                margin-left: 0.6em;</span><br><span class="line">                border: 1px solid green;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             .rem继承根节点 &#123;</span><br><span class="line">                margin-left: 0.8rem;</span><br><span class="line">                border: 1px solid red;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .rem继承 &#123;</span><br><span class="line">                margin-left: 0.8rem;</span><br><span class="line">                border: 1px solid yellow;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .rem本身设置字体 &#123;</span><br><span class="line">                font-size: 40px;</span><br><span class="line">                margin-left: 0.6rem;</span><br><span class="line">                border: 1px solid green;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .rem本身设置em字体 &#123;</span><br><span class="line">                font-size: 1.5rem;</span><br><span class="line">                margin-left: 0.6rem;</span><br><span class="line">                border: 1px solid green;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;em是根据自身的字体大小来计算成对应的px值&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;divBorder&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;rem继承根节点&quot;&gt;测试继承根节点，em根据自身从父节点继承的字体大小来计算em的值。&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;emContainer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;继承&quot;&gt;测试继承父节点的字体大小，em根据自身从父节点继承的字体大小来计算em的值。&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;emContainer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;本身设置字体&quot;&gt;测试设置本身字体大小，em直接根据自身设置的字体大小进行计算。&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;emContainer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;本身设置em字体&quot;&gt;本身字体以em方式设置，先计算本身字体大小，然后再根据自身字体大小计算其他的em设置&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h2&gt;rem是根据html标签的字体大小来计算成对应的px值&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;divBorder&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;rem继承根节点&quot;&gt;测试继承根节点，em根据自身从父节点继承的字体大小来计算em的值。&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;emContainer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;rem继承&quot;&gt;测试继承父节点的字体大小，em根据自身从父节点继承的字体大小来计算em的值。&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;emContainer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;rem本身设置字体&quot;&gt;测试设置本身字体大小，em直接根据自身设置的字体大小进行计算。&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;emContainer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;rem本身设置em字体&quot;&gt;本身字体以em方式设置，先计算本身字体大小，然后再根据自身字体大小计算其他的em设置&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="http://caibaojian.com/rem-vs-em.html" target="_blank" rel="noopener">参考</a><br><a href="https://drafts.csswg.org/css-values-3/#absolute-lengths" target="_blank" rel="noopener">官网地址</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点串讲-3</title>
      <link href="/2020/02/20/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-3/"/>
      <url>/2020/02/20/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-3/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><h3 id="什么是-DOCTYPE-及作用"><a href="#什么是-DOCTYPE-及作用" class="headerlink" title="什么是 DOCTYPE 及作用"></a>什么是 DOCTYPE 及作用</h3><p>DTD (document type definition,文档类型定义）是一系列的语法规则，用来定义 XML 或(X)HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析， 以及切换浏览器模式。</p><blockquote><p>简单来说：DTD 就是告诉浏览器我是什么文档类型，浏览器根据这个来决定用什么引擎来解析和渲染它。</p></blockquote><p>DOCTYPE 是用来声明文档类型和 DTD 规范的，一个主要的用途便是文件的合法性验证。<br>如果文件代码不合法，那么浏览器解析时便会出一些差错</p><blockquote><p>大白话就是：DOCTYPE 就是直接告诉浏览器什么是 DTD 的，也就是说 DOCTYPE 通知浏览器，告诉当前的文档，包含的是哪个 DTD，也就是哪个文档类型</p></blockquote><ul><li>HTML5<!DOCTYPE html></li><li>HTML4.01 Strict<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 //EN" "http://www.w3.org/TR/html4/strict.dtd"><blockquote><p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素(如：font)</p></blockquote></li><li>HTML4.01 Transitional<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><blockquote><p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素(如：font)</p></blockquote></li></ul><p>面试时，如果能说出三种及严格和宽松的区别即可，具体写法不需要记住。</p><a id="more"></a><h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><h3 id="什么是-Reflow"><a href="#什么是-Reflow" class="headerlink" title="什么是 Reflow"></a>什么是 Reflow</h3><ul><li>定义<br>DOM 结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素 放到它该出现的位置，这个过程称之为 reflow</li><li>触发 ReflowReflow<ol><li>当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint</li><li>当你移动 DOM 的位置，或是搞个动画的时候</li><li>当你修改 CSS 样式的时候</li><li>当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候</li><li>当你修改网页的默认字体时</li></ol></li></ul><h3 id="什么是重绘-Repaint"><a href="#什么是重绘-Repaint" class="headerlink" title="什么是重绘 Repaint"></a>什么是重绘 Repaint</h3><ul><li>定义<br>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称$为 repaint<blockquote><p>简而言之：把计算后的结果统统画到屏幕上</p></blockquote></li><li>触发 Repaint<br>DOM 改动<br>CSS 改动</li><li>如何避免最小的 repaint<br>使用文档节点，把所有的更改最后一次添加到页面中，不要改一个提交一个</li></ul><h2 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h2><p><a href="https://segmentfault.com/n/1330000013987637" target="_blank" rel="noopener">https://segmentfault.com/n/1330000013987637</a></p><blockquote><p>教程里面说，定时器的时间是放到异步队列的时间不是执行时间，这有点不明白，如果设置 1 秒，1 秒后放到异步队列中，如果这时异步队列中有其他的任务在排队，那不是会延迟执行了吗？那就是说除了运行栈可能导致延迟，任务队列也有肯能导致延迟了？</p></blockquote><h2 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h2><h3 id="题目：提升页面性能的方法有哪些？"><a href="#题目：提升页面性能的方法有哪些？" class="headerlink" title="题目：提升页面性能的方法有哪些？"></a>题目：提升页面性能的方法有哪些？</h3><ol><li>资源压缩合并，减少 HTTP 请求</li><li>非核心代码异步加载——► 异步加载的方式———► 异步加载的区别</li><li>利用浏览器缓存——► 缓存的分类———-► 缓存的原理</li><li>使用 CDN</li><li>预解析 DNS</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// https</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//host_name一to_prefetch.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>页面中的 a 标签，在高级浏览器中默认是打开了 dns 预解析的，但是如果使用的是 htpps 协议或者浏览器默认关闭 dns 预解析的，使用第一句可以强制打开 a 标签的 dns 预解析。(教程说的是 a 标签，mdn 说的是所有可点击的 url)<br><a href="https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching</a></p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><h4 id="1-异步加载的方式"><a href="#1-异步加载的方式" class="headerlink" title="1.异步加载的方式"></a>1.异步加载的方式</h4><p>1、动态脚本加载<br>2、defer 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发  <code>DOMContentLoaded</code>  事件前执行<br>3、async</p><h4 id="2-异步加载的区别"><a href="#2-异步加载的区别" class="headerlink" title="2.异步加载的区别"></a>2.异步加载的区别</h4><p>1、defer 是在 HTML 解析完之后才会执行，如果是多个，按照加载的顺序<strong>依次</strong>执行<br>2、async 是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</p><h4 id="3-触发条件-重点"><a href="#3-触发条件-重点" class="headerlink" title="3.触发条件 (重点)"></a>3.触发条件 (重点)</h4><p>如果页面中有被<code>async/defer</code>标记的<code>script</code>标签，页面中必须有正常的引用外部<code>js</code>的<code>script</code>标签才有用，不然不起作用，和没标记一样，并不会异步加载和执行，也是在 DOM 解析完后才开始加载。<br>只有遇到了正常引用外部 js 的 script 标签才开始异步加载；在没遇到正常的引用外部 js 的 script 标签前是不会开始加载的。<br>也就是说：<code>async的触发条件是遇到正常引用外部js的script标签；（遇到内嵌的script标签没用）</code><br>比如这个例子，如果没有引用 main.js，则标记的两个 async 也是最后才加载执行。如果把引用 main.js 的 script 标签放到内部执行 5s 的 js 后面，async 标记的 script 也是在 5s 后和 main.js 一起开始加载</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><h4 id="1-缓存的分类"><a href="#1-缓存的分类" class="headerlink" title="1.缓存的分类"></a>1.缓存的分类</h4><ol><li>强 缓 存<br><code>Expires</code> Expires:Thu, 21 Jan 2017 23:39:02 GMT<br><code>Cache-Control</code> Cache-Control:max-age=3600</li><li>协 商 缓 存<br><code>Last-Modified</code>、<code>If-Modified-Since</code><br>Last-Modified: Wed, 26 Jan 2017 00:35:11 GMT<br><code>Etag</code> <code>If-None-Match</code><br>就是咨询下服务器前端的缓存是否还能用。</li></ol><h2 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h2><h3 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h3><p>1.即时运行错误：代码错误 2.资源加载错误</p><h3 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h3><p>1.即时运行错误：代码错误<br>1）try … catch<br>2）window.onerror 这个无法捕获资源加载错误</p><p>2.资源加载错误<br>1）object.onerror 这个事件不冒泡<br>2）performance.getEntries()<br>3）Error 事件捕获</p><p>上面不是说了资源加载错误不能被 window.onerror 捕获吗？那是在冒泡阶段不能，但是这种错误在捕获阶段是可以的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"error"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"捕获到错误了"</span>, e);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">true</span>, <span class="comment">// true是捕获，false冒泡</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//baidu.com/abc.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="跨域的-js-运行错误可以捕获吗，错误提示什么，应该怎么处理"><a href="#跨域的-js-运行错误可以捕获吗，错误提示什么，应该怎么处理" class="headerlink" title="跨域的 js 运行错误可以捕获吗，错误提示什么，应该怎么处理?"></a>跨域的 js 运行错误可以捕获吗，错误提示什么，应该怎么处理?</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-a82d357668815702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li><p>在 script 标签增加 <code>crossorigin</code> 属性 —前端</p></li><li><p>设置 js 资源响应头 <code>Access-Control-Allow-Origin:\*</code> —服务端</p></li></ol><h3 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h3><p>1.采用 Ajax 的方式上报<br>但所有的错误监控都不使用这种方式。</p><p>2.利用 image 对象上报<br>都是用的这种方式。这种方式比较简单，不需要引用任何 js 库。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 错误上报方式</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">new</span> Image().src = <span class="string">"http://baidu.com/sdfas?a=abc"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css实现边框的部分显示</title>
      <link href="/2020/02/20/css%E5%AE%9E%E7%8E%B0%E8%BE%B9%E6%A1%86%E7%9A%84%E9%83%A8%E5%88%86%E6%98%BE%E7%A4%BA/"/>
      <url>/2020/02/20/css%E5%AE%9E%E7%8E%B0%E8%BE%B9%E6%A1%86%E7%9A%84%E9%83%A8%E5%88%86%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#bbb</span>;</span></span><br><span class="line">    padding: 4px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">div</span><span class="selector-pseudo">:before</span> &#123;</span></span><br><span class="line">    content: "";</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: -2px;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 2px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>请看这个div的“上边框”是只有一半的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数组乱序</title>
      <link href="/2020/01/16/js%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F/"/>
      <url>/2020/01/16/js%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// function randomSort1(a, b) &#123;</span></span><br><span class="line"><span class="comment">//   return Math.random() &gt; 0.5 ? -1 : 1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * len);</span><br><span class="line">    <span class="keyword">let</span> cur = arr[i];</span><br><span class="line">    arr[i] = arr[random];</span><br><span class="line">    arr[random] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">randomSort(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>parseInt的用法</title>
      <link href="/2020/01/16/parseInt%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2020/01/16/parseInt%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>先看如下输出结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map(<span class="built_in">parseInt</span>);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br></pre></td></tr></table></figure><p>这里需要注意 parseInt 的用法，尤其是第二个参数的含义。</p><a id="more"></a><p>用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix);</span><br></pre></td></tr></table></figure><ul><li>string<br>如果 string 不是字符串类型，则会传递调用 toString()来转换。</li><li>radix<br>指定字符串 string 的基数，也就是指定 string 是什么进制；比如 radix 是 8，则表示 string 是 8 进制的数，而不是转换成 8 进制的数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js运行机制执行顺序</title>
      <link href="/2020/01/16/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2020/01/16/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://www.houdunren.com/edu/front/video/13393" target="_blank" rel="noopener">讲解链接</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery中attr和prop的区别</title>
      <link href="/2020/01/16/jquery%E4%B8%ADattr%E5%92%8Cprop%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/16/jquery%E4%B8%ADattr%E5%92%8Cprop%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在<code>jQuery</code>中有两个设置元素属性的方法，<code>prop</code>和<code>attr</code>,在使用的时候很多同学分不清该选择哪一个，只能先用一个，不管用了再试另一个，虽然开发中没什么影响，但总是感觉脑中一团迷雾，下面来讲解这个两个的区别。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p>对于 HTML 元素本身就带有的<code>固有属性</code>，在处理时，使用<code>prop</code>方法。</p></li><li><p>对于 HTML 元素我们自己<code>自定义</code>的 DOM 属性，在处理时，使用<code>attr</code>方法。</p></li></ul><a id="more"></a><h3 id="深度理解"><a href="#深度理解" class="headerlink" title="深度理解"></a>深度理解</h3><ul><li><code>attribute</code>是<code>HTML</code>属性，<code>property</code>是<code>js</code>属性;</li><li>简单来说就是只要写在 html 元素上的属性都可以使用 attribute 来获取，因为 attribute 代表的就是 html 的属性，包括自定义的；</li><li>property 代表的是 js 对象的属性，自定义的属性在 html 元素对应的 js 对象中是没有对应的属性的，所以 property 获取不到；</li></ul><p><code>jquery</code>使用两个方法直接区分了这两个属性，原生的 js 通过 getAttribute()方法和点的方式获取属性来区分，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"txtName"</span> name=<span class="string">"txtName"</span> disabled /&gt;</span><br><span class="line">&lt;a href=<span class="string">"/user/list.html"</span> id=<span class="string">"a"</span> myName=<span class="string">"zhangssan"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//js代码</span></span><br><span class="line"><span class="keyword">var</span> txtName=<span class="built_in">document</span>.getElementById(<span class="string">"txtName"</span>);</span><br><span class="line"><span class="keyword">var</span> a=<span class="built_in">document</span>.getElementById(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">txtName.getAttribute(<span class="string">"name"</span>);  <span class="comment">//jquery的attr方式</span></span><br><span class="line">txtName.name                <span class="comment">//property获取方式</span></span><br></pre></td></tr></table></figure><ul><li>如果是 HTML 元素原有的属性，使用 attribute 和 property 都可以获取到，但是自定义的属性，只能使用 attribute 的方式来获取；</li><li>另外需要注意的是，有些属性通过 attribute 和 property 获取的值不同；比如<code>diabled</code>、<code>href</code>、<code>自定义属性</code>等；</li><li><code>disabled</code>通过 attribute 获取不到值或者是 disabled 字符串，通过 property 获取的是 true 或 false</li><li><code>href</code>通过 attribute 获取的是 html 元素中写的值，比如上面的就是<code>/user/list.html&quot;</code>,但用 property 获取的就是加上域名的，比如<code>http://www.baidu.com/user/list.html</code></li><li>如果通过 property 方式修改<code>自定义属性</code>的值，<code>attribute</code>是获取不到的，因为更改的是 js 的<code>property</code>对象，<code>attribute</code>对象中的值并没有被更改</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中_proto_和prototype的区别</title>
      <link href="/2020/01/16/JavaScript%E4%B8%AD-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/16/JavaScript%E4%B8%AD-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="先说个总结-1-对象有属性-proto-，指向该对象的构造函数的原型对象。-2-方法除了有属性-proto-还有属性prototype-prototype指向该方法的原型对象-3-prototype-proto-都指向Object-prototype"><a href="#先说个总结-1-对象有属性-proto-，指向该对象的构造函数的原型对象。-2-方法除了有属性-proto-还有属性prototype-prototype指向该方法的原型对象-3-prototype-proto-都指向Object-prototype" class="headerlink" title="先说个总结 1.对象有属性__proto__，指向该对象的构造函数的原型对象。 2.方法除了有属性__proto__,还有属性prototype,prototype指向该方法的原型对象 3.prototype.__proto__都指向Object.prototype"></a>先说个总结 1.对象有属性<code>__proto__</code>，指向该对象的构造函数的原型对象。 2.方法除了有属性<code>__proto__</code>,还有属性<code>prototype</code>,<code>prototype</code>指向该方法的原型对象 3.<code>prototype.__proto__</code>都指向<code>Object.prototype</code></h3><h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p><img src="https://i.loli.net/2020/01/16/j8k1igHYnWFQcfL.jpg" alt="关系图"><br><a href="https://sm.ms/" target="_blank" rel="noopener">使用 SMMS 存储图片</a>，这种平台找好久了。</p><a id="more"></a><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">person.prototype = &#123; <span class="attr">atrr1</span>: <span class="string">"aaaa"</span>, <span class="attr">atrr2</span>: <span class="string">"bbbb"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> person();</span><br><span class="line"><span class="built_in">console</span>.log(obj.atrr1);</span><br><span class="line"><span class="built_in">console</span>.log(obj.atrr2);</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> person);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"**********************************"</span>);</span><br><span class="line">person.prototype = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.atrr1);</span><br><span class="line"><span class="built_in">console</span>.log(obj.atrr2);</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> person);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"**********************************"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(person.prototype);</span><br></pre></td></tr></table></figure><h4 id="先讲个容易入坑的知识点"><a href="#先讲个容易入坑的知识点" class="headerlink" title="先讲个容易入坑的知识点"></a>先讲个容易入坑的知识点</h4><p><code>instanceof</code>是根据原型链来判断实例是否属于某个类型。 ####误解<br>因实例的<code>__proto__</code>指向的是类的<code>prototype</code>，因此可能会认为，当类的<code>prototype</code>发生改变时，实例<strong>proto</strong>也发生了改变，所以<strong>proto</strong>也是新的。<br>这就打错特错了。 ####解释<br>实例的<strong>proto</strong>指向类的 prototype 不错，但是他们指向的都是一个地址。他们不过是地址的“变量”而已，而变量是可以指向一个新的地址，但是老的地址并不会因为变量的改变而改变。老的地址还是存在的。<br>所以上面的题，当改变 person 的 prototype 指向时，他们是不相等的，因为他们分别指向了不同的地址。</p><h3 id="更直接的例子"><a href="#更直接的例子" class="headerlink" title="更直接的例子"></a>更直接的例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> man = &#123; <span class="attr">name</span>: <span class="string">"lisi"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> woman = man;</span><br><span class="line">man = &#123; <span class="attr">name</span>: <span class="string">"zhangsan"</span> &#125;;</span><br></pre></td></tr></table></figure><p>man 只是一个变量，当指向新的地址时，lisi 还在那。</p><p><img src="../images/1081818-20181226113959129-841742312.jpg" alt="关系图"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据类型的总结及判断的各种方法优缺点</title>
      <link href="/2020/01/16/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A4%E6%96%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2020/01/16/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A4%E6%96%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="js-中的数据类型"><a href="#js-中的数据类型" class="headerlink" title="js 中的数据类型"></a>js 中的数据类型</h3><p>js 中只有<code>六种</code>原始数据类型和一个<code>Object</code>:</p><blockquote><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>String</li><li>Symbol (ECMAScript 6 新定义)</li><li>Object</li></ul></blockquote><p>大家认真记清这个描述，不要到时候把 Array、Date 都当成 js 的数据类型就尴尬了。那可能会有人问，那 Array 和 Date 算什么呢，他们都属于 Object，看下面分类：</p><a id="more"></a><h3 id="Object-分类"><a href="#Object-分类" class="headerlink" title="Object 分类"></a>Object 分类</h3><blockquote><p>Object 分为<strong>本地对象</strong>、<strong>内置对象</strong>和<strong>宿主对象</strong>三种</p></blockquote><h3 id="本地对象"><a href="#本地对象" class="headerlink" title="本地对象"></a>本地对象</h3><blockquote><p>定义：独立于宿主环境的 ECMAScript 实现提供的对象。简单的说就是 ECMA 定义的类。他们包括：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>   <span class="built_in">Function</span>   <span class="built_in">Array</span>   <span class="built_in">String</span></span><br><span class="line"><span class="built_in">Boolean</span>   <span class="built_in">Number</span>  <span class="built_in">Date</span> <span class="built_in">RegExp</span></span><br><span class="line"><span class="built_in">Error</span>   <span class="built_in">EvalError</span>   <span class="built_in">RangeError</span>  <span class="built_in">ReferenceError</span></span><br><span class="line"><span class="built_in">SyntaxError</span>   <span class="built_in">TypeError</span> <span class="built_in">URIError</span></span><br></pre></td></tr></table></figure><p>所以 Array 和 Date 都属于对象类型，它们是本地对象。</p><hr><h3 id="疑问：-1-有人可能会问，为什么-String-也是-Object-类型，上面不是说了是原始类型吗？"><a href="#疑问：-1-有人可能会问，为什么-String-也是-Object-类型，上面不是说了是原始类型吗？" class="headerlink" title="疑问： 1.有人可能会问，为什么 String 也是 Object 类型，上面不是说了是原始类型吗？"></a>疑问： 1.有人可能会问，为什么 String 也是 Object 类型，上面不是说了是原始类型吗？</h3><p>答：原始类型中有字符串 String 不错，它只是表达了一种数据类型，但数据类型也有自己的类定义啊，是吧，上面的 String 说的就是它的类型定义，是个对象，所以当然也是引用类型了。其他同理。<br>看下面 demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">typeof</span> str1; <span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> str2; <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想获取str2的字符串，可以通过str2.toString()</span></span><br><span class="line"></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><blockquote><p>定义：“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已经被实例化了。<br>内置对象只有两个<code>Global</code>和<code>Math</code>,他们其实也是本地对象，根据定义每个内置对象都是本地对象。</p></blockquote><h3 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h3><blockquote><p>所有非本地对象都是宿主对象，即由 ECMAScript 实现的宿主环境提供的对象。所有<code>BOM</code>和<code>DOM</code>对象都是宿主对象。</p></blockquote><hr><p>###typeof<br>最常见的判断方法：typeof,它的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">官方解释</a>：</p><blockquote><p>typeof 操作符返回一个字符串，表示未经计算的操作数的类型。<br>简单理解就是<code>typeof</code>是判断的是原始类型（值类型），但函数返回的是<code>function</code>，null 返回的也是<code>object</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Undefined; <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="keyword">typeof</span> num; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="typeof-各类型返回结果列表"><a href="#typeof-各类型返回结果列表" class="headerlink" title="typeof 各类型返回结果列表"></a>typeof 各类型返回结果列表</h3><table><thead><tr><th>类型</th><th>结果</th></tr></thead><tbody><tr><td>Undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Symbol （ECMAScript 6 新增）</td><td>“symbol”</td></tr><tr><td>宿主对象（由 JS 环境提供）</td><td>Implementation-dependent</td></tr><tr><td>函数对象（[[Call]] 在 ECMA-262 条款中实现了）</td><td>“function”</td></tr><tr><td>任何其他对象</td><td>“object”</td></tr></tbody></table><blockquote><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签也成为了 0，typeof null 就错误的返回了”object”。<br>###typeof 优缺点列表<br>|优点|缺点|<br>|—-|—-|<br>|判断原始类型比较方便|null 返回的是 object|<br>| |方法返回的是 function|<br>| |所有的引用类型都返回 object,Array、Date 等不能准确定位|</p></blockquote><hr><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p>定义：“instanceof 运算符用来测试一个<strong>对象（第一个参数）</strong>在其原型链中是否存在一个构造函数（第二个参数）的 prototype 属性。”<br>简单理解就是：instanceof 是判断两个对象“最近”prototype 是否一样。<br>另外，instanceof 是判断对象是否属于某一类型，而不是获取的对象的类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1=<span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> str2=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">man.prototype=<span class="keyword">new</span> person();</span><br><span class="line"><span class="keyword">var</span> m1=<span class="keyword">new</span> person();</span><br><span class="line"><span class="keyword">var</span> m2=<span class="keyword">new</span> man();</span><br><span class="line"></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span>    <span class="comment">//false</span></span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span>    <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>      <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">window</span>.frames[<span class="number">0</span>].Array  <span class="comment">//false</span></span><br><span class="line">m1 <span class="keyword">instanceof</span> person      <span class="comment">//true</span></span><br><span class="line">m2 <span class="keyword">instanceof</span> man         <span class="comment">//true</span></span><br><span class="line">m2 intanceof person       <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="优缺点列表"><a href="#优缺点列表" class="headerlink" title="优缺点列表"></a>优缺点列表</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>判断对象的具体类型</td><td>只能判断对象，对原始类型不能判断</td></tr><tr><td></td><td>多全局对象时返回不正确</td></tr></tbody></table><h3 id="多全局对象解释"><a href="#多全局对象解释" class="headerlink" title="多全局对象解释"></a>多全局对象解释</h3><blockquote><p>简单来说:多全局对象就是跨窗口或跨 frame 操作。</p></blockquote><h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。<br>这可能会引发一些问题。<br>比如，表达式 [] instanceof window.frames[0].Array 会返回 false，因为 Array.prototype !== window.frames[0].Array.prototype，因此你必须使用 Array.isArray(myObj) 或者 Object.prototype.toString.call(myObj) === “[object Array]”来判断 myObj 是否是数组。</p><hr><h3 id="根据对象的-constructor-判断"><a href="#根据对象的-constructor-判断" class="headerlink" title="根据对象的 constructor 判断"></a>根据对象的 constructor 判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alert(c.constructor === <span class="built_in">Array</span>) ----------&gt; <span class="literal">true</span></span><br><span class="line">alert(d.constructor === <span class="built_in">Date</span>) -----------&gt; <span class="literal">true</span></span><br><span class="line">alert(e.constructor === <span class="built_in">Function</span>) -------&gt; <span class="literal">true</span></span><br><span class="line">注意： <span class="keyword">constructor</span> 在类继承时会出错</span><br><span class="line">eg：</span><br><span class="line">      function A()&#123;&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">      A.prototype = <span class="keyword">new</span> B(); <span class="comment">//A继承自B</span></span><br><span class="line">      <span class="keyword">var</span> aObj = <span class="keyword">new</span> A();</span><br><span class="line">      alert(aobj.constructor === B) -----------&gt; <span class="literal">true</span>;</span><br><span class="line">      alert(aobj.constructor === A) -----------&gt; <span class="literal">false</span>;</span><br><span class="line">而<span class="keyword">instanceof</span>方法不会出现该问题，对象直接继承和间接继承的都会报<span class="literal">true</span>：</span><br><span class="line">      alert(aobj <span class="keyword">instanceof</span> B) ----------------&gt; <span class="literal">true</span>;</span><br><span class="line">      alert(aobj <span class="keyword">instanceof</span> B) ----------------&gt; <span class="literal">true</span>;</span><br><span class="line">言归正传，解决construtor的问题通常是让对象的<span class="keyword">constructor</span>手动指向自己：</span><br><span class="line">      aobj.<span class="keyword">constructor</span> = A; //将自己的类赋值给对象的<span class="keyword">constructor</span>属性</span><br><span class="line">      alert(aobj.<span class="keyword">constructor</span> === A) -----------&gt; true;</span><br><span class="line">      alert(aobj.<span class="keyword">constructor</span> === B) -----------&gt; false; //基类不会报true了;</span><br></pre></td></tr></table></figure><p>缺点：继承的对象判断时，不准确。感觉鸡肋。</p><p>最靠谱的方法： Object.prototype.toString.call(obj)</p><ul><li>这种方法不存在多全局环境和 Array、null 返回 object 的情况，</li><li>原始类型和原始类型对应的引用类型声明的变量都能返回正确的值</li><li>但是这个方法对自定义类型无效，自定义类型返回的都是<code>Object</code>，所以自定义时还是使用<code>instanceof</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(str1); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(str2); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(man); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/test/</span>); <span class="comment">//[object RegExp]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>不存在多全局环境问题</td><td>只能判断本地对象和宿主对象</td></tr><tr><td>原始类型无论是字面量语法声明还是通过对应的引用类型声明都能正确判断</td><td>自定义类型都返回[object Object]</td></tr></tbody></table><hr><h3 id="jquery-type"><a href="#jquery-type" class="headerlink" title="jquery.type()"></a>jquery.type()</h3><p>就是对 prototype 的封装。源码附上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span> ?</span><br><span class="line">            <span class="built_in">String</span>( obj ) :</span><br><span class="line">            class2type[ toString.call(obj) ] || <span class="string">"object"</span>;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="对数组的判断"><a href="#对数组的判断" class="headerlink" title="对数组的判断"></a>对数组的判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">typeof</span> arr; <span class="comment">//object  分辨不出类型</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true //受多全局环境影响</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">//[object Array] //推荐</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">//true //推荐</span></span><br><span class="line">$.type(arr); <span class="comment">//array  //推荐</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grid布局笔记</title>
      <link href="/2020/01/16/grid%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/16/grid%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">具体可参考阮一峰老师的介绍</a><br>这里只记录一些容易产生误解的地方。</p><h2 id="justify-items-属性，align-items-属性，place-items-属性"><a href="#justify-items-属性，align-items-属性，place-items-属性" class="headerlink" title="justify-items 属性，align-items 属性，place-items 属性"></a>justify-items 属性，align-items 属性，place-items 属性</h2><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。<br>第一次看我想大多都会认为这不就是设置内容的对齐方式吗，是吧？<br>答案：不是，不然我也不会专门写这个笔记。</p><p>我的理解：</p><blockquote><p><code>justify-items</code>和<code>align-items</code>是设置<code>内容区的开始方式</code>，不是内容的对齐方式。默认是 stretch 的效果；</p></blockquote><p>比如现在一个宽高都是 50px 的正方形区域，默认整个区域都是内容区域，比如设置背景为红色，那回看到一个宽高都是 50px 的正方形，这应该都能理解；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class="container"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1348523-c962f4631c20869d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果设置了<code>justify-items:start</code>(需要启用 grid 模式)，则内容区域则是从左开始，直到够现实内容即可，剩下的就不是内容区域了，比如下面的效果图是每个元素都是 80px 的正方形，但是背景色只是显示了由内容的地方，设置成 stretch 就成了上面的效果了。<br><img src="https://upload-images.jianshu.io/upload_images/1348523-696d314dac297570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在子元素上设置的<code>justify-self</code>和这个一个意思。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水平垂直居中的方式</title>
      <link href="/2020/01/16/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/01/16/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>div 绝对定位水平垂直居中【margin:auto 实现绝对定位元素的居中】，</p><p>兼容性：,IE7 及之前版本不支持</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 方案二</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> 绝对定位水平垂直居中【<span class="selector-tag">margin</span> 负间距】      这或许是当前最流行的使用方法。</span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">css</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>div 绝对定位水平垂直居中【Transforms 变形】</p><p>兼容性：IE8 不支持；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><p>css 不定宽高水平垂直居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案五"><a href="#方案五" class="headerlink" title="方案五"></a>方案五</h2><p>将父盒子设置为 table-cell 元素，可以使用 text-align:center 和 vertical-align:middle 实现水平、垂直居中。比较完美的解决方案是利用三层结构模拟父子结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"outerBox tableCell"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ok"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"innerBox"</span>&gt;</span>tableCell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* table-cell实现居中 将父盒子设置为table-cell元素，设置 text-align:center,vertical-align: middle;</span></span><br><span class="line"><span class="comment">子盒子设置为inline-block元素 */</span></span><br><span class="line"><span class="selector-class">.tableCell</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tableCell</span> <span class="selector-class">.ok</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tableCell</span> <span class="selector-class">.innerBox</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案六"><a href="#方案六" class="headerlink" title="方案六"></a>方案六</h2><p>对子盒子实现绝对定位，利用 calc 计算位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"outerBox calc"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"innerBox"</span>&gt;</span>calc<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绝对定位，clac计算位置*/</span></span><br><span class="line"><span class="selector-class">.calc</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.calc</span> <span class="selector-class">.innerBox</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">left</span>: <span class="built_in">-webkit-calc</span>((<span class="number">500px</span> - <span class="number">200px</span>)/<span class="number">2</span>);</span><br><span class="line">   <span class="attribute">top</span>: <span class="built_in">-webkit-calc</span>((<span class="number">120px</span> - <span class="number">50px</span>)/<span class="number">2</span>);</span><br><span class="line">   <span class="attribute">left</span>: <span class="built_in">-moz-calc</span>((<span class="number">500px</span> - <span class="number">200px</span>)/<span class="number">2</span>);</span><br><span class="line">   <span class="attribute">top</span>: <span class="built_in">-moz-calc</span>((<span class="number">120px</span> - <span class="number">50px</span>)/<span class="number">2</span>);</span><br><span class="line">   <span class="attribute">left</span>: <span class="built_in">calc</span>((<span class="number">500px</span> - <span class="number">200px</span>) / <span class="number">2</span>);</span><br><span class="line">   <span class="attribute">top</span>: <span class="built_in">calc</span>((<span class="number">120px</span> - <span class="number">50px</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js版链表反转</title>
      <link href="/2020/01/16/js%E7%89%88%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
      <url>/2020/01/16/js%E7%89%88%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">data</span>: <span class="string">"a"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">data</span>: <span class="string">"b"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">data</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> d = &#123; <span class="attr">data</span>: <span class="string">"d"</span> &#125;;</span><br><span class="line">a.next = b;</span><br><span class="line">b.next = c;</span><br><span class="line">c.next = d;</span><br><span class="line">d.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移动元素法</span></span><br><span class="line"><span class="comment"> * 原理是把后面的元素一个一个换到第一个去</span></span><br><span class="line"><span class="comment"> * 比如原来是1-2-3-4</span></span><br><span class="line"><span class="comment"> * 第一次结果2-1-3-4</span></span><br><span class="line"><span class="comment"> * 第二次结果3-2-1-4</span></span><br><span class="line"><span class="comment"> * 第三次结果4-3-2-1</span></span><br><span class="line"><span class="comment"> * 每次都把后面的元素放到第一个。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 两点：</span></span><br><span class="line"><span class="comment"> * 在移动的时候，只要保证对象的链是对的就ok了</span></span><br><span class="line"><span class="comment"> * 但我们只关注开头的节点是谁，所以返回值一定要指向开头的那个对象。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;开头节点&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = head;</span><br><span class="line">  <span class="keyword">var</span> nextNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 存储下一个对象</span></span><br><span class="line">    nextNode = current.next;</span><br><span class="line">    <span class="comment">// 下面两步是保证链连接正确</span></span><br><span class="line">    current.next = nextNode.next;</span><br><span class="line">    nextNode.next = head;</span><br><span class="line">    <span class="comment">// 设置开头的对象</span></span><br><span class="line">    head = nextNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(reverse(a)));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React事件机制</title>
      <link href="/2020/01/09/React%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/09/React%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>React 事件系统在原生的 DOM 事件体系上做了一些优化，封装了一个“合成事件”层，事件处理程序通过合成事件进行实例传递。在 React 的事件系统中，没有把所有事件绑定到对应的真实 DOM 上，而是使用委托机制实现了一个统一的事件监听器，把所有的事件绑定到了最外层 document 上，然后再将事件进行分发。这样极大地减少了内存开销，使运行性能得到极大提升。</p><h2 id="如何提升性能"><a href="#如何提升性能" class="headerlink" title="如何提升性能"></a>如何提升性能</h2><p>1、减少事件组册，提高性能<br>2、新增子对象时，不用再次绑定事件</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react_ssr笔记</title>
      <link href="/2020/01/09/react-ssr%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/react-ssr%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="react-实现-ssr-和原理讲解"><a href="#react-实现-ssr-和原理讲解" class="headerlink" title="react 实现 ssr 和原理讲解"></a>react 实现 ssr 和原理讲解</h1><p>使用 react 实现 ssr，并讲解实现 ssr 的原理。</p><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>服务端渲染很简单，就是在服务端生成 html 代码字符串，然后返回给浏览器。<br>所以对前端来说就是一个请求。<br>本课程使用 express 启动服务。</p><a id="more"></a><h2 id="在服务端写-react-代码"><a href="#在服务端写-react-代码" class="headerlink" title="在服务端写 react 代码"></a>在服务端写 react 代码</h2><p>首先同样需要先安装 react 的包，babel 进行转义，不然因为写的是 node 代码，连 import 都不能直接使用，使用了 babel 这些，自然就需要使用 webpack 进行打包转义了。</p><blockquote><p><code>webpack</code>不仅可以打包前端代码，服务端代码也可以，只是在<code>webpack</code>的配置文件中，需要添加<code>target:&#39;node&#39;</code>，告诉 webpack 这是服务端代码，不然像<code>path</code>这样的工具包会被打包进代码中，在服务端<code>path</code>工具全局环境中的，是可以直接使用的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli react react-dom babel-loader babel-core babel-preset-react@latest babel-preset-stage-0 babel-preset-env --save</span><br></pre></td></tr></table></figure><p>babel 是个很好的转义工具，但是各种转义都需要安装对应的 preset，比如上面的 react，stage-0 语法等。</p><h3 id="webpack-node-externals"><a href="#webpack-node-externals" class="headerlink" title="webpack-node-externals"></a>webpack-node-externals</h3><p>虽然上面通过设置<code>target</code>可以避免 node 环境中已有包不会被打包到代码中，但是<code>node_modules</code>中安装的第三方包比如 <code>express</code> 还是被打包到引用它的文件中。这样会导致 express 被重复打包。<br>使用 webpack-node-externals 可以避免这种情况发生，这会保证各个文件中保持<code>require(&#39;express&#39;)</code>的写法。(有点像前端优化的动态链接库，自我感觉)</p><blockquote><p>️⚠️ 不做这个处理，打包会报警告！</p></blockquote><h3 id="使用-renderToString-服务端渲染-react-组件"><a href="#使用-renderToString-服务端渲染-react-组件" class="headerlink" title="使用 renderToString 服务端渲染 react 组件"></a>使用 renderToString 服务端渲染 react 组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">"react-dom/server"</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"./Home"</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="前端渲染-CSR-和服务端渲染-SSR-的优缺点"><a href="#前端渲染-CSR-和服务端渲染-SSR-的优缺点" class="headerlink" title="前端渲染(CSR)和服务端渲染(SSR)的优缺点"></a>前端渲染(CSR)和服务端渲染(SSR)的优缺点</h3><blockquote><p>SSR 有利于 SEO，但是对服务端性能消耗比较大。</p></blockquote><h3 id="webapck-server-js"><a href="#webapck-server-js" class="headerlink" title="webapck.server.js"></a>webapck.server.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">"webpack-node-externals"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  target: <span class="string">"node"</span>, <span class="comment">// 指定运行环境是服务端环境</span></span><br><span class="line">  mode: <span class="string">"development"</span>, <span class="comment">// 指定开发</span></span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"build"</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">        loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">        exclude: [<span class="string">"/node_modules/"</span>],</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 指定需要转义的内容，需要安装对应的babel插件。</span></span><br><span class="line">          presets: [</span><br><span class="line">            <span class="string">"react"</span>,</span><br><span class="line">            <span class="string">"stage-0"</span>,</span><br><span class="line">            <span class="comment">/* 如何根据环境进行适配 */</span></span><br><span class="line">            [</span><br><span class="line">              <span class="string">"env"</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                targets: &#123;</span><br><span class="line">                  browsers: [<span class="string">"last 2 versions"</span>], <span class="comment">// 在打包编译的过程中会去兼容所有浏览器的最后两个版本，当然可以设置3个版等等。</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="自动打包和服务自动启动"><a href="#自动打包和服务自动启动" class="headerlink" title="自动打包和服务自动启动"></a>自动打包和服务自动启动</h3><p>打包和启动是两个命令，前端由 webpack-dev-server 可以帮忙解决这个问题，但是服务端，目前还没有这样的工具，只能把代码用 webpack 打包，然后用 node 启动，命令如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node ./build/bundle.js",</span><br><span class="line">  "build": "webpack --config webpack.server.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>解决上面的问题也很简单，<code>webpack</code>自带了检测功能，增加<code>--watch</code>参数即可；<br><code>node</code>需要借助一个工具<code>nodemon</code>,<code>nodemon</code>启动的<code>node</code>服务可以自动检测启动文件所在目录是否发生变化，如果发生变化则自动重启服务。<br><code>nodemon</code>也可以设置监控多个文件夹。</p><blockquote><p><code>nodemon</code>还有一个同类工具叫<code>supervisor</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon -g</span><br></pre></td></tr></table></figure><p>修改后启动配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "nodemon --watch build ./build/bundle.js",</span><br><span class="line">  "build": "webpack --config webpack.server.js --watch"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="使用-npm-run-all-进一步提升开发效率"><a href="#使用-npm-run-all-进一步提升开发效率" class="headerlink" title="使用 npm-run-all 进一步提升开发效率"></a>使用 npm-run-all 进一步提升开发效率</h3><p>上面的配置虽然实现了自动打包，服务自动启动的功能，但是还是需要打开两个命令窗口，还是很麻烦。<br>使用 npm-run-all 就可以只打开一个窗口就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i npm-run-all -g</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "npm-run-all --parallel dev:**",</span><br><span class="line">  "dev:start": "nodemon --watch build ./build/bundle.js",</span><br><span class="line">  "dev:build": "webpack --config webpack.server.js --watch"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>parallel</code> 指定并行执行</li><li><code>dev:**</code>指定并行执行以”<code>dev:</code>“开头的所有 npm 命令</li></ul></blockquote><p>这样执行<code>npm run dev</code>两个服务就都启动了。</p><h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><p>服务端渲染时，如果在 react 组件上增加事件，当渲染到浏览器上时，事件是无法被绑定到组件上的。<br>这该怎么解决呢？这就需要使用<strong>同构</strong>。</p><blockquote><p>同构：就是一套 react 代码，在服务端执行一次，然后在客户端再执行一次。</p></blockquote><h3 id="让-react-组件在客户端再运行一次"><a href="#让-react-组件在客户端再运行一次" class="headerlink" title="让 react 组件在客户端再运行一次"></a>让 react 组件在客户端再运行一次</h3><p>这就比较简单了，这就是正常的前端 react 开发，把 react 组件和挂载打包后，在入口 html 引用就可以了。打包后的文件就是 js 吗，让打包的组件在客户端再挂载一次。<br>不同的是，这次挂载用的不是 ReactDom.render 而是 ReactDom.hydrate()方法。因为 react 组件已经被服务端渲染了一遍，做同构，就不要使用 render，而是使用 dydrate</p><blockquote><p>服务端渲染挂载组件两边不要有文本节点，也就是把 react 组件转换成字符串 A 后，传给 html 字符串 B 时，A 要和它的父元素在一行，不要有空格、换行，挨着写就行了。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"root"</span>&gt;$&#123;renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol><li>前端执行的 js 包入口</li></ol><p>// src/client/index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../Home"</span>;</span><br><span class="line"></span><br><span class="line">ReactDom.hydrate(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置 webpack 打包前端 js 包</li></ol><p>把<code>webpack.server.js</code>中<code>node</code>的相关配置删除即可。把<code>js文件</code>打包到<code>public</code>文件夹中。</p><ol start="3"><li>增加打包命令</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"dev:build:client": "webpack --config webpack.client.js --watch"</span><br></pre></td></tr></table></figure><ol start="4"><li>在首页 html 中引入 client 打包的静态 js</li></ol><p>使用<code>express</code>的<code>static</code>中间件，把<code>public</code>文件夹设置成静态资源请求目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定请求的静态资源都去public文件夹中获取</span></span><br><span class="line"><span class="comment"> * 并且不用写public路径，如下面的index</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">app.use(express.static(<span class="string">"public"</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;ssr&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;div id="root"&gt;<span class="subst">$&#123;renderToString(&lt;Home <span class="regexp">/&gt;)&#125;&lt;/</span>div&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">        &lt;<span class="regexp">/body&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">        &lt;script src="/i</span>ndex.js<span class="string">"&gt;&lt;/script&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;/html&gt;`);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;);</span></span></span></span><br></pre></td></tr></table></figure><p>经过上述的修改，按钮的事件就被绑定到元素上了，点击就有反应了。</p><blockquote><p>react 说白了就是 dom 操作，所以客户端再绑定一次，元素就被 dom 动态的又创建一次，事件什么的当然有了。</p></blockquote><h3 id="webpack-复用公共部分"><a href="#webpack-复用公共部分" class="headerlink" title="webpack 复用公共部分"></a>webpack 复用公共部分</h3><p>由于<code>webpack.server.js</code>和<code>webpack.client.js</code>大部分都相同，所以可以抽出公共部分，两个“继承”后各自扩展就行了；使用<code>webpack-merge</code>可以达到这个目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-merge</span><br></pre></td></tr></table></figure><h3 id="服务端路由"><a href="#服务端路由" class="headerlink" title="服务端路由"></a>服务端路由</h3><p>路由同样需要进行同构操作，但服务端路由不是使用<code>BrowserRouter</code>,而是需要使用<code>StaticRouter</code></p><p>首先安装 react 的 router 包<code>react-router-dom</code>，<code>BrowserRouter</code>和<code>StaticRouter</code>是这个包中的两个模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-router-dom --save</span><br></pre></td></tr></table></figure><h3 id="改造客户端和服务端使用路由进行渲染"><a href="#改造客户端和服务端使用路由进行渲染" class="headerlink" title="改造客户端和服务端使用路由进行渲染"></a>改造客户端和服务端使用路由进行渲染</h3><p>前端使用<code>BrowserRouter</code>进行路由,改造<code>client</code>中的<code>index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> Routes <span class="keyword">from</span> <span class="string">"../Routes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span>&#123;Routes&#125;<span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDom.hydrate(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>服务端代码改造</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"root"</span>&gt;</span><br><span class="line">  $</span><br><span class="line">  &#123;renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt;</span><br><span class="line">      &#123;Routes&#125;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;,</span></span><br><span class="line"><span class="regexp">  )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p><code>StaticRouter</code>和<code>BrowserRouter</code>不同，它不能自动感知 url 中的路由信息，所以需要设置<code>location</code>属性来告知服务端的 router 当前的路径是什么。</p><p><strong>多个路由时的处理</strong><br>因为 react 是单页面，所以服务端的路由需要都指定到入口文件上。比如增加了一个 login 页面，不能增加 get(/login)，把入口的路由改成全部(*)即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"*"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;ssr&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;hello,this is a ssr content.&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;h1&gt;下面是home组件的内容&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div id="root"&gt;<span class="subst">$&#123;renderToString(</span></span></span><br><span class="line"><span class="string"><span class="subst">              &lt;StaticRouter location=&#123;req.path&#125;</span> context=&#123;&#123;&#125;&#125;&gt;</span></span><br><span class="line"><span class="string">                &#123;Routes&#125;</span></span><br><span class="line"><span class="string">              &lt;/StaticRouter&gt;,</span></span><br><span class="line"><span class="string">            )&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;script src="/index.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="同构-redux"><a href="#同构-redux" class="headerlink" title="同构 redux"></a>同构 redux</h3><p>加上 redux 比较简单，和正常的开发一样就行。客户端和服务端同样都做相同处理，不然报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-redux redux redux-thunk</span><br></pre></td></tr></table></figure><p>相关代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = &#123; name: <span class="string">"温木"</span> &#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));</span><br><span class="line"></span><br><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">  &lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt;</span><br><span class="line">    &#123;Routes&#125;</span><br><span class="line">  &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Provider&gt;;</span><br></pre></td></tr></table></figure><h3 id="抽离公共store"><a href="#抽离公共store" class="headerlink" title="抽离公共store"></a>抽离公共<code>store</code></h3><p>由于服务端和客户端的 store 是一样的，因此可以把公共的部分抽成公共的模块， 但是需要注意的是，<code>createStore</code>应该每次调动时都生成新的 store，不然所有的服务就会调用的是同一个 store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = &#123; name: <span class="string">"温木"</span> &#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, applyMiddleware(thunk));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是错误代码，下面的写法会让所有的服务共用一个store</span></span><br><span class="line"><span class="comment">// const store = createStore(reducer, applyMiddleware(thunk));</span></span><br><span class="line"><span class="comment">// export default store;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Warning: Expected server HTML to contain a matching &lt;div&gt; in &lt;div&gt;.</code><br>引起这种 bug 我遇到有两种：</p><ol><li>只在客户端渲染使用了路由，服务端渲染没有使用，服务端加上即可</li><li>服务端在渲染是多嵌套了 div，比如我遇到的就是把 html 字符串封装成了方法 render，但是原来的 html 字符串忘记删除，在 html 字符串中又调用了 render，所以导致了这个警告。</li></ol></blockquote><h3 id="服务端渲染时加载-store-数据"><a href="#服务端渲染时加载-store-数据" class="headerlink" title="服务端渲染时加载 store 数据"></a>服务端渲染时加载 store 数据</h3><p>通常情况下，我们请求数据都在<code>componentDidMount</code>声明周期中进行，但是声明周期函数<code>componentDidMount</code>(<code>useEffect</code>也一样)在服务端渲染时是不执行的，只有在客户端渲染时才会触发。因此<code>React</code>为服务端渲染提供了专门的数据加载方法。</p><p><a href="https://reacttraining.com/react-router/web/guides/server-rendering" target="_blank" rel="noopener">详情参考<code>react router</code>的<code>Server Rendering</code>的<code>Data Loading</code>部分</a></p><ol><li>首先每个组件需要增加一个静态的<code>loadData</code>函数，用于服务端渲染时获取组件的异步数据</li><li>给路由增加<code>loadData</code>属性，官网推荐用一个数组 map 输出</li><li>服务端渲染时，绑定 store 之前，使用<code>matchPath</code>向 store 中填充数据，不过 matchPath 只能匹配一层路由，多级路由需要使用<code>react-router-config</code>的<code>matchRoutes</code>,</li><li>由于获取数据是异步，所以需要数据请求结束后借助<code>Promise.all</code>的回调返回<code>html</code>字符串（注意:<code>action</code>和<code>loadData</code>中要把<code>promise</code>对象透传出去，把<code>promise</code>对象<code>return</code>出去）</li></ol><blockquote><p>node 不能使用 fetch<br>fetch 在 node 中不能使用，所以有服务端渲染时最好使用<code>axios</code>发请求。<br><strong>切记<code>loadData</code>要把结果<code>return</code></strong></p></blockquote><h3 id="同构存在的问题！！！"><a href="#同构存在的问题！！！" class="headerlink" title="同构存在的问题！！！"></a>同构存在的问题！！！</h3><p>由于同构服务端渲染一遍，客户端又渲染了一遍，那就有一个问题了，当服务端把数据已经渲染了，异步数据也拿到了，由于客户端还会再执行一遍，那数据还会再执行并渲染一般，那前端由的延迟不是还是能感觉到吗，这不是脱裤放屁了，当禁用掉<code>js</code>,由于前端<code>js</code>无法执行。渲染异步请求的数据的部分会是空白；（当然 SEO 不影响，因为数据确实已经在页面了）</p><p><strong>如何解决这个问题呢？</strong><br>这需要用到数据的注水和脱水。</p><blockquote><p>说白了就是当服务端已经拿到的<code>state</code>数据放到<code>window</code>的全局变量里面，当前端再创建<code>store</code>的时候，取出来全局中存储的<code>state</code>数据传给<code>store</code>当做默认值，这就没抖动了。<br>都是笨方法新概念，听着挺高大上</p></blockquote><p>创建 store 时候，服务端和客户端分开使用两个方法就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, applyMiddleware(thunk));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脱水</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getClientStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultState = <span class="built_in">window</span>.context.state;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, defaultState, applyMiddleware(thunk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那客户端不发出请求不行了吗？<br>不行，因为服务端渲染只是渲染首屏 A，当手动输入页面路径首先访问 B 时，再回到 A 这是就无法获取 A 的数据了，所以客户端的请求不能省略；为了避免客户端重复发出请求，可以加个判断，有数据就不请求。</p><h3 id="让客户端的请求都通过node中间件"><a href="#让客户端的请求都通过node中间件" class="headerlink" title="让客户端的请求都通过node中间件"></a>让客户端的请求都通过<code>node</code>中间件</h3><p>到目前为止，<code>action</code>发出的请求是直接访问服务器的，既然搭建了 node 中间件，所有的请求应该都通过中间件发出去，客户端不应该直接和服务端进行交互。<br>实现也简单，因为现在有了 node 服务，如果发出的请求是相对路径，那么都会被 node 服务接收，我们只要制定好规则，把获取数据的请求都转到数据服务器就行了，说白了就是加个代理。<br>代理需要用到<code>express-http-proxy</code>,通过这个插件可以轻松的把请求代理到指定的服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express-http-proxy</span><br></pre></td></tr></table></figure><p>我这里做的约定是，所有数据的请求都以<code>/api</code>开头。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置代理，代理只能处理客户端发出的请求，服务端的请求不走这块，需要额外处理</span></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">"/api"</span>,</span><br><span class="line">  proxy(<span class="string">"https://www.easy-mock.com"</span>, &#123;</span><br><span class="line">    https: <span class="literal">true</span>,</span><br><span class="line">    proxyReqPathResolver: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`/mock/5d7073309fb10a1868876f68/react_ssr/api<span class="subst">$&#123;req.url&#125;</span>`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>⚠️ 服务端渲染的时候有问题。</p><blockquote><p>比如我当时报错信息是：Error: connect ECONNREFUSED 127.0.0.1:80</p></blockquote><p>因为<code>action</code>中的请求链接现在写的相对路径(比如:<code>/api/list.json</code>)，当浏览器发出请求的时候，浏览器会想网站挂载的服务器发出请求，也就是使用网站的域名和端口。<br>但是服务端在发出请求的时候，由于这本身就在服务端，所以对服务器来说，这是请求根目录下的<code>api</code>目录下<code>list.json</code>文件，由于根目录下没有这个文件，所以就报错了，请求接口同样的道理。<br>要解决这个问题也很简单，就是大家都能想到的最笨的方法。<br>做个判断处理，服务端发起的请求就把请求路径写成数据服务器的绝对路径，比如：<code>https://www.baidu.com/data/api/list.json</code>,如果是客户端发起的请求就写相对路径<code>/api/list.json</code>;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">`/api/list`</span>;</span><br><span class="line"><span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">  url = <span class="string">"https://www.easy-mock.com/mock/5d7073309fb10a1868876f68/react_ssr/api/list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做很丑陋，如果这样处理，首屏上用到的异步数据 action 都要这么处理，太 low 了。使用<code>axios</code>的<code>instance</code>可以改善这个问题(其实差别不大,还是需要判断)。</p><p>原理就是创建两个<code>axios</code>的实例，一个客户端的，一个服务端的，把上面的 url 换成两个实例就行了。<code>axios</code>的实例可以指定发出请求的前缀内容，所以方法中的<code>url</code>可以写成相对路径，拼接工作嫁给了<code>axios</code>的实例来完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">"/"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">"https://www.easy-mock.com/mock/5d7073309fb10a1868876f68/react_ssr"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">let</span> request = isServer ? ServerAxios : ClientAxios;</span><br><span class="line">request.get(<span class="string">"/api/list"</span>);</span><br></pre></td></tr></table></figure><p><strong>不使用判断更优雅的解决</strong><br>由于客户端渲染和服务端渲染分别使用各自的<code>stroe</code>，因此可以在创建<code>store</code>的时候，绑定<code>axios</code>的实例，这样就不用传参判断是否是客户端还是服务端请求了。<br>给<code>store</code>绑定<code>axios</code>实例，需要用到<code>redux-thunk</code>的<code>withExtraArgument</code>方法，这个方法允许给<code>thunk</code>传递一个参数，这个参数在异步调用的时候可以使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store绑定axios实例</span></span><br><span class="line"><span class="keyword">import</span> ClientAxios <span class="keyword">from</span> <span class="string">"../client/request"</span>;</span><br><span class="line"><span class="keyword">import</span> ServerAxios <span class="keyword">from</span> <span class="string">"../server/request"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, applyMiddleware(thunk.withExtraArgument(ClientAxios)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getClientStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultState = <span class="built_in">window</span>.context.state;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, defaultState, applyMiddleware(thunk.withExtraArgument(ServerAxios)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action中调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchHomeList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第三个参数就是绑定的axios实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState, axiosInstance</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> axiosInstance.get(<span class="string">"/api/list"</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data &#125; = response;</span><br><span class="line">      dispatch(setHome(data.data));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有没有想过为什么客户端和服务端渲染不用同一个 store 呢？，这样还不用注水和脱水呢！<br>因为客户端和服务端运行环境不同，一个运行客户端也就是浏览器中，一个运行在 node 环境中，变量怎么可能共享呢，哈哈 😀</p></blockquote><h3 id="node代理时没有携带解决cookie问题"><a href="#node代理时没有携带解决cookie问题" class="headerlink" title="node代理时没有携带解决cookie问题"></a><code>node</code>代理时没有携带解决<code>cookie</code>问题</h3><p>服务端代理请求时，携带上客户单请求上的<code>cookie</code>就行了;更新创建<code>axios</code>实例的地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> req =&gt;</span><br><span class="line">  axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">"https://www.easy-mock.com/mock/5d7073309fb10a1868876f68/react_ssr"</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      cookie: req.get(<span class="string">"cookie"</span>) || <span class="string">""</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="共用部分实现，比如Header"><a href="#共用部分实现，比如Header" class="headerlink" title="共用部分实现，比如Header"></a>共用部分实现，比如<code>Header</code></h3><p>项目中总会有很多页面的共用部分，比如<code>header</code>,<code>footer</code>等等，这些如何像使用模板那样在一个地方写，而不需要在每个页面中都写一遍呢？<br>使用<code>router</code><strong>多级路由</strong>就可以轻松解决这个问题。</p><ol><li>写一个共用组件,如<code>App.js</code>，组件中放入公共部分，比如<code>Header</code>、<code>Footer</code>、<code>Menu</code>等等。</li><li>在<code>App.js</code>中增加各个组件的路由,但是为了能显示多级路由的内容，需要用到<code>react-router-config</code>的<code>renderRoutes</code></li><li>把<code>App</code>组件作为路由对象的根对象，子集路由就是要在内容区域显示的各个子组件了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/"</span>,</span><br><span class="line">    component: App,</span><br><span class="line">    key: <span class="string">"app"</span>,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">"/"</span>,</span><br><span class="line">        component: Home,</span><br><span class="line">        loadData: Home.loadData,</span><br><span class="line">        exact: <span class="literal">true</span>,</span><br><span class="line">        key: <span class="string">"home"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">"/login"</span>,</span><br><span class="line">        component: Login,</span><br><span class="line">        exact: <span class="literal">true</span>,</span><br><span class="line">        key: <span class="string">"login"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 服务端渲染注册路由的地方</span></span><br><span class="line">&lt;StaticRouter location=&#123;req.path&#125; context=&#123;&#123;&#125;&#125;&gt;</span><br><span class="line">  &lt;div&gt;&#123;renderRoutes(routes)&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>StaticRouter&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示路由的地方,App组件</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">"./Routes"</span>;</span><br><span class="line"><span class="comment">//....省略部分</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &#123;renderRoutes(routes[<span class="number">0</span>].routes)&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 客户端注册路由的地方</span></span><br><span class="line"><span class="regexp">&lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;renderRoutes(routes)&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/BrowserRouter&gt;;</span></span><br></pre></td></tr></table></figure><p>由于一级路由渲染完组件后，路由会把路由对象的信息传递给组件，因此 App 公共组件不需要专门引入定义的 routes，在 props 中可以直接获取到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = memo(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &#123;renderRoutes(props.route.routes)&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><h3 id="通过axios给请求添加公共参数"><a href="#通过axios给请求添加公共参数" class="headerlink" title="通过axios给请求添加公共参数"></a>通过<code>axios</code>给请求添加公共参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">"/"</span>,</span><br><span class="line">  params: &#123; <span class="attr">secret</span>: <span class="string">"abc"</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> req =&gt;</span><br><span class="line">  axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">"https://www.fastmock.site/mock/0564485c18844ec86d683c16b922e8ab/ssr"</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      cookie: req.get(<span class="string">"cookie"</span>) || <span class="string">"cookie"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    params: &#123; <span class="attr">secret</span>: <span class="string">"abc"</span> &#125;,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h3><p>当访问的路由不存在时，我们需要显示<code>404</code>页面，这实现其实很简单。<br>写一个 404 的页面，然后在配置路由的地方配置下就行，但是配置只需要一个<code>component</code>属性即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">"/"</span>,</span><br><span class="line">  component: App,</span><br><span class="line">  loadData: App.loadData,</span><br><span class="line">  key: <span class="string">"app"</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      component: NotFound,   <span class="comment">// 这行就是404页面</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>当访问路由中没有的路由时，会自动跳转到 404 页面。</p><h3 id="借助router的context来返回-404-状态码"><a href="#借助router的context来返回-404-状态码" class="headerlink" title="借助router的context来返回 404 状态码"></a>借助<code>router</code>的<code>context</code>来返回 404 状态码</h3><p>上面的 404 页面配置完后，虽然其作用了，但是 http 状态码是 200，为了更真实的显示，我们应该让找不到路由时 http 的状态码是<code>404</code></p><p>给<code>StaticRouter</code>组件传递<code>context</code>属性，当返回 html 字符串时判断 context 对象是否被标记访问的是 404 页面，比如添加了 notFound 属性，如果是，则设置状态码为 404</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用于404页面时增加标记用</span></span><br><span class="line">  <span class="keyword">const</span> context = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> html = render(req, store, routes, context);</span><br><span class="line">  <span class="keyword">if</span> (context.noFound) &#123;</span><br><span class="line">    res.status(<span class="number">404</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  res.send(html);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h3><p>前面我们已经做了，当退出登录时，使用<code>Redirect</code>调回到首页的功能，但是<code>Redirect</code>仅限于前端重定向，不能做服务端重定向；<br>在非登录状态下，如果我们直接手动访问其他页面，其实服务端是已经访问了的，只是客户端帮我们跳转到了首页。</p><p>服务端该如何重定向呢？<br>这仍需要借助<code>router</code>的<code>context</code>对象，当我们有重定向时，<code>context</code>会被填充一些属性，通过打印 context 对象，可以发现，填充的属性有：</p><ul><li><code>action</code> 字符串，描述操作类型，重定向就是<code>REPLACE</code></li><li><code>location</code> 一个对象，描述重定向前的数据</li><li><code>url</code> 字符串，描述重定向后的<code>url</code></li></ul><p>所以在服务端渲染时，可以像处理 404 时那样，判断 context 中的 action，如果是<code>REPLACE</code>则跳转到<code>url</code>指定的路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context.action === <span class="string">"REPLACE"</span>) &#123;</span><br><span class="line">  res.redirect(<span class="number">301</span>, context.url);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.noFound) &#123;</span><br><span class="line">  res.status(<span class="number">404</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决请求失败的问题"><a href="#解决请求失败的问题" class="headerlink" title="解决请求失败的问题"></a>解决请求失败的问题</h3><p>在循环组件并加载数据的地方再嵌套一层 promise,无论组件中加载数据的部分是成功还是失败都把结果传递下去，这样只有失败的组件不显示，成功的组件仍显示。<br>并且当有多个请求时，如果第一个失败了，后面的数据还没返回也不影响，因为 <code>catch</code> 也让触发的 <code>resolve</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">matchedRoutes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.route.loadData) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      item.route</span><br><span class="line">        .loadData(store)</span><br><span class="line">        .then(resolve)</span><br><span class="line">        .catch(resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">    promises.push(promise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="服务端渲染css配置"><a href="#服务端渲染css配置" class="headerlink" title="服务端渲染css配置"></a>服务端渲染<code>css</code>配置</h3><p>服务端渲染<code>css</code>需要使用到<code>isomorphic-style-loader</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install isomorphic-style-loader --save-dev</span><br></pre></td></tr></table></figure><p>然后把<code>style-loader</code>改成<code>isomorphic-style-loader</code>。</p><p>配置完后，下面的处理就和 404 页面的处理类似，当是服务端渲染时，就把<code>css</code>字符串添加到<code>router</code>的<code>context</code>对象中，然后在服务端渲染那块，从<code>context</code>中拿出<code>css</code>字符串，拼接到<code>head</code>中即可。<br>如果获取<code>css</code>字符串呢？<br>首先把 <code>css</code> 引入方式配置成模块引入的方式。<code>isomorphic-style-loader</code>提供了<code>_getCss()</code>的方法可以获取到 <code>css</code> 字符串。<br>这样禁用掉 <code>js</code> 后，样式仍能直接有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是服务端渲染</span></span><br><span class="line"><span class="keyword">if</span> (staticContext) &#123;</span><br><span class="line">  staticContext.css = styles._getCss();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有很多问题：</p><ol><li>因为需要在每个组件中把<code>css</code>添加到<code>context</code>对象中，所以 css 会被后面的覆盖</li><li>不在路由中的组件没有<code>context</code>属性</li></ol><p>解答：</p><ol><li>css 属性用数组类型</li><li>手动把<code>context</code>对象传递过去。因为<code>App</code>组件是在路由中的，所以可以在<code>App</code>中把<code>conterxt</code>传递给<code>header</code>组件中</li></ol><h3 id="使用高阶组件解决需要在每个组件中添加css字符串的问题"><a href="#使用高阶组件解决需要在每个组件中添加css字符串的问题" class="headerlink" title="使用高阶组件解决需要在每个组件中添加css字符串的问题"></a>使用高阶组件解决需要在每个组件中添加<code>css</code>字符串的问题</h3><p>在每个组件中都需要把 css 字符串添加到 context 对象中很麻烦，可以写一个高阶组件，来解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (DecoratedComponent, styles) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">newComponent</span> <span class="keyword">extends</span> <span class="title">React</span>() </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; staticContext &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">if</span> (staticContext) &#123;</span><br><span class="line">        staticContext.css.push(styles._getCss());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">DecoratedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>title 和 Description 主要是为了提高网站的点击率，对<code>SEO</code>意义不大。</p><h3 id="使用react-helmet定制-title-和-Description"><a href="#使用react-helmet定制-title-和-Description" class="headerlink" title="使用react-helmet定制 title 和 Description"></a>使用<code>react-helmet</code>定制 title 和 Description</h3><p><code>react-helmet</code>不仅可以帮助动态生成<code>title</code>和<code>description</code>,并且可以在服务端渲染时引用，让服务端渲染也是动态生成<code>title</code>和<code>description</code>。<br>在每个组件中使用<code>helmet</code>，则当路由到这个组件时，<code>title</code> 和 <code>description</code> 就自动发生了变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到客户端渲染定义的helmet</span></span><br><span class="line"><span class="keyword">const</span> helmet = Helmet.renderStatic();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在html字符串中使用</span></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;helmet.title.toString()&#125;</span></span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;helmet.meta.toString()&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">        `</span>;</span><br></pre></td></tr></table></figure><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>当对首屏时间要求不高，但是对 SEO 要求较高时，可以使用预渲染方案来解决这个问题。<br>预渲染就是当访问的是人时，就是正常的客户端渲染，但当访问的是爬虫蜘蛛时，则走预渲染服务器，预渲染服务器去取项目的页面，把页面的<code>dom</code>结构生成后再返回给蜘蛛。<br>预渲染服务器是如何获取页面的 dom 结构呢？<br>其实就是把页面上生成的 html 获取过来，就像我们使用开发者工具查看 html 结构一样，预渲染服务器就是拿的这个 html 字符串。</p><h3 id="搭建预渲染服务器"><a href="#搭建预渲染服务器" class="headerlink" title="搭建预渲染服务器"></a>搭建预渲染服务器</h3><p>预渲染需要预渲染服务，蜘蛛访问的是预渲染服务器，不是我们直接的网站页面。<br>预渲染服务器需要用到<code>prerender</code>，这个插件可以帮助我们轻松搭建预渲染服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install prerender</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prerender = <span class="built_in">require</span>(<span class="string">"prerender"</span>);</span><br><span class="line"><span class="keyword">const</span> server = prerender(&#123; <span class="attr">port</span>: <span class="number">3200</span> &#125;);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure><p>访问预渲染服务器的时候需要通过以下方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3200/render?url=https://www.example.com/</span><br></pre></td></tr></table></figure><p>请求参数<code>url</code>的内容就是要抓取的页面。</p><h3 id="PreRender-原理"><a href="#PreRender-原理" class="headerlink" title="PreRender 原理"></a>PreRender 原理</h3><p>当访问预渲染服务器时，预渲染服务器会创建一个小浏览器，然后在这个小浏览器中访问 url 指定的页面，然后再在这个小浏览器中拿到<code>html</code>的内容，拿到后关掉这个小浏览器，把内容返回给蜘蛛。<br>由于这个过程，耗时可能比较长，但是蜘蛛只关心内容，不太关心响应时间，所以问题不大。</p><blockquote><p>预渲染参考网站 <a href="https://prerender.io/" target="_blank" rel="noopener">https://prerender.io/</a><br>这个网站详细讲解了预渲染原理和使用方式，并提供了便捷的的使用接口。</p></blockquote><h3 id="如何判断是否是蜘蛛在访问"><a href="#如何判断是否是蜘蛛在访问" class="headerlink" title="如何判断是否是蜘蛛在访问"></a>如何判断是否是蜘蛛在访问</h3><p>可以通过 nigix 进行判断，然后根据结果路由到不同的服务器上，如果是机器蜘蛛则路由到预渲染服务器，如果是客户在访问则路由到网站服务器</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth认证</title>
      <link href="/2020/01/09/OAuth%E8%AE%A4%E8%AF%81/"/>
      <url>/2020/01/09/OAuth%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>OAuth 认证方式有多种，但常用的有两种</p><ul><li>Password</li><li>Authorize Code</li></ul><h3 id="Password-方式"><a href="#Password-方式" class="headerlink" title="Password 方式"></a>Password 方式</h3><p>这种方式比较简单，就是把用户名和密码传递给认证平台，认证平台返回 token。<br>比如我们使用<code>github</code>，把在<code>github</code>上注册的用户名密码传给<code>github</code>，<code>github</code>认证后返回<code>token</code>。<br>但这有个很明显的弊端：就是当前系统可以知道你在 github 上的账号密码，比较不安全。</p><h3 id="Authorize-Code"><a href="#Authorize-Code" class="headerlink" title="Authorize Code"></a>Authorize Code</h3><p>这种方式和<code>Password</code>方式最大的区别就是，这个登录是在认证平台(<code>github</code>)提供的登录页面，也就是在<code>github</code>的网站进行登录和验证，验证通过后返回一个<code>code</code>,然后系统拿着这个<code>code</code>再去认证平台获取<code>token</code>。</p><p>这种方式比较安全，当前网站无法接触到你在认证平台上的任何信息。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中this的指向问题</title>
      <link href="/2020/01/09/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/09/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>js 方法中的 this 是指向调用它的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="number">20</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); <span class="comment">//20</span></span><br><span class="line">(foo.bar1 = foo.bar)(); <span class="comment">//10</span></span><br><span class="line">(foo.bar1, foo.bar)(); <span class="comment">//10</span></span><br><span class="line">foo.bar1(); <span class="comment">//20</span></span><br><span class="line">(foo.bar)(); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>第一个很好理解，调用 bar()是 foo 对象，所以是 foo；</p><p>第二个需要了解赋值的<strong>副作用</strong>：<code>赋值表达式会返回等号右边的值！</code><br>所以在执行这表达式时，读取了 foo.bar 的值并返回了，返的是 bar 函数的一个引用，然后再进行了执行； 这时执行时是处于 window 的上下文，所以它的 this 指向 window。</p><p>第三个是逗号的<strong>副作用</strong>：<code>返回最后一个表达式的值</code>；所以上下文和第二个一样，都指向了 window。</p><p>第四个没什么好说的，调用的就是 foo 对象，指向当然也是它。</p><p>第五个的结果和第一个一样，并且编辑器也会格式化成第一个的形式，说明这种形式是相等的。<br>也许你会想，这个不是一个表达式吗？<br>既然是表达式，为什么 2 和 3 的上下文都丢失了，为什么 5 的不丢失？<br>第一，因为括号没有副作用。<br>第二，点号运算符的作用就是在当前对象上调用方法，必须直接使用 <code>a.b()</code>或 <code>a[&quot;b&quot;]()</code> 的形式才能在当前对象上调用方法，其他形式仅仅是调用方法/函数。（这里不考虑 bind、call、apply 这些）</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字体大小pt、px、em、rem的区别</title>
      <link href="/2020/01/09/%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8Fpt%E3%80%81px%E3%80%81em%E3%80%81rem%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/09/%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8Fpt%E3%80%81px%E3%80%81em%E3%80%81rem%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>这里向大家描述一下<a href="http://developer.51cto.com/art/201008/220838.htm" target="_blank" rel="noopener">CSS</a>中 px 和 em 的特点和区别，px 像素（Pixel），相对长度单位，像素 px 是相对于显示器屏幕分辨率而言的，而 em 是相对长度单位，相对于当前对象内文本的字体尺寸，相信本文介绍一定会让你有所收获。</p><a id="more"></a><h4 id="详解-px-和-em-的特点和区别"><a href="#详解-px-和-em-的特点和区别" class="headerlink" title="详解 px 和 em 的特点和区别"></a>详解 px 和 em 的特点和区别</h4><p>象素 px 是我们在定义 CSS 中经常用到的尺寸大小单位，而 em 在国外网站中经常被使用，px 和 em 之间究竟有什么区别和特点呢？</p><ul><li>px 像素（Pixel），相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。</li><li>em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>因此用 px 来定义字体，就无法用浏览器字体放大的功能。<br>任意浏览器的默认字体高都是 16px。所有未经调整的浏览器都符合:1em=16px。那么 12px=0.75em,10px=0.625em。为了简化 font-size 的换算，需要在 css 中的 body 选择器中声明 Font-size=62.5%，这就使 em 值变为 16px*62.5%=10px,这样 12px=1.2em,10px=1em,也就是说只需要将你的原来的 px 数值除以 10，然后换上 em 作为单位就行了。</li></ul><h4 id="CSS-中-em-属性有如下特点"><a href="#CSS-中-em-属性有如下特点" class="headerlink" title="CSS 中 em 属性有如下特点"></a>CSS 中 em 属性有如下特点</h4><ul><li>em 的值并不是固定的；</li><li>em 会继承父级元素的字体大小。</li></ul><h4 id="所以我们在写-CSS-的时候，需要注意"><a href="#所以我们在写-CSS-的时候，需要注意" class="headerlink" title="所以我们在写 CSS 的时候，需要注意"></a>所以我们在写 CSS 的时候，需要注意</h4><ul><li>body 选择器中声明 Font-size=62.5%；</li><li>将你的原来的 px 数值除以 10，然后换上 em 作为单位；</li><li>重新计算那些被放大的字体的 em 数值。避免字体大小的重复声明。<br>也就是避免 1.2*1.2=1.44 的现象。<br>比如说你在#content 中声明了字体大小为 1.2em，那么在声明 p 的字体大小时就只能是 1em，而不是 1.2em,因为此 em 非彼 em，它因继承#content 的字体高而变为了 1em=12px。<br>但是 12px 汉字例外，就是由以上方法得到的 12px(1.2em)大小的汉字在 IE 中并不等于直接用 12px 定义的字体大小，而是稍大一点。这个问题 Jorux 已经解决，只需在 body 选择器中把 62.5%换成 63%就能正常显示了。原因可能是 IE 处理汉字时，对于浮点的取值精确度有限。不知道有没有其他的解释。</li></ul><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>em 是相对长度单位，相对于当前对象内文本的字体尺寸，即 em 的计算是基于父级元素 font-size 的。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:14px"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size:2em"</span>&gt;</span>我这里的字体显示大小是28px(14px*2)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size:18px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size:2em"</span>&gt;</span>我这里显示字体大小是36px(18px*2),而不是上面计算的28px<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>rem 是 css3 新增的一个相对单位，与 em 的区别在于，它是相对于 html 根元素的(在 body 标签里面设置字体大小不起作用)。还是上面那个例子，如果换做 rem，结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:14px"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size:2rem"</span>&gt;</span></span><br><span class="line">    我这里的字体显示大小是32px(16px*2),因为我是根据html根元素的font-size大小进行计算的</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size:18px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size:2rem"</span>&gt;</span></span><br><span class="line">      我这里显示字体大小是32px(16px*2),因为我是根据html根元素的font-size大小进行计算的</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>** <code>补充默认font-size大小是16px(如果html中没有设置的话)。</code>**</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css优先级-权重值</title>
      <link href="/2020/01/09/css%E4%BC%98%E5%85%88%E7%BA%A7-%E6%9D%83%E9%87%8D%E5%80%BC/"/>
      <url>/2020/01/09/css%E4%BC%98%E5%85%88%E7%BA%A7-%E6%9D%83%E9%87%8D%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS-的权重值"><a href="#CSS-的权重值" class="headerlink" title="CSS 的权重值"></a>CSS 的权重值</h3><p><img src="http://upload-images.jianshu.io/upload_images/1348523-5ffba205f8782ccd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="权重值列表"> ###位置优先级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt; （外部样式）External style sheet</span><br></pre></td></tr></table></figure><p>当 html 元素的 class 在调用样式时，权重值越大优先级越高，尤其是一个 class 有多个类时，和 class 名的调用顺序无关。下面的调用结果是一样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 前后端漏洞分析与防御技巧--笔记</title>
      <link href="/2020/01/09/Web-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/Web-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>代替 node，启动的服务，如果修改后会自动编译启动，无需每次手动启动。</p><h3 id="jspm"><a href="#jspm" class="headerlink" title="jspm"></a>jspm</h3><p>前端包管理工具，npm 是 node 的包管理工具，服务端的。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>全称是：<code>Cross Site Scripting</code>,(跨站脚本攻击），为什么不叫 CSS，因为 CSS 是样式的缩写，<code>cross</code>在英文中通常也被缩写为<code>X</code>，所以这里直接把 cross 缩写成 X。<br>简单理解就是：通常情况下，你希望你网站中运行的逻辑都是来自本站，是你自己的东西才能在你网站中运行。但是如果运行了不是本站的脚本就发生了跨站脚本攻击。这里是<code>脚本</code>，不是请求。<br>//通常发给你服务器的请求是来自你自己的网站，但是 xss 就是发给你服务的请求，不是从你自己的网站，请求是从其他的网站发过来的。</p><h3 id="url-参数注入"><a href="#url-参数注入" class="headerlink" title="url 参数注入"></a>url 参数注入</h3><ol><li>如果 url 中的参数在网页中直接当做变量来显示，则可以被脚本攻击。如果参数的值中包含脚本，则在显示变量值时，传入的脚本则会被执行，引起 XSS。<br>如下代码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://test.com?name=zhangsan&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//下面使用hmtl模板或jsx语法为例</span><br><span class="line">&lt;div&gt;访问的本站是&#123;name&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述代码则会运行传入的脚本。</p><ol start="2"><li>还可以直接链接到其他网站的 js 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://test.com?name=zhangsan&lt;script src=<span class="string">'http://code.jquery.com/jquery-2.1.1.min.js'</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面的请求发出后，参数中的 jquery 链接文件就会被下载并执行。可以在网络请求中看到下载的链接。<br>如果上面的链接换成了恶意写好的代码，比如获取你的用户名和密码，发送违规请求等，那危害就大了。</p><h3 id="脚本攻击能干什么"><a href="#脚本攻击能干什么" class="headerlink" title="脚本攻击能干什么"></a>脚本攻击能干什么</h3><ol><li>获取页面数据</li><li>获取 Cookies</li><li>劫持前端逻辑</li><li>发送请求</li><li>偷取网站任意数据</li><li>偷取用户资料</li><li>偷取用户名和登录状态</li><li>欺骗用户</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>反射类：url 参数直接注入</li><li>存储类：存储到 DB 后读取时注入</li></ul><h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>反射类上面已经举例说明了，下面看看存储类。<br>比如我们在评论里面写入脚本，评论被显示时脚本就会被执行。</p><h3 id="XSS-注入点"><a href="#XSS-注入点" class="headerlink" title="XSS 注入点"></a>XSS 注入点</h3><ol><li>HTML 节点，比如上面传的参数直接在页面中显示和在评论区中输入脚本</li><li>HMTL 属性，比如有些 html 的属性是动态输入的。比如根据输入的地址显示对应的图片。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"#&#123;imgPath&#125;"</span> /&gt;</span><br><span class="line">如果输入的是<span class="string">`1" onerror="alert(1)"`</span>,则会变成下面的内容</span><br><span class="line">&lt;img src=<span class="string">"1"</span> onerror=<span class="string">"alert(1)"</span> /&gt;</span><br></pre></td></tr></table></figure><p>当然 src 还可以是一个 js 文件链接。</p><ol start="3"><li>JavaScript 代码，比如上面的评论中直接写脚本。</li><li>富文本<br>富文本就是在文本框中输入脚本或恶意链接。</li></ol><h3 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h3><ol><li><p>浏览器自带防御<br>服务端在返回时，可以设置请求头部：<code>X-XSS-Protection</code>,默认是开启的，开启后，上面 url 中注入的脚本就会被认出，请求就会被拦截。<br>这个只能防御有限，只能防止反射性的注入。 如果传的参数没有带<script>标签，直接写脚本内容则不会被识别出来。</p></li><li><p>内容进行转义<br>把一些特殊字符转换成 html 字符实体</p><blockquote><p>比如把<code>&lt;</code> 转换成 <code>&amp;lt;</code> , <code>&gt;</code> 转换成 <code>&amp;gt;</code><br>双引号<code>&quot;</code>转换成<code>&amp;quto;</code><br>单引号<br>空格<br>JavaScript 代码的话，可以转换成 json 字符串或把双引号、斜杠等等都给转义了。<br>富文本的话，可以把相关的字符也进行转换或设置白名单来避免攻击</p></blockquote></li></ol><p>设置 CSP<br>在响应头部设置 CSP 参数。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>Cross Site Request Forgy,跨站请求伪造。</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>原理其实很简单，其实就是利用了 cookie 会被请求自动带上的规则发起的攻击。<br>比如你登录了 A，这些你的敏感信息都在 cookie 中存储。这时你访问了一个攻击 A 网站的 B 网站，B 网站向 A 网站发送请求（比如超链接的 href 直接就是一个请求地址），请求会自动带上 A 网站的 cookie 信息。<br>因为验证信息在 cookie 中，所以 A 网站的服务端就验证通过了。</p><h3 id="疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？"><a href="#疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？" class="headerlink" title="疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？"></a>疑问：现在浏览器有同源策略，这个问题是不是不用考虑了？</h3><p>答案是：NO，同源策略虽然能限制 cookie 被非同一网站使用，但是也并不是所有的都遵循同源策略。</p><p>同源策略限制范围：</p><blockquote><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送。</p></blockquote><p>不遵循同源策略的标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  &lt;img&gt;  &lt;iframe&gt;中的src，</span><br><span class="line">还有超链接a的href都可以任意链接网络资源，相当于对所要求的源进行了一次请求。</span><br></pre></td></tr></table></figure><p>实例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://code.jquery.com/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"#btnCSRF"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          $.<span class="keyword">get</span>("http://localhost:3001/setVal");</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;3002&lt;/h1&gt;</span><br><span class="line">    &lt;a href="http://localhost:3001/setVal"&gt;百元大奖&lt;/a&gt;</span><br><span class="line">    &lt;input id="btnCSRF" type="button" value="点击中大奖" /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure><p>用户 node 起了两个服务，端口分别是 3001 和 3002，上面的是 3002 的页面代码；<br>当点击超链接“百元大奖”时，3001 服务端是能获取到请求传过来的 cookie，说明 cookie 被自动带上了。<br>当点击按钮“点击中大奖”发出 ajax 请求时，没有报错，但是确实没有 cookie，验证了上述说明是正确的。</p><h3 id="防御-CSRF"><a href="#防御-CSRF" class="headerlink" title="防御 CSRF"></a>防御 CSRF</h3><ol><li>设置 sameSite,禁止其他网站携带 cookie<blockquote><p>测试没起作用，我的网站只是端口不同，都是在 localhost 下测试，不知道是不是这个原因</p></blockquote></li><li>在页面中使用验证码或 token，验证码裤 ccap</li><li>referer 判断请求来源，但 referer 中可以通过参数来模拟关键字<br><a href="http://www.baidu.com/name?pp=&quot;www.test.com&quot;" target="_blank" rel="noopener">http://www.baidu.com/name?pp=&quot;www.test.com&quot;</a> ###防止 cookie 泄露信息 ###签名<br>所谓签名就是把信息加密</li></ol><h3 id="httponly"><a href="#httponly" class="headerlink" title="httponly"></a>httponly</h3><p>禁止 js 读取 cookie</p><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>现象就是你点击某个按钮时，并没有发生想象的结果。而是触发了不可想象的事件。<br>原理就是网页使用一个 iframe 嵌套一个的其他的网页，并把 iframe 隐藏，iframe 页面中的按钮正好和你看到页面上的引诱按钮重合，其实你看到的引诱按钮只是一个背景图片，当点击引诱按钮时，iframe 页面中的按钮就被触发了，这就是点击劫持的原理。</p><h3 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h3><p>点击劫持其实就是网页被 iframe 内嵌了，如果禁止内嵌就不会发生点击劫持。<br>方法：</p><blockquote><p>1.javascript 禁止内嵌<br>默认情况下 top==window,当页面被内嵌后，top!==window,并且他们的 location 也是不相等的，因此可以用 location 来判断页面是否被内嵌。<br>但是 js 如果被禁用了，这方法就没用了。<br>2.X-FRAME-OPTIONS 禁止内嵌<br>在 response 的 header 中进行设置。<br>// ALLOWORIGIN 相同域名可以内嵌，ALLOW-FROM 指定网站可以内嵌<br>res.set({"X-Frame-Options ","DENY"}) 3.其他辅助手段</p></blockquote><h3 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h3><h3 id="anyproxy-工具"><a href="#anyproxy-工具" class="headerlink" title="anyproxy 工具"></a>anyproxy 工具</h3><h3 id="SwitchyOmega-插件"><a href="#SwitchyOmega-插件" class="headerlink" title="SwitchyOmega 插件"></a>SwitchyOmega 插件</h3><p><a href="https://www.css88.com/archives/7628" target="_blank" rel="noopener">https://www.css88.com/archives/7628</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装forever和pm2失败解决方法</title>
      <link href="/2020/01/09/Centos7%E5%AE%89%E8%A3%85forever%E5%92%8Cpm2%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/09/Centos7%E5%AE%89%E8%A3%85forever%E5%92%8Cpm2%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在安装往 forever 或者 pm2 后，提示找不到对应的命令</p><p><img src="https://upload-images.jianshu.io/upload_images/1348523-7806c64db5dead9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>解决很简单，把安装时上面的地址 link 到下面的路径即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/node/bin/forever /usr/<span class="built_in">local</span>/bin/forever</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/node/bin/pm2 /usr/<span class="built_in">local</span>/bin/pm2</span><br></pre></td></tr></table></figure><p>注意：forever 和 pm2 别写错了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Peer-to-Peer笔记</title>
      <link href="/2020/01/09/Peer-to-Peer%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/Peer-to-Peer%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-NAT"><a href="#什么是-NAT" class="headerlink" title="什么是 NAT"></a>什么是 NAT</h3><p>NAT（Network Address Translation，网络地址转换），简单说，就是把局域网中的机器和外部进行通信时，映射公网 IP 和端口的过程。<br>比如你在局域网中的地址是 192.168.1.100，你的公网地址是 119.125.123.12，当你和异地的朋友通信时，你发出的信息是通过你的公网地址发出去的，为了区分是局域网中的哪个机器，通常会分配一个端口，比如你发出的信息时，给你分配的公网地址和端口是：119.125.123.12:8223，那么当互联网上的任何人往上面地址发送信息，都会发到你机器上（前提是没设置通信限制，下面有讲解，这里说的是完全锥形 NAT）</p><a id="more"></a><h3 id="NAT-的分类"><a href="#NAT-的分类" class="headerlink" title="NAT 的分类"></a>NAT 的分类</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-3743e41de25d9991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>电信级的网关都是“对称 NAT”，比如移动、连通、电信</p><h3 id="对称-NAT"><a href="#对称-NAT" class="headerlink" title="对称 NAT"></a>对称 NAT</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-d1680bcfd70082ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>简单说就是客户机向每个服务器发送信息，都会有一个新的公网端口，比如你向两个服务器通信，你和第一个服务器通信时给你分配的公网地址和端口是：119.125.123.12:8223，和第二个通信时分配的是 119.125.123.12:8224，只要公网 IP 一样，端口不一样，这就是对称 NAT。</p><h3 id="完全锥形-NAT"><a href="#完全锥形-NAT" class="headerlink" title="完全锥形 NAT"></a>完全锥形 NAT</h3><p>这就简单了，就是都能通过给你分配的公网 IP 和端口和你通信。加上限制就是限制锥形 NAT</p><h3 id="判断顺序"><a href="#判断顺序" class="headerlink" title="判断顺序"></a>判断顺序</h3><ol><li>先判断是不是 完全锥形 NAT</li><li>再判断是不是 IP 限制锥形 NAT</li></ol>]]></content>
      
      
      <categories>
          
          <category> P2P </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P2P </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中变量和函数的声明提前</title>
      <link href="/2020/01/09/JavaScript%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/"/>
      <url>/2020/01/09/JavaScript%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 这个弱类型语言现在越来越火，我也很喜欢这个语言，因为弱姿态，反而更灵活，现在已经成为全栈型开发语言。<br>在学习 JavaScript 时，有很多细节性东西，也就是坑，一不留意就会掉下去，其中一个就是<strong>声明提前</strong></p><h3 id="1-声明提前的顺序优先级"><a href="#1-声明提前的顺序优先级" class="headerlink" title="1. 声明提前的顺序优先级"></a>1. 声明提前的顺序优先级</h3><blockquote><ol><li>函数参数</li><li>var 声明的变量</li><li>函数定义</li></ol></blockquote><p>也就是说：一个作用域中有多种声明，那么就按照上面的优先级来进行提前，<strong>先把所有的函数参数进行提前，完了再提前 var 变量，然后才是函数声明</strong>。在这里，把函数参数和 var 声明的变量统称为<strong>属性</strong>，大家也许会认为不管谁先吧，知道提前就行，在正常开发中确实是不太需要关注这个。但如果面试时，可能就需要明白这个的重要性了。因为面试时遇到的题是，在一个作用域中，这几个声明都有，但是他们的名字一样，哈哈，无语了吧。</p><p>下面马上就介绍这种情况的规则</p><h3 id="2-名称相同时，保留优先级"><a href="#2-名称相同时，保留优先级" class="headerlink" title="2. 名称相同时，保留优先级"></a>2. 名称相同时，保留优先级</h3><blockquote><ol><li>如果属性相同，则以第一个为准</li><li>如果有与函数名同名的变量,则会被此函数覆盖</li><li>JavaScript 作用域会先在自己的 AO 上找,找不到就到父函数的 AO 上找,再找不到再找上一层的 AO,直到找到 window.</li></ol></blockquote><hr><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>try-catch 是同步的，只能获取同步的异常，若果 try 代码块中是异步操作，异步的回调函数或事件中的错误是获取不到的，如果需要获取回调函数的错误，就得在回调函数中再写一个 trycatch</p><blockquote><p>参考链接：<a href="http://www.jianshu.com/p/43bf4f2e0d57#" target="_blank" rel="noopener">http://www.jianshu.com/p/43bf4f2e0d57#</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>byte[]和string及16进制的转换</title>
      <link href="/2020/01/09/byte-%E5%92%8Cstring%E5%8F%8A16%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/01/09/byte-%E5%92%8Cstring%E5%8F%8A16%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转换成byte[]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToByte</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">var</span> len, c;</span><br><span class="line">  len = str.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    c = str.charCodeAt(i);</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="number">0x010000</span> &amp;&amp; c &lt;= <span class="number">0x10ffff</span>) &#123;</span><br><span class="line">      bytes.push(((c &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x07</span>) | <span class="number">0xf0</span>);</span><br><span class="line">      bytes.push(((c &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>) | <span class="number">0x80</span>);</span><br><span class="line">      bytes.push(((c &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>) | <span class="number">0x80</span>);</span><br><span class="line">      bytes.push((c &amp; <span class="number">0x3f</span>) | <span class="number">0x80</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="number">0x000800</span> &amp;&amp; c &lt;= <span class="number">0x00ffff</span>) &#123;</span><br><span class="line">      bytes.push(((c &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0f</span>) | <span class="number">0xe0</span>);</span><br><span class="line">      bytes.push(((c &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>) | <span class="number">0x80</span>);</span><br><span class="line">      bytes.push((c &amp; <span class="number">0x3f</span>) | <span class="number">0x80</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="number">0x000080</span> &amp;&amp; c &lt;= <span class="number">0x0007ff</span>) &#123;</span><br><span class="line">      bytes.push(((c &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x1f</span>) | <span class="number">0xc0</span>);</span><br><span class="line">      bytes.push((c &amp; <span class="number">0x3f</span>) | <span class="number">0x80</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bytes.push(c &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// byte[]转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byteToString</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arr === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">""</span>,</span><br><span class="line">    _arr = arr;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; _arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> one = _arr[i].toString(<span class="number">2</span>),</span><br><span class="line">      v = one.match(<span class="regexp">/^1+?(?=0)/</span>);</span><br><span class="line">    <span class="keyword">if</span> (v &amp;&amp; one.length == <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> bytesLength = v[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">var</span> store = _arr[i].toString(<span class="number">2</span>).slice(<span class="number">7</span> - bytesLength);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> st = <span class="number">1</span>; st &lt; bytesLength; st++) &#123;</span><br><span class="line">        store += _arr[st + i].toString(<span class="number">2</span>).slice(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      str += <span class="built_in">String</span>.fromCharCode(<span class="built_in">parseInt</span>(store, <span class="number">2</span>));</span><br><span class="line">      i += bytesLength - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      str += <span class="built_in">String</span>.fromCharCode(_arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十六进制字符串转字节数组，跟网上demo一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HexString2Bytes</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> len = str.length;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  len /= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> arrBytes = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> s = str.substr(pos, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> v = <span class="built_in">parseInt</span>(s, <span class="number">16</span>);</span><br><span class="line">    arrBytes.push(v);</span><br><span class="line">    pos += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节数组转十六进制字符串，对负值填坑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bytes2HexString</span>(<span class="params">arrBytes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrBytes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp;</span><br><span class="line">    <span class="keyword">var</span> num = arrBytes[i];</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//此处填坑，当byte因为符合位导致数值为负时候，需要对数据进行处理</span></span><br><span class="line">      tmp = (<span class="number">255</span> + num + <span class="number">1</span>).toString(<span class="number">16</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp = num.toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp.length == <span class="number">1</span>) &#123;</span><br><span class="line">      tmp = <span class="string">"0"</span> + tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    str += tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> byte </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>create-react-app添加mocker和代理功能</title>
      <link href="/2020/01/09/create-react-app%E6%B7%BB%E5%8A%A0mocker%E5%92%8C%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD/"/>
      <url>/2020/01/09/create-react-app%E6%B7%BB%E5%8A%A0mocker%E5%92%8C%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>本文讲解如何给使用 create-react-app 创建的项目添加 mocker 的功能，和设置添加 proxy 同服务端进行联调。 ###创建项目<br>使用官网方式创建项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><a id="more"></a><p>弹出配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><h3 id="添加-mocker-功能"><a href="#添加-mocker-功能" class="headerlink" title="添加 mocker 功能"></a>添加 mocker 功能</h3><p><a href="https://www.npmjs.com/package/mocker-api" target="_blank" rel="noopener">mocker-api 的 npm 地址</a></p><p><code>mocker-api</code>是用来启动一个 mocker 服务的插件，使用 mocker-api 可以通过多种方式启动一个 mocker 服务，比如可以像<code>serve</code>插件一样，直接把指定文件启动成一个 mocker 服务,如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mocker <span class="string">'./mocker.js'</span></span><br></pre></td></tr></table></figure><p>当然也可以在<code>webpack</code>中进行配置，通过<code>webapck</code>进行调用。<br>在<code>webpack</code>的<code>devserver</code>的<code>before</code>函数中进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mocker-api --save-dev</span><br></pre></td></tr></table></figure><p>打开<code>config/webpackDevServer.config.js</code>文件<br>按照官网上的添加就行，关键代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> apiMocker = <span class="built_in">require</span>(<span class="string">'mocker-api'</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">before(app,server)&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">apiMocker(app, path.resolve(<span class="string">"./mocker/index.js"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二个参数一定要定位到一个文件，不能指定一个文件夹。</p></blockquote><h3 id="设置-proxy"><a href="#设置-proxy" class="headerlink" title="设置 proxy"></a>设置 proxy</h3><p>上面的 code 省去了<code>mocker-api</code>的<code>proxy</code>的配置，经过测试，在<code>mocker-api</code>中设置 proxy 没有作用。下面是官网的 demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 官网code</span><br><span class="line">+ devServer: &#123;</span><br><span class="line">+   ...</span><br><span class="line">+   before(app)&#123;</span><br><span class="line">+     apiMocker(app, path.resolve(<span class="string">'./mocker/index.js'</span>), &#123;</span><br><span class="line">+       proxy: &#123;</span><br><span class="line">+         <span class="string">'/repos/*'</span>: <span class="string">'https://api.github.com/'</span>,</span><br><span class="line">+         <span class="string">'/:owner/:repo/raw/:ref/*'</span>: <span class="string">'http://127.0.0.1:2018'</span></span><br><span class="line">+       &#125;,</span><br><span class="line">+       changeHost: <span class="literal">true</span>,</span><br><span class="line">+     &#125;)</span><br><span class="line">+   &#125;</span><br><span class="line">+ &#125;,</span><br></pre></td></tr></table></figure><p>如果需要开启 proxy，需要设置<code>devServer</code>的<code>proxy</code>属性，但是<code>create-react-app</code>对 proxy 进行了封装，它读取的是 package.json 文件中 proxy 的配置，可查看<code>scripts/start.js</code>中对 proxy 设置的相关代码：</p><p>scripts/start.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load proxy config</span></span><br><span class="line"><span class="keyword">const</span> proxySetting = <span class="built_in">require</span>(paths.appPackageJson).proxy;</span><br><span class="line"><span class="keyword">const</span> proxyConfig = prepareProxy(proxySetting, paths.appPublic);</span><br><span class="line"><span class="comment">// Serve webpack assets generated by the compiler over a web server.</span></span><br><span class="line"><span class="keyword">const</span> serverConfig = createDevServerConfig(proxyConfig, urls.lanUrlForConfig);</span><br><span class="line"><span class="keyword">const</span> devServer = <span class="keyword">new</span> WebpackDevServer(compiler, serverConfig);</span><br></pre></td></tr></table></figure><p><code>paths.appPackageJson</code>就是<code>package.json</code>文件，然后读取<code>proxy</code>属性。</p><h3 id="proxy-的值"><a href="#proxy-的值" class="headerlink" title="proxy 的值"></a>proxy 的值</h3><p>在 package.json 如下设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"proxy"</span>: <span class="string">"http://target_ip:port/"</span></span><br><span class="line">例如：</span><br><span class="line"><span class="string">"proxy"</span>: <span class="string">"http://www.baidu.com/"</span></span><br></pre></td></tr></table></figure><h3 id="和服务端联调"><a href="#和服务端联调" class="headerlink" title="和服务端联调"></a>和服务端联调</h3><p>其实 devServer 的 proxy 和 mocker-api 是没关系的，无论 mocker-api 是否存在，只要 devServer 设置了 proxy，就能直接和服务端联调了。</p><h3 id="设置了-mocker-api-的情况下如何与服务端联调呢？"><a href="#设置了-mocker-api-的情况下如何与服务端联调呢？" class="headerlink" title="设置了 mocker-api 的情况下如何与服务端联调呢？"></a>设置了 mocker-api 的情况下如何与服务端联调呢？</h3><p>看官方的 demo，mocker 中根据环境变量 NO_PROXY 是“启动”mocker，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> noProxy = process.env.NO_PROXY === <span class="string">"true"</span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = noProxy ? &#123;&#125; : delay(proxy, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>因此可以通过设置 NO_PROXY“禁用 mocker”，而通过 proxy 和服务端进行联调。如何做呢，很简单，增加一个 npm scripts 命令，看代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start:no-mock"</span>: <span class="string">"NO_PROXY=true node scripts/start.js"</span>,</span><br></pre></td></tr></table></figure><p>是的，仔细的同学应该看到了，就是<strong>复制</strong>了一份<code>start</code>的命令，只是增加了上了环境变量的设置。</p><p>如何测试呢？</p><blockquote><p>我就是使用 mocker 另外启了一个服务，通过 mocker-api 把项目中编写好的 mocker 文件启动了起来。<br><code>mocker ./mocker/index.js</code><br>这个服务的端口和 react 项目的端口肯定不一样，可以进行测试。</p></blockquote><h3 id="上面的“启动”和“禁用”为什么要加引号呢？"><a href="#上面的“启动”和“禁用”为什么要加引号呢？" class="headerlink" title="上面的“启动”和“禁用”为什么要加引号呢？"></a>上面的“启动”和“禁用”为什么要加引号呢？</h3><blockquote><p>因为只要在<code>devServer</code>的<code>before函数</code>中配置了<code>mocker-api</code>，其实<code>mocker</code>服务就启用了，只不过如果<code>mocker</code>文件返回一个空对象，那请求在<code>mocker服务</code>中肯定匹配不到合适的<code>url</code>，然后就走<code>proxy</code>进行请求，而不是<code>mocker服务</code>没启动。</p></blockquote><p>2019 年 05 月 24 日</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现tab标签下选中条滑动效果-react组件</title>
      <link href="/2020/01/09/%E5%AE%9E%E7%8E%B0tab%E6%A0%87%E7%AD%BE%E4%B8%8B%E9%80%89%E4%B8%AD%E6%9D%A1%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C-react%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/01/09/%E5%AE%9E%E7%8E%B0tab%E6%A0%87%E7%AD%BE%E4%B8%8B%E9%80%89%E4%B8%AD%E6%9D%A1%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C-react%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>这个是模仿 ant design 的 Tabs 控件，当切换 tab 时，下面的蓝色条滑过的效果。<br><a href="https://ant.design/components/tabs-cn/#header" target="_blank" rel="noopener">点击查看效果</a><br>我只是封装了 tab 的头部标签，并没有包含内容部分。<br>我的最终结果<br><img src="https://upload-images.jianshu.io/upload_images/1348523-da2570428517b560.gif?imageMogr2/auto-orient/strip" alt="head.gif"></p><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" target="_blank" rel="noopener">transform</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">transition</a></li></ul><a id="more"></a><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p><code>transform</code>属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改 CSS 视觉格式化模型的坐标空间来实现的。<br>通过看 ant design 的代码，他使用的是<code>translate3d</code>平移函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: translate3d(<span class="number">100</span>px, <span class="number">0</span>px, <span class="number">0</span>px);</span><br></pre></td></tr></table></figure><h3 id="translate3d-函数"><a href="#translate3d-函数" class="headerlink" title="translate3d 函数"></a>translate3d 函数</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-function" target="_blank" rel="noopener">translate3d()</a> 这个 CSS 函数用于移动元素在 3D 空间中的位置。 这种变换的特点是三维矢量的坐标定义了它在每个方向上的移动量。</p><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate3d(tx, ty, tz);</span><br></pre></td></tr></table></figure><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><code>transition</code>控制滑动速度及滑动时间等。不用这个属性，效果没那么自然。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">官方解释：</a></p><blockquote><p><strong><code>transition</code></strong><a href="https://developer.mozilla.org/en/CSS" target="_blank" rel="noopener" title="CSS">CSS</a>属性是一个<a href="https://developer.mozilla.org/en-US/docs/CSS/Shorthand_properties" target="_blank" rel="noopener" title="/en-US/docs/CSS/Shorthand_properties">简写属性</a>，用于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property" target="_blank" rel="noopener" title="transition-property 指定应用过渡属性的名称。"><code>transition-property</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-duration" target="_blank" rel="noopener" title="transition-duration 属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s ，表示不出现过渡动画。"><code>transition-duration</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function" target="_blank" rel="noopener" title="CSS属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。"><code>transition-timing-function</code></a>  和  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay" target="_blank" rel="noopener" title="CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。"><code>transition-delay</code></a>。</p></blockquote><blockquote><p>上面就是实现需要用到的比较不常见的技术，所以专门列举出来。</p></blockquote><h3 id="布局分析"><a href="#布局分析" class="headerlink" title="布局分析"></a>布局分析</h3><ol><li><p>首先一个外层的 div 当做容器<code>headerContainer</code></p></li><li><p>里面分为上下两部分，上面就是包含各个“标签”的容器<code>header</code>，下面是滑动条<code>tab_bar</code></p><blockquote><p>注意：滑动条是一个专门的 div 来实现，并不是“标签”容器的下边框</p></blockquote></li><li><p>标签容器里面放各个“标签”元素</p></li></ol><p>代码布局如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"headerContainer"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"header"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"headItem"</span>&gt;tab <span class="number">1</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="headItemChecked"&gt;tab 2&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="tab_bar"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong><br><code>headerContainer</code>目前没有需要的 css，由于我是用 less 写的，只是用它当做一个容器来用。<br><code>header</code>和<code>headItemChecked</code>设置标签的排列方式、字体等样式<br><code>tab_bar</code>的 css 样式是关键，它设置<code>选中条</code>的样式，值得注意的是，它需要和标签的状态和宽度保持一致。</p><h3 id="如何和标签状态保持一致"><a href="#如何和标签状态保持一致" class="headerlink" title="如何和标签状态保持一致"></a>如何和标签状态保持一致</h3><p>当选中一个标签时，“选中条”需要滑动到对应的标签下面。<br>这个通过设置“选中条”的平移位置来实现，这个可以设置<code>translate3d</code>的参数来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate3d($&#123;checkedPosition&#125;px, <span class="number">0</span>px, <span class="number">0</span>px)</span><br></pre></td></tr></table></figure><p>当点击标签时，动态设置<code>checkedPosition</code>的值即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onClickHeader = <span class="function">(<span class="params">checkedHead, index</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123; checkedHead, <span class="attr">checkedPosition</span>: index * <span class="number">100</span> &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>但是这时虽然能滑过去，但是没有那种平滑的滑动效果，实现这个效果就需要<code>transition</code>来实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.645</span>, 0<span class="selector-class">.045</span>, 0<span class="selector-class">.355</span>, 1),</span><br><span class="line">        <span class="selector-tag">width</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.645</span>, 0<span class="selector-class">.045</span>, 0<span class="selector-class">.355</span>, 1),</span><br><span class="line">        <span class="selector-tag">left</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.645</span>, 0<span class="selector-class">.045</span>, 0<span class="selector-class">.355</span>, 1),</span><br><span class="line">        <span class="selector-tag">-webkit-transform</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.645</span>, 0<span class="selector-class">.045</span>, 0<span class="selector-class">.355</span>, 1);</span><br></pre></td></tr></table></figure><blockquote><p>这个和 ant design 的参数保持一致</p></blockquote><p>但是每个标签的内容导致宽度是不一样的，所以不能乘以换一个固定的值(100)来计算每次平移的位置，需要每个标签的实际宽度来决定平移的位置。</p><h3 id="计算每个标签的宽度"><a href="#计算每个标签的宽度" class="headerlink" title="计算每个标签的宽度"></a>计算每个标签的宽度</h3><p>这个就用到了<code>react</code>不推荐使用的<code>ref</code>属性了。这里推荐使用回调函数的方式，不然 eslint 会警告你 ⚠️，当然你没用 eslint 就无所谓了。<br>通过 ref 来获取元素的宽度，然后计算<code>容器的宽度</code>、<code>选中条的宽度和位置</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div</span><br><span class="line">    ref=&#123;r =&gt; &#123;</span><br><span class="line">                  <span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index&#125;</span>`</span>] = r;</span><br><span class="line">           &#125;&#125;</span><br><span class="line">   key=&#123;item.code&#125;</span><br><span class="line">....省略部分</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算宽度</span></span><br><span class="line">onClickHeader = <span class="function">(<span class="params">checkedHead, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> preWidth = index &gt; <span class="number">0</span> ? <span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index - <span class="number">1</span>&#125;</span>`</span>].offsetWidth : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> barWidth = <span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index&#125;</span>`</span>].offsetWidth;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; checkedHead, <span class="attr">checkedPosition</span>: index * preWidth, barWidth &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解决-offsetWidth-四舍五入的问题"><a href="#解决-offsetWidth-四舍五入的问题" class="headerlink" title="解决 offsetWidth 四舍五入的问题"></a>解决 offsetWidth 四舍五入的问题</h3><p>offsetWidth 虽然能获取元素的宽度，但是在使用过程中发现，它返回的都是整数，进行了<code>四舍五入</code>的情况，当宽度遇到小于 0.5 的情况，就会引起<code>内容换行</code>了，很不美观，所以不能使用 offsetWidth.</p><p><strong>解决方法如下：</strong></p><ol><li>Element.getBoundingClientRect()<blockquote><p>Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index&#125;</span>`</span>].getBoundingClientRect().width; <span class="comment">//192.243</span></span><br></pre></td></tr></table></figure><p>返回的是包含小数的数字，比如 192.243</p><ol start="2"><li>Window.getComputedStyle()<blockquote><p>Window.getComputedStyle()方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有 CSS 属性的值。 私有的 CSS 属性值可以通过对象提供的 API 或通过简单地使用 CSS 属性名称进行索引来访问。</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getComputedStyle(<span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index&#125;</span>`</span>], <span class="literal">null</span>).getPropertyValue(<span class="string">"width"</span>); <span class="comment">//192.243px</span></span><br></pre></td></tr></table></figure><p>返回的是带单位(px)的值，比如 192.243px。</p><blockquote><p>由于涉及到计算，我上面使用了第一种解决方法。 ###完整 code<br>index.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">"./index.less"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TabHeader</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">const</span> &#123; defaultHead &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      containerWidth: <span class="number">1500</span>,</span><br><span class="line">      checkedPosition: <span class="number">0</span>,</span><br><span class="line">      barWidth: <span class="number">70</span>,</span><br><span class="line">      checkedHead: defaultHead,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; heardList &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">let</span> containerWidth = <span class="number">0</span>;</span><br><span class="line">    (heardList || []).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      containerWidth += <span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index&#125;</span>`</span>].getBoundingClientRect().width;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">barWidth</span>: <span class="keyword">this</span>.ref_0.getBoundingClientRect().width, containerWidth &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClickHeader = <span class="function">(<span class="params">checkedHead, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> preWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; i += <span class="number">1</span>) &#123;</span><br><span class="line">      preWidth += <span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;i&#125;</span>`</span>].offsetWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> barWidth = <span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index&#125;</span>`</span>].offsetWidth;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; checkedHead, <span class="attr">checkedPosition</span>: preWidth, barWidth &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; checkedHead, checkedPosition, containerWidth, barWidth &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> &#123; heardList, source &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.container&#125; style=&#123;&#123; <span class="attr">width</span>: <span class="string">`<span class="subst">$&#123;containerWidth&#125;</span>px`</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;div className=&#123;styles.headerContainer&#125;&gt;</span><br><span class="line">          &lt;div className=&#123;styles.header&#125;&gt;</span><br><span class="line">            &#123;heardList.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">              &lt;div</span><br><span class="line">                ref=&#123;r =&gt; &#123;</span><br><span class="line">                  <span class="keyword">this</span>[<span class="string">`ref_<span class="subst">$&#123;index&#125;</span>`</span>] = r;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">                key=&#123;item.code&#125;</span><br><span class="line">                className=&#123;checkedHead === item.code ? styles.headItemChecked : styles.headItem&#125;</span><br><span class="line">                onClick=&#123;<span class="keyword">this</span>.onClickHeader.bind(<span class="keyword">this</span>, item.code, index)&#125;</span><br><span class="line">              &gt;</span><br><span class="line">                &#123;item.text&#125; &#123;item.num&#125;</span><br><span class="line">              &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            ))&#125;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">          &lt;div</span><br><span class="line">            className=&#123;styles.tab_bar&#125;</span><br><span class="line">            style=&#123;&#123;</span><br><span class="line">              transform: <span class="string">`translate3d(<span class="subst">$&#123;checkedPosition&#125;</span>px, 0px, 0px)`</span>,</span><br><span class="line">              width: <span class="string">`<span class="subst">$&#123;barWidth&#125;</span>px`</span>,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className=&#123;styles.list&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;source.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;div key=&#123;item.id&#125; className=&#123;styles.row&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div className=&#123;styles.name&#125;&gt;&#123;item.name&#125;&lt;/</span>div&gt;</span><br><span class="line">                &lt;div className=&#123;styles.phone&#125;&gt;&#123;item.phone&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">              &lt;div className=&#123;styles.count&#125;&gt;</span><br><span class="line">                &lt;span className=&#123;styles.doing&#125;&gt;&#123;item.doing&#125;&lt;<span class="regexp">/span&gt; /</span></span><br><span class="line">                &lt;span className=&#123;styles.error&#125;&gt; &#123;item.error&#125;&lt;<span class="regexp">/span&gt; /</span></span><br><span class="line">                &lt;span className=&#123;styles.all&#125;&gt; &#123;item.all&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>index.less</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"></span><br><span class="line">  .headerContainer &#123;</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.header</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: flex;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"></span><br><span class="line">      .headItem &#123;</span><br><span class="line">        <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">font-size</span>: 14<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">font-family</span>: <span class="selector-tag">PingFangSC-Regular</span>;</span><br><span class="line">        <span class="selector-tag">font-weight</span>: 400;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(51, 51, 51, 1);</span><br><span class="line">        <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line">        <span class="selector-tag">padding</span>: 12<span class="selector-tag">px</span> 17<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">cursor</span>: <span class="selector-tag">pointer</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: 4<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">rgba</span>(232, 232, 232, 1);</span><br><span class="line">        <span class="selector-tag">transition</span>: <span class="selector-tag">border</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.645</span>, 0<span class="selector-class">.045</span>, 0<span class="selector-class">.355</span>, 1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.headItemChecked</span> &#123;</span><br><span class="line">        .headItem;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(0, 155, 255, 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.tab_bar</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="number">#1890ff</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">4px</span>;</span><br><span class="line">      <span class="attribute">transition</span>: transform <span class="number">0.3s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.645</span>, <span class="number">0.045</span>, <span class="number">0.355</span>, <span class="number">1</span>), width <span class="number">0.3s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.645</span>, <span class="number">0.045</span>, <span class="number">0.355</span>, <span class="number">1</span>),</span><br><span class="line">        left <span class="number">0.3s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.645</span>, <span class="number">0.045</span>, <span class="number">0.355</span>, <span class="number">1</span>), -webkit-transform <span class="number">0.3s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.645</span>, <span class="number">0.045</span>, <span class="number">0.355</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.list</span> &#123;</span><br><span class="line">    .row &#123;</span><br><span class="line">      <span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line">      <span class="selector-tag">justify-content</span>: <span class="selector-tag">space-between</span>;</span><br><span class="line">      <span class="selector-tag">padding</span>: 14<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 8<span class="selector-tag">px</span>;</span><br><span class="line">      <span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br><span class="line">      <span class="selector-tag">font-family</span>: <span class="selector-tag">PingFangSC-Regular</span>;</span><br><span class="line">      <span class="selector-tag">font-weight</span>: 400;</span><br><span class="line">      <span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(102, 102, 102, 1);</span><br><span class="line">      <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">rgba</span>(232, 232, 232, 1);</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.name</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">        <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">51</span>, <span class="number">51</span>, <span class="number">51</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.phone</span> &#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.count</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">        <span class="attribute">font-family</span>: PingFangSC-Semibold;</span><br><span class="line">        <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">        .doing &#123;</span><br><span class="line">          <span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(24, 137, 250, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-class">.error</span> &#123;</span><br><span class="line">          <span class="attribute">color</span>: <span class="number">#eb9e08</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-class">.all</span> &#123;</span><br><span class="line">          <span class="attribute">color</span>: <span class="number">#5f636b</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用-demo"><a href="#调用-demo" class="headerlink" title="调用 demo"></a>调用 demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabHeader</span><br><span class="line">  defaultHead=<span class="string">"abc"</span></span><br><span class="line">  heardList=&#123;[</span><br><span class="line">    &#123; <span class="attr">code</span>: <span class="string">"abc"</span>, <span class="attr">text</span>: <span class="string">"较长的名字数量"</span>, <span class="attr">num</span>: <span class="string">"10"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">code</span>: <span class="string">"abcd"</span>, <span class="attr">text</span>: <span class="string">"男人"</span>, <span class="attr">num</span>: <span class="string">"101"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">code</span>: <span class="string">"abce"</span>, <span class="attr">text</span>: <span class="string">"美女数"</span>, <span class="attr">num</span>: <span class="string">"121"</span> &#125;,</span><br><span class="line">  ]&#125;</span><br><span class="line">  source=&#123;[</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="string">"12121"</span>,</span><br><span class="line">      name: <span class="string">"刘医生"</span>,</span><br><span class="line">      phone: <span class="string">"16807656551"</span>,</span><br><span class="line">      doing: <span class="string">"10"</span>,</span><br><span class="line">      error: <span class="string">"212"</span>,</span><br><span class="line">      all: <span class="string">"32"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="string">"1211"</span>,</span><br><span class="line">      name: <span class="string">"张无忌"</span>,</span><br><span class="line">      phone: <span class="string">"16807656551"</span>,</span><br><span class="line">      doing: <span class="string">"10"</span>,</span><br><span class="line">      error: <span class="string">"22"</span>,</span><br><span class="line">      all: <span class="string">"322"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> components </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger UI各参数讲解</title>
      <link href="/2020/01/09/Swagger-UI%E5%90%84%E5%8F%82%E6%95%B0%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/01/09/Swagger-UI%E5%90%84%E5%8F%82%E6%95%B0%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img2.ph.126.net/_SX8su5HOXBkjMO0opT0nQ==/6632198063655900158.png" alt="参数注释1"></p><h3 id="parameters-的属性"><a href="#parameters-的属性" class="headerlink" title="parameters 的属性"></a>parameters 的属性</h3><ul><li>in 定义参数类型，是在 body 中还是 url 中，可选值：body，path，query，formdata</li><li>description</li><li>required 是否为必须参数</li><li>type 参数的数据类型</li><li>format 定义具体的数据类型</li><li>default <strong>设置参数默认值</strong></li><li>item 当 type 是“array”时有用</li></ul><a id="more"></a><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">"array"</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">"string"</span></span><br><span class="line">  <span class="attr">enum:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"available"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"pending"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"sold"</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">"available"</span></span><br></pre></td></tr></table></figure><h3 id="Post-请求，body-是字符串数组的定义"><a href="#Post-请求，body-是字符串数组的定义" class="headerlink" title="Post 请求，body 是字符串数组的定义"></a>Post 请求，body 是字符串数组的定义</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">in:</span> <span class="string">"body"</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">"body"</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">"some urls"</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">schema:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">"array"</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">"#/definitions/Urls"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">definitions:</span></span><br><span class="line">  <span class="attr">Urls:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">"string"</span></span><br></pre></td></tr></table></figure><blockquote><p>Urls 是在 definitions 中定义的字符串类型对象，也可以直接在 item 中定义 type</p></blockquote><h3 id="responses-的配置"><a href="#responses-的配置" class="headerlink" title="responses 的配置"></a>responses 的配置</h3><p>可以配置写说明，比如 200,400,什么的，如果返回值是个对象，也可以配置返回值对应对象，但是不配置也行，会直接输出出来。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger UI入门部署</title>
      <link href="/2020/01/09/Swagger-UI%E5%85%A5%E9%97%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/01/09/Swagger-UI%E5%85%A5%E9%97%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>在开发过程中，通用的功能我们通常会定义一些接口，但随着项目越做越大，时间越来越久，接口就越来越多，忘的就越来越多，沟通成本就越来越高，最后就会想到，当时把定义的接口及用法都写下就好了，巴拉巴拉一大堆后悔的话。</p><p><strong>为了解决上述描述的问题，Swagger UI 应运而生。</strong></p><p>Swagger UI 可以让我们把定义的接口以配置文件的方式编写，最后生成一个可视化较高的网站。</p><a id="more"></a><p><strong>Swagger UI 有如下优势：</strong></p><ul><li>编写语言统一</li><li>风格统一<br>不会像自己写的 word 说明文档，各成一家</li><li>可读性高<br>生成的界面简洁、信息全</li><li>可交互<br>这是最可贵的，根据查看到的接口，我们不仅能看到接口的链接串、参数、返回值等各种信息，我们还可以真是的对服务器进行请求，查看真实的交互，大大减小了同事之间的交互成本。</li></ul><h3 id="资源传送门"><a href="#资源传送门" class="headerlink" title="资源传送门"></a>资源传送门</h3><p><a href="http://swagger.io/specification/" target="_blank" rel="noopener">官网地址</a><br><a href="http://petstore.swagger.io/" target="_blank" rel="noopener">Demo 地址</a><br><a href="http://editor.swagger.io/#/" target="_blank" rel="noopener">在线编辑地址</a></p><blockquote><p>可以把 Swagger UI 理解成自己部署的一个网站</p></blockquote><h3 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h3><p>下面介绍下如何部署自己的 Swagger UI</p><h4 id="1-从-git-上-clone"><a href="#1-从-git-上-clone" class="headerlink" title="1.从 git 上 clone"></a>1.从 git 上 clone</h4><p>github 上 clone：<a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-ui</a></p><h4 id="2-新建一个文件夹-public"><a href="#2-新建一个文件夹-public" class="headerlink" title="2.新建一个文件夹 public"></a>2.新建一个文件夹 public</h4><p>将下载到的 swagger ui 里的 dist 文件夹里的文件复制到 public 文件夹里</p><h4 id="3-在-IIS-上部署"><a href="#3-在-IIS-上部署" class="headerlink" title="3.在 IIS 上部署"></a>3.在 IIS 上部署</h4><p>在运行中 inetmgr 打开 IIS，把 public 文件夹新建一个网站<br>如果 MIME Types 中没有对 json 的支持，需要添加 .json、application/json</p><h4 id="4-访问"><a href="#4-访问" class="headerlink" title="4.访问"></a>4.访问</h4><p>在浏览器中输入你配置的网址就可以访问了<br><a href="http://localhost:8011/index.html" target="_blank" rel="noopener">http://localhost:8011/index.html</a></p><h3 id="部署自己的接口-API"><a href="#部署自己的接口-API" class="headerlink" title="部署自己的接口 API"></a>部署自己的接口 API</h3><p>上面的部署的接口来源是从 Swagger UI 官网提供的，如何部署自己的接口 API 呢，这需要先编写自己的 API 代码。<br><a href="http://editor.swagger.io/#/" target="_blank" rel="noopener">Swagger Editor</a>提供了编写 Swagger UI 的工具。<br>大家可以在这里编写自己的 Swagger UI，该框架使用的是 YAML 语言进行编写，不熟悉的朋友可以自行学习下。</p><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><ul><li>在 Swagger Editor 中点击 File—&gt;Download JSON</li><li>将下载的 json 文件你的 public 文件夹下</li><li>修改 index.html 文件，将原来引用官网 json 文件的链接改成刚生成的 json 文件的路径</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Build a system</span></span><br><span class="line">  <span class="keyword">const</span> ui = SwaggerUIBundle(&#123;</span><br><span class="line">    url: <span class="string">"./swagger.json"</span>,</span><br><span class="line">    dom_id: <span class="string">'#swagger-ui'</span>,</span><br><span class="line">    presets: [</span><br><span class="line">      SwaggerUIBundle.presets.apis,</span><br><span class="line">      SwaggerUIStandalonePreset</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">      SwaggerUIBundle.plugins.DownloadUrl</span><br><span class="line">    ],</span><br><span class="line">    layout: <span class="string">"StandaloneLayout"</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.ui = ui</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中访问下，能访问就 OK 了。</p><p>推荐一个基于 node 部署的<a href="http://www.jianshu.com/p/d6626e6bd72c" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reactjs中事件传参</title>
      <link href="/2020/01/09/reactjs%E4%B8%AD%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%8F%82/"/>
      <url>/2020/01/09/reactjs%E4%B8%AD%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<p>最近公司用 reactjs 做开发，虽然网上很多教程，但实际开发中许多细小的技术点还是需要自己去偶遇</p><a id="more"></a><h3 id="1-事件传参技巧"><a href="#1-事件传参技巧" class="headerlink" title="1.事件传参技巧"></a>1.事件传参技巧</h3><ul><li><strong>问题描述</strong><br>我们在事件中通常需要获取控件的值，通常通过<code>event.target.value</code>的方式来取值，在绑定事件时，event 参数也不需要传递，在方法中直接使用即可。<br>但是，有些时候需要传入一些其他的参数，比如需要循环绑定一些输入框，在绑定 onChange 事件时，需要传入索引<code>index</code>和数据源的索引进行对应</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onHandleChange(index,event)&#123;</span><br><span class="line">    <span class="keyword">let</span> val=event.target.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关键代码</span></span><br><span class="line">source.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;item.name&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.onHandleChange.bind(this,index)&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><ul><li><strong>代码解释</strong><br>有的同学应该已经看出区别了，<code>onHandleChange</code>在声明时有两个参数，但在调用时却只传递了一个参数，这就是今天要讲的:<blockquote><p><strong>在给方法传递新参数时，方法原有的参数会排在新参数之后</strong></p></blockquote></li></ul><p>做过 reactjs 的同学都知道，event 这个参数是不需要手动传递的，直接在方法中声明就可以使用，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onChangeHandle(event)&#123;</span><br><span class="line">      <span class="keyword">let</span> val=event.target.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;input type="text" onChange=&#123;this.onChangeHandle.bind(this)&#125; /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-扩展阅读"><a href="#2-扩展阅读" class="headerlink" title="2.扩展阅读"></a>2.扩展阅读</h3><ul><li>描述<br>在自定义组件时，组件的事件由父组件传入，但为了方便，我们可能在自定义组件中把需要的数据回传给富组件传递过来的方法，如下 dropdwon 控件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">WDropdownlist</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">"-1"</span>,</span><br><span class="line">      text: <span class="string">"全部"</span>,</span><br><span class="line">      selectedValue: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      selectedValue: nextProps.selectedValue,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      selectedValue: <span class="keyword">this</span>.props.selectedValue,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> _props = _self.props;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">selectedValue</span>: event.target.value &#125;);</span><br><span class="line">    <span class="keyword">const</span> currentIndex = event.target.selectedIndex;</span><br><span class="line">    <span class="keyword">const</span> targetItems = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(_props.dataSource));</span><br><span class="line">    _props.onChange &amp;&amp;</span><br><span class="line">      _props.onChange.call(_self, &#123;</span><br><span class="line">        currentIndex: currentIndex,</span><br><span class="line">        currentItem: targetItems[currentIndex],</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> props = self.props;</span><br><span class="line">    <span class="keyword">var</span> state = self.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;select</span><br><span class="line">        className=&#123;props.className&#125;</span><br><span class="line">        style=&#123;props.style&#125;</span><br><span class="line">        disabled=&#123;props.disabled&#125;</span><br><span class="line">        onChange=&#123;self.handleChange.bind(self)&#125;</span><br><span class="line">        name=&#123;props.name&#125;</span><br><span class="line">        value=&#123;state.selectedValue&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;!props.dataSource || props.dataSource.length == <span class="number">0</span> ? (</span><br><span class="line">          &lt;option value=&#123;<span class="keyword">this</span>.state.value&#125;&gt;&#123;<span class="keyword">this</span>.state.text&#125;&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">        ) : (</span></span><br><span class="line"><span class="regexp">          props.dataSource.map((item, index) =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;option key=&#123;index&#125; value=&#123;item[props.valueField]&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &#123;item[props.textField]&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>option&gt;</span><br><span class="line">          ))</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">WDropdownlist.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  style: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  valueField: "value",</span></span><br><span class="line"><span class="regexp">  textField: "text",</span></span><br><span class="line"><span class="regexp">  selectedValue: 0,</span></span><br><span class="line"><span class="regexp">  disabled: false,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li>组件调用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> WDropdwonList <span class="keyword">from</span> <span class="string">'../wigets/w-dropdwon-list.js'</span>;</span><br><span class="line"><span class="comment">//第一个参数就是下面调用控件时传递的参数，item是定义组件时传递的当前选中项对象</span></span><br><span class="line">onChangeHandle(currentMan,item)&#123;</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       otherSource.map((currentMan,index)=&gt;&#123;</span></span><br><span class="line">        &lt;WDropdwonList onChange=&#123;this.onChangeHandle.bind(this,currentMan)&#125;</span><br><span class="line">                dataSource=&#123;this.state.source&#125;</span><br><span class="line">                textField='Display'</span><br><span class="line">                valueField='Value'</span><br><span class="line">                selectedValue=&#123;currentSubsystem['PointRoles'][key]||'-1'&#125;  &gt;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">WDropdwonList</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line">&lt;div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>讲解：<br>下拉框事件中 ，当前选中项经常使用，因此封装到了自定义组件中，但是在使用自定义组件时，会需要传递进去数据源的一些其他参数，比如上面的<code>currentMan</code>,该参数在调用事件方法时，像正常一样传递，没区别，只是在声明事件方法时，事件方法“隐含”的参数放在新传递的参数之后就行，如上面事件方法的定义，item 就是组件内部传递出来的参数,在调用时，是不需要在外面显示传递的</li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>create-react-app项目部署到Github Pages</title>
      <link href="/2020/01/09/create-react-app%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Github-Pages/"/>
      <url>/2020/01/09/create-react-app%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Github-Pages/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>本文讲解使用<code>create-react-app</code>创建的项目，如何部署<code>GitHub Pages</code>，以及这部署到过程中遇到到坑。</p><a id="more"></a><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>使用官网方式创建项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>弹出配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><h3 id="Github-Pages部署讲解"><a href="#Github-Pages部署讲解" class="headerlink" title="Github Pages部署讲解"></a><code>Github Pages</code>部署讲解</h3><p>把项目部署成<code>github pages</code>，在<code>github</code>上点开项目到设置，翻到<code>Github Pages</code>设置处，可以看到<code>Github Pages</code>只能使用<code>master</code>、<code>gh-pages</code>分支或者<code>master</code>下面的<code>docs</code>文件夹。<br>我们这里使用的是<code>gh-pages</code>分支的方式来创建。</p><h3 id="安装gh-pages"><a href="#安装gh-pages" class="headerlink" title="安装gh-pages"></a>安装<code>gh-pages</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gh-pages --save-dev</span><br></pre></td></tr></table></figure><p>通过<code>gh-pages</code>中间件可以把<code>build</code>文件下到文件推送到<code>github</code>，并且创建<code>gh-pages branch</code>。</p><h3 id="修改-package-json"><a href="#修改-package-json" class="headerlink" title="修改 package.json"></a>修改 package.json</h3><p>增加 homepage</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"name": "react_demo",</span><br><span class="line">"version": "1.1.0",</span><br><span class="line">"private": true,</span><br><span class="line">"homepage": "./",  //加上这一句</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>homepage</code>不要设置成<code>github page</code>上生成的那个链接路径，比如<code>https://username.github.io/react_demo/</code>。<br>如果设置成上面的连接，<code>build</code>打的包会这所有路径前面加上<code>react_demo</code>。<br>比如<code>index.html</code>文件中对同等目录下的文件引用应该是<code>src=&#39;./index.css&#39;</code>,结果会变成<code>src=&#39;./react_demo/index.css&#39;</code>,这样部署后肯定无法访问，所有资源都找不到。</p></blockquote><p>增加<code>npm scripts</code>命令，推送<code>gh-pages</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">        ...</span><br><span class="line">     + "deploy": "gh-pages -d build" //加上这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推送项目"><a href="#推送项目" class="headerlink" title="推送项目"></a>推送项目</h3><p><code>GitHub Pages</code>只是部署项目，<code>react</code>代码直接放上去是识别不了的，所以部署的是打包编译后到代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>编译后就可以推送了,执行上面配置的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><p>这时<code>github</code>上项目就多出了一个<code>gh-pages</code>的<code>branch</code>，在设置中<code>Github Pages</code>处选择<code>gh-pages</code>分支保存，部署完成。<br>点击生成的连接，查看是否部署成功。</p><p>2019-05-25</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github page </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10天彻底搞定webpack4.0-笔记(2)</title>
      <link href="/2020/01/09/10%E5%A4%A9%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9Awebpack4-0-%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2020/01/09/10%E5%A4%A9%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9Awebpack4-0-%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h2 id="手写-webpack"><a href="#手写-webpack" class="headerlink" title="手写 webpack"></a>手写 webpack</h2><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>通常<code>npm</code>包都有一个或多个可执行文件需要被安装到环境变量<code>PATH</code>中。<code>npm</code>可以轻松做到这一点。<br>如何做呢？只需要在<code>package.json</code>文件中提供字段<code>bin</code>即可。字段<code>bin</code>是命令名对本地文件的一个映射。当安装的时候，<code>npm</code>会把可执行文件链接进<code>(symlink)</code>全局安装的<code>prefix/bin</code>目录或者本地安装的<code>./node_modules/.bin/</code>目录。<a href="https://www.npmjs.cn/files/package.json/#bin" target="_blank" rel="noopener">官网对 bin 的讲解</a></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="string">"bin"</span>:&#123;</span><br><span class="line">      <span class="string">"custom_command"</span>:<span class="string">"./bin/filename.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>安装后，通过<code>npx custom_command</code>就能执行<code>filename.js</code>文件。</p></blockquote><h3 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h3><p>把本地自己开发的包 symlink 到全局包安装路径中，具体可看文章<a href="https://segmentfault.com/n/1330000019782280?token=26f88776ae4cfe59d5c26157b5384019" target="_blank" rel="noopener">npm link 介绍</a><br>以及安装的相关介绍<a href="https://segmentfault.com/n/1330000019782291?token=7de48a493145373f2d2f203eeb207ab4" target="_blank" rel="noopener">npm install 讲解</a></p><h3 id="结合-bin-和-link-进行包开发"><a href="#结合-bin-和-link-进行包开发" class="headerlink" title="结合 bin 和 link 进行包开发"></a>结合 bin 和 link 进行包开发</h3><p>假设我们现在正在开发一个自己的包(A)。<br>bin 指定了包 A 的可执行文件，link 命令把包(A)symlink 到全局环境中。<br>现在我们要在 demo 中测试一下包 A。可以在 demo 中安装，使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link my_package</span><br></pre></td></tr></table></figure><p>然后就可以通过<code>npx my_package</code>运行包 A</p><p>###AST<br>ast 是抽象语法树。<br><a href="https://segmentfault.com/a/1190000016231512?utm_source=tag-newest" target="_blank" rel="noopener">AST 抽象语法树的讲解</a></p><p>webpack 打包是通过 ast 来进行解析和修改文件。从而实现打包的目的。</p><p>###loader 开发<br>loader 其实就是一个方法（其实是废话，js 中连类都没有，只能是方法啊），读取项目中文件内容，根据 loader 中配置的规则进行转换。</p><p>###loader 组成<br>loader 在分为 pitch 和 normal<br><img src="https://upload-images.jianshu.io/upload_images/1348523-34740557cbf2d28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pitch无返回值"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-c1d1cae46628794e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pitch有返回值"></p><p>###plugin 开发<br>plugin 其实就是 webpack 上的钩子，</p><blockquote><p>laoder 是对项目中的每个文件进行转换、处理的，把文件转换成 javascript 模块。plugin 是对整个项目打包过程进行处理的。</p></blockquote><p>loader 加载顺序，是从右向左，从下往上，但是配置了优先级，优先级如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre ==&gt; normal ==&gt; inline ==&gt; post.</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>JSON.stringify(cssObj)</code>可以取消换行不兼容问题</p></blockquote><p>所有文件的依赖，都会被打包成 key/value 键值对，key 就是依赖文件的路径，value 是经过处理（打包）后生成的 js 方法，这个方法就是依赖文件要干的事情。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10天彻底搞定webpack4.0-笔记(1)</title>
      <link href="/2020/01/09/10%E5%A4%A9%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9Awebpack4-0-%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2020/01/09/10%E5%A4%A9%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9Awebpack4-0-%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h3 id="npm-script-命令给-webpack-传参"><a href="#npm-script-命令给-webpack-传参" class="headerlink" title="npm script 命令给 webpack 传参"></a>npm script 命令给 webpack 传参</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build -- --config webpack.config.js</span><br></pre></td></tr></table></figure><p>加上两个杠，表示后面是字符串，是参数。</p><h3 id="dev-server"><a href="#dev-server" class="headerlink" title="dev-server"></a>dev-server</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">contentBase:'./build/' ,// 指定server启动的目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Html-webpack-plugin"><a href="#Html-webpack-plugin" class="headerlink" title="Html-webpack-plugin"></a>Html-webpack-plugin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template:<span class="string">''</span>,</span><br><span class="line">  filename:<span class="string">''</span>,</span><br><span class="line">  hash:tue, <span class="comment">//在每个html后面加上hash</span></span><br><span class="line">  <span class="comment">//压缩html</span></span><br><span class="line">  minify:&#123;</span><br><span class="line">    removeAttributeQuotes:<span class="literal">true</span> <span class="comment">// 删除属性值上的双引号</span></span><br><span class="line">    collapseWhitespace:<span class="literal">true</span>,<span class="comment">// 压缩html成一行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>css-loader 主要是解决<code>@import</code>、图片路径等这些语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>;</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">"style-loader"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        insertAt: <span class="string">"top"</span>, <span class="comment">// 设置style标签插入的地方</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽离-css"><a href="#抽离-css" class="headerlink" title="抽离 css"></a>抽离 css</h3><p>使用插件<code>mini-css-extract-plugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MniCssExtractPlugin = riquire(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">"main.css"</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是就不要放到style里面，所以style-loader就不要了</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>;</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">// css-loader执行后执行minicssextractplugin的loader</span></span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    <span class="string">"css-loader"</span>,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css-自动加前缀"><a href="#css-自动加前缀" class="headerlink" title="css 自动加前缀"></a>css 自动加前缀</h3><p>使用 autoprefixer 插件，但是需要 postcss-loader 对它进行解析。<br>在 css-loader 之前 less-loader 使用 postcss-loader</p><h3 id="压缩-css"><a href="#压缩-css" class="headerlink" title="压缩 css"></a>压缩 css</h3><p>默认情况下，webpack 使用<code>uglifyjs-webpack-plugin</code>插件在生产环境打包时已经压缩了 js，但如果使用了<code>mini-css-extract-plugin</code>，则需要自己单独再配置压缩优化相关项，<a href="[https://www.npmjs.com/package/mini-css-extract-plugin](https://www.npmjs.com/package/mini-css-extract-plugin)">可查看官网</a>。<br>压缩 js 可以使用<code>uglifyjs-webpack-plugin</code>，也可以使用下面的。压缩 css 需要插件<code>optimize-css-assets-webpack-plugin</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserJSPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;<span class="comment">// 优化项</span></span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserJSPlugin(&#123;&#125;), <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">  &#125;,</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换-es6-语法"><a href="#转换-es6-语法" class="headerlink" title="转换 es6 语法"></a>转换 es6 语法</h3><p>babel-loader<br>babel-core<br>babel/preset-env</p><p>@babel/plugin-transform-runtime 和 @babel/runtime 解决更高级语法 api 没有的问题，比如 generator</p><h3 id="js-规范"><a href="#js-规范" class="headerlink" title="js 规范"></a>js 规范</h3><p>使用 eslint-loader 和 eslint<br>如果只是使用 eslint，帮助在开发过程中进行检测，会提示文件中语法不符合规则的部分。但是在打包的时候不会做校验。使用 eslint-loader,在 webpack 进行打包的时候进行校验。<br>eslint-loader 通常单独配置，不建议和 bable 等其他处理 js 的 loader 写在一块。可以通过<code>enforce</code>设置执行顺序，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    enforce: <span class="string">"pre"</span>,<span class="comment">//在其他loader之前执行，使用post在其他loader之后执行</span></span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"eslint-loader"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="暴露第三方模块给全局"><a href="#暴露第三方模块给全局" class="headerlink" title="暴露第三方模块给全局"></a>暴露第三方模块给全局</h3><p>比如我们安装了 jquery，我们可以在每个模块中 import 进来，然后使用，这样是没问题的，但是如果想通过 window 访问这些包，就不行了，可以通过下面的方法来实现。</p><blockquote><p>下面简单说下 loader 的分类：</p><ul><li>pre 前置 loader,前面执行的 loader</li><li>normal 普通的 loader</li><li>内联 loader</li><li>post 后置 loader</li></ul></blockquote><p>比如使用<code>expose-loader</code>。</p><ol><li>通过内联 loader 的方式来实现把 jquery 暴露给 window。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">"expose-loader?$!jquery"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.$); <span class="comment">// window上存在$</span></span><br></pre></td></tr></table></figure><p>但是上面的写法不美观，可以在配置文件中配置。</p><ol start="2"><li>在配置文件中配置</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:require.resolve('jquery'),</span><br><span class="line">    use:'expose-loader?$'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">import $ from 'jquery'</span><br><span class="line">console.log(window.$)</span><br></pre></td></tr></table></figure><p>不用引用直接使用呢？</p><ol start="3"><li>在每个模块中注入$对象<br>通过<code>webpack</code>的<code>ProviderPlugin</code>插件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 在每个模块中都注入</span></span><br><span class="line">  <span class="keyword">new</span> webpack.ProviderPlugin(&#123;</span><br><span class="line">    $: <span class="string">"jquery"</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为是注入到每个模块中的，所以在每个模块中可以直接使用，但window.$不存在</span></span><br><span class="line"><span class="built_in">console</span>.log($);</span><br></pre></td></tr></table></figure><h3 id="不打包指定模块"><a href="#不打包指定模块" class="headerlink" title="不打包指定模块"></a>不打包指定模块</h3><p>比如在<code>index.html</code>中手动引入了<code>jquery</code>包，那就不需要对<code>jquery</code>进行打包。通过设置<code>webpack</code>的<code>externals</code>属性可以实现该功能。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">    jquery:"$"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使在代码中使用 import 的方式引入，也不会进行打包。</p><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><p>file-loader 默认会在内部生成一张图片到输出目录下，把生成的图片的名字返回回来。 ### 在 html 中使用 img<br>因为 webpack 会对模块中引用的 img 进行打包转换等处理，所以如果直接在 index.html 中使用 img 是识别不了的。如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./logo.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>因为打包后原来的 logo.png 的名字和路径都发生了变化，所以这种写法是肯定拿不到的。<br>使用<code>html-withimg-loader</code>可以解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.html/</span>;</span><br><span class="line">  use: <span class="string">"html-withimg-loader"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小图片的处理"><a href="#小图片的处理" class="headerlink" title="小图片的处理"></a>小图片的处理</h3><p>使用<code>url-loader</code>可以使用 base64 的方式减少对图片的请求。</p><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><ol><li>图片</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jpg|png|jpeg|svg)/</span></span><br><span class="line">    use:&#123;</span><br><span class="line">        lader:<span class="string">'url-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">            limit:<span class="number">2</span>*<span class="number">1024</span>,</span><br><span class="line">            outputPath:<span class="string">'img/'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>css</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MiniCssExdtractPlugin(&#123;</span><br><span class="line">  filename: <span class="string">"css/main.css"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就是在各个资源前面加上文件夹名即可</p><blockquote><p>如果需要在每个资源前面统一加上一个前缀，比如 cdn，可以配置 webpack 输出路径的 publicpath</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> output:&#123;</span><br><span class="line">   filename:<span class="string">'bundle.js'</span>.</span><br><span class="line">   path:path.resolve(__dirname,<span class="string">'build'</span>),</span><br><span class="line">   publicPath:<span class="string">'https://www.baiducdn.com/'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要在不同的资源前面家不同的 cdn，可以在各自 loader 上加上 publicPath</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test:<span class="regexp">/\.(jpg|png|jpeg|svg)/</span></span><br><span class="line">   use:&#123;</span><br><span class="line">       lader:<span class="string">'url-loader'</span>,</span><br><span class="line">       options:&#123;</span><br><span class="line">           limit:<span class="number">2</span>*<span class="number">1024</span>,</span><br><span class="line">           outputPath:<span class="string">'img/'</span>,</span><br><span class="line">           publicPath:<span class="string">'https://www.baidu.com/'</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry:&#123;</span><br><span class="line">        home:<span class="string">'./src/home.js'</span>,</span><br><span class="line">        other:<span class="string">'./src/other.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">"dist/"</span>),</span><br><span class="line">    <span class="comment">//输出时只要根据每个入口的名字输出就行</span></span><br><span class="line">    filename: <span class="string">"js/[name].js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">plugins:[</span><br><span class="line">    <span class="comment">// 模板输出html文件无法使用入口定义的名字，</span></span><br><span class="line">    <span class="comment">//只能使用多个模板实例来解决多个的问题。</span></span><br><span class="line">    <span class="comment">//但需要使用chunk来指定加载打包的js</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          template:<span class="string">'./home.html'</span>,</span><br><span class="line">          filename:<span class="string">'home.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'home'</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          template:<span class="string">'./home.html'</span>,</span><br><span class="line">          filename:<span class="string">'home.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'home'</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码映射"><a href="#代码映射" class="headerlink" title="代码映射"></a>代码映射</h3><p>配置了 sourcemap 不仅仅是开发的时候有映射，生产环境也会有(当然生产环境不配置就没有了)。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devtool"</span>: <span class="string">"source-map"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>source-map<br>源码映射，会单独生成一个 source map 文件，出错了会列出报错的列和行号。</li><li>eval-sorce-map<br>不会产生单独的文件，但是可以显示出错的行和列;并且在浏览器中也能看到源码。eval 标明，这种方式是使用 eval 的方式把源码生成字符串，集成在打包后的文件中，然后 eval 出来。</li><li>cheap-module-source-map<br>不显示出错的行和列，但是生成一个单独的文件，并且和调试<strong>没有</strong>关联起来。</li><li>cheap-module-eval-source-map<br>不生成文件，集成在打包后的文件中， 也不会产生列</li></ul><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"watch"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"watchOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"poll"</span>: <span class="number">100</span>, <span class="comment">// 每秒检测的次数</span></span><br><span class="line">    <span class="attr">"aggregateTimeout"</span>: <span class="number">500</span>, <span class="comment">// 防抖，500毫秒内的变化</span></span><br><span class="line">    <span class="attr">"ignored"</span>: <span class="string">"/node_modules/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小插件"><a href="#小插件" class="headerlink" title="小插件"></a>小插件</h3><ul><li>cleanWebpackPlugin<br>每次打包，先清空指定目录中的旧文件。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> cleanWebpackPlugin(<span class="string">"./dist"</span>);</span><br></pre></td></tr></table></figure><ul><li>copyWebpackPlugin<br>打包的时候，有些静态资源可能不会被打包，但也是需要放到打包目录中，使用这个插件，就可以实现该功能。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> copyWebpackPlugin([&#123; <span class="attr">from</span>: <span class="string">"doc"</span>, <span class="attr">to</span>: <span class="string">"/"</span> &#125;]);</span><br></pre></td></tr></table></figure><ul><li>bannerPlugin(内置的 )<br>给打包后的代码加上版权信息。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"make by wenmu 2019 "</span>);</span><br></pre></td></tr></table></figure><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>就是设置<code>devServer</code>的<code>proxy</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        <span class="string">'/api'</span>:<span class="string">"http://localhost:4567"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就把以<code>/api</code>开头的请求链接都转到<code>http://localhost:4567</code>的服务上。比如<code>/api/user/getDetail</code>,发出的请求就是<code>http://localhost:4567/api/user/getDetail</code>。<br><strong>如果服务端的链接不带<code>/api</code>怎么办？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: &#123;</span><br><span class="line">      target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">      pathRewrite: &#123;<span class="string">'^/api'</span> : <span class="string">''</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端自己-mock-数据，不借助服务端"><a href="#前端自己-mock-数据，不借助服务端" class="headerlink" title="前端自己 mock 数据，不借助服务端"></a>前端自己 mock 数据，不借助服务端</h3><p>我们知道，其实 devServer 本身就是一个 node 服务。我们可以使用这个服务直接处理请求。这需要借助 devServer 的 before 钩子函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">   before: <span class="function"><span class="keyword">function</span>(<span class="params">app, server</span>) </span>&#123;</span><br><span class="line">     app.get(<span class="string">'/some/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">       res.json(&#123; <span class="attr">custom</span>: <span class="string">'response'</span> &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>app</code>就是<code>devServer</code>中的<code>express</code>实例。<br>如果一个一个的请求都写到这里面，这个文件会比较大，所以可以把相关的请求函数封装到一起，在这里调用即可。通常使用第三方封装的组件<code>mocker-api</code>帮助 mock 数据。<code>mocker-api</code>就是这个原理。</p><h3 id="服务端-node-启动-webpack"><a href="#服务端-node-启动-webpack" class="headerlink" title="服务端 node 启动 webpack"></a>服务端 node 启动 webpack</h3><p>使用<code>node</code>启动<code>webpack</code>，这样在<code>node</code>中写的<code>mock</code>数据就和<code>webpack</code>启动的前端是一个端口，就不存在跨域问题了。<br>在服务端中启动<code>webpack</code>，需要使用<code>webpack</code>的中间件<code>webpack-dev-middleware</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">const</span> middleware = <span class="built_in">require</span>(<span class="string">"webpack-dev-middleware"</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">"./webpack.config.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> express();</span><br><span class="line">app.use(middleware(compiler));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/user"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.json(&#123; <span class="attr">name</span>: <span class="string">"test data."</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>resolve 的作用就是解析，项目中的各种解析都可以在这里做相关的配置。</p><ul><li>第三方包的查找<br>默认情况下，当引入一个包时，首先在<code>node_modules</code>中查找，如果找不到就再去全局包安装目录查找，再找不到就报错了。我们可以通过配置 <code>modules</code>来强制指定只在哪些目录中进行查找，比如只在<code>node_modules</code>中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">    modules:[path.resolve(<span class="string">'node_modules'</span>)]</span><br><span class="line">&#125;,</span><br><span class="line">devServer:&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>别名<br>如果一个路径的比较长，引用起来比较麻烦，可以通过在 resolve 中对路径设置别名来解决。<br>比如应用 bootstrap 的样式，<code>bootstrap/dist/css/bootstrap.css</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    BootstrapStyle: <span class="string">"bootstrap/dist/css/bootstrap.css"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是可以直接引用<code>BootstrapStyle</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BootstrapStyle;</span><br></pre></td></tr></table></figure><ul><li>优先读取的 package 字段<br>在引用一个包时，默认是读取包中<code>package.json</code>中<code>main</code>字段配置的文件，如下是<code>bootstrap</code>的<code>package.json</code>，当<code>import bootstrap</code>时，读取的是 js 文件。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style:<span class="string">'/dist/css/bootstrap.css'</span>,</span><br><span class="line">main:<span class="string">'/dist/js/bootstrap.js'</span></span><br></pre></td></tr></table></figure><p>我们可以设置引入包时，优先读取的字段，比如优先读取<code>style</code>字段，找不到了再读取<code>main</code>字段对应的文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">   mainFields: [<span class="string">'style'</span>, <span class="string">'main'</span>],</span><br><span class="line">   mainFiles:[<span class="string">'index'</span>] <span class="comment">// 入口文件的名字</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样当<code>import bootstrap</code>时，bootstrap 的样式就被加载了。</p><ul><li>默认扩展名<br>在引入一些文件时，比如 js，后缀名是不需要写的，但是 css 的后缀是必须写的，我们是可以设置一些类型不需要些扩展名的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">".js"</span>, <span class="string">".css"</span>, <span class="string">".jsx"</span>, <span class="string">".json"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入一个文件时，会先找 js，找不到再找 css，依次 jsx、json 等等。当匹配到一个时，就不会继续再匹配了。因此存在多种类型的文件使用一个文件名时，当引入这个文件名时，只会加载设置的第一个类型。如果引用 css，还是需要加上后缀。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>webpack 提供了一个插件可以帮助我们定义一些环境变量;<code>webpack.DefinePlugin</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  NAME: <span class="string">"'wenmu'"</span>,</span><br><span class="line">  DEV: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">  Express: <span class="string">"1+1"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样上面定义的变量就可以直接使用了。<br>细心的同学发现，为什么<code>NAME</code>的值要用双引号把包括单引号呢？<br>因为在读取变量时，会把后面单引号中的直接复制给变量，那读取上面的<code>NAME</code>就成了<code>wenmu</code>,而不是<code>&#39;wenmu&#39;</code>那就会报错，说 wenmu 未定义了，当成一个变量了。比如 Express 就是 2，不是<code>1+1</code>字符串。<br>可以使用双引号再包裹一下，但推荐使用第二种的写法，可读性强。</p><h3 id="区分不同的环境"><a href="#区分不同的环境" class="headerlink" title="区分不同的环境"></a>区分不同的环境</h3><p>通常开发和生产使用的 webapck 配置文件是不一样的，但是大部分的配置是一样的，因此写一个 base 文件，再写两个开发和生产的“继承”base 即可。继承就用到了<code>webpack-merge</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; smart &#125; = <span class="built_in">require</span>(<span class="string">"webapck-merge"</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">"./webapck.base.js"</span>);</span><br><span class="line"></span><br><span class="line">modules.export = smart(base, &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webpack-优化"><a href="#webpack-优化" class="headerlink" title="webpack 优化"></a>webpack 优化</h3><ol><li>noParse<br>noParse 指定不需要解析的包，当一个包比较大，并且没有依赖其他包时，可以使用 noParse 指定，这样可以减少打包时间。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置 loader 解析的范围</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>, <span class="comment">//排除不需要解析的</span></span><br><span class="line">      include: path.resolve(<span class="string">"src"</span>), <span class="comment">// 设置需要解析的</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: [<span class="string">"babel-loader"</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>ignorePlugin<br>在使用一个写第三方包时，包可能会引入很多文件，但是一些文件可能对我们的项目是没用的。<br>比如有一个 moment，这个包做了国际化处理，默认它会把所有的语言包都加载，如果我们只使用了中文，这样打包的时候就比较大，这时可以使用 webpack 提供的 IgnorePlugin 来指定这个包哪些文件不需要加载。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [<span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/\.\/locale/</span>, /moment/)];</span><br></pre></td></tr></table></figure><p>这时国际化就不管用了，中文的语言包需要手动引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"moment/locale/zh-cn"</span>;</span><br><span class="line"></span><br><span class="line">moment.locale(<span class="string">"zh-cn"</span>);</span><br></pre></td></tr></table></figure><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>默认在打包时，所有的包都会被到包在一起，包括第三方库，这样每次打包的时候，第三方库和有些公共的文件也需要每次都重新进行打包，这样不仅打出的包比较大，并且打包会比较慢。<br>因此我们可以把第三方库和一些公共的文件抽离出来，先单独进行打包。比如 react、react-dom 等等。然后开发的时候引用我们单独打好的包，这样每次打包的时候，单独抽离出来的包就不会再次进行打包了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> abc= (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">                ....</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span>        ....</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"./src/aaa.js"</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/******/</span> (&#123;</span><br><span class="line"><span class="comment">/***/</span> <span class="string">"./src/aaa.js"</span>:</span><br><span class="line">  !*** ./src/aaa.js ***!</span><br><span class="line"><span class="comment">/*! no static exports found */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"module.exports = \"this is a value\";\n\n\n//# sourceURL=webpack:///./src/aaa.js?"</span>);</span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"><span class="comment">/******/</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面是打包后的代码结构，大部分删除了。<code>var abc=</code>是手动写上的。</p><blockquote><p>简单讲解下打包后文件的代码结构。<br> 一个模块打包后，原来的模块会被封装成一个立即执行 function，js 中其实类或模块都是 function 的语法糖吗，这个 function 会把打包的模块做一个对象返回。我们在引用模块的时候，其实就是接受这个 function 的返回值。<br> 我们把这个函数的返回值赋给一个变量，然后</p></blockquote><p>基于上面的讲解，我们可以在配置文件中指定，接收打包后返回值的变量名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    test: <span class="string">"./src/aaa.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    library: <span class="string">"abc"</span>, <span class="comment">// 接收的变量名</span></span><br><span class="line">    <span class="comment">// 指定接收的方式，可以是变量的方式var(默认 )，也可以是commonjs，amd等其他方式。</span></span><br><span class="line">    libraryTarget: <span class="string">"var"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加上<code>library</code>的配置后，上面的手动写的<code>var abc=1</code>就不用手动写了，打包出来的就是这样的。</p><p>动态链接库就是基于上面的原理来做的，只是我们需要打包的是 react、react-dom 等包。</p><ol><li>如何让 webpack 知道上面生成的文件就是动态链接库呢？<br>这就需要用到<code>webpack</code>的自带插件<code>DllPlugin</code>,它能指定把哪个文件打包成动态链接库，并且用一个清单(<code>manifest.json</code>)的方式进行管理。<code>manifest.json</code>记录了如何查找动态链接库中的文件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    react: [<span class="string">"react"</span>, <span class="string">"react-dom"</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"_dll_[name].js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    library: <span class="string">"_dll_[name]"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// name==library</span></span><br><span class="line">      name: <span class="string">"_dll_[name]"</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"dist"</span>, <span class="string">"manifest.json"</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 webpack 编译后，会生成一个<code>_dll_react.js</code>和<code>manifest.json</code>两个文件。</p><ul><li><code>_dll_react.js</code>中就是打包后的<code>react</code>和<code>react-dom</code></li><li><code>manifest.json</code>，记录了<code>_dll_react</code>中的依赖关系。这个主要是被<code>DllReferencePlugin</code>使用。</li></ul><p>打包完以后，就需要在入口 index.html 文件中引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/_dll_react.js "</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然引用了，但是打包的时候，react、react-dom 默认还是去<code>node_modules</code>中找，找到了然后就又被打包了，那怎么办，上面的工作不是白做了吗，这就需要用到<code>webpack</code>的另一个插件<code>DllReferencePlugin</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">  manifest: path.resolve(__dirname, <span class="string">"dist"</span>, <span class="string">"manifest.json"</span>),</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><blockquote><p>注意：这个和<code>DllPlugin</code>不在一个配置文件中，这个是开发打包使用的<code>webpack配置文件</code>,而<code>DllPlugin</code>是专门用来提取的公共包的<code>webpack配置</code>文件。</p></blockquote><p>这样配置后，打包的时候会先去清单中查找包，找不到了再把包打包进当前的代码中。这样打包出来的文件往往很小，因为公用包都已经在<code>_dll_react.js</code>中了</p><h3 id="多线程打包"><a href="#多线程打包" class="headerlink" title="多线程打包"></a>多线程打包</h3><p>多现成打包主要用到了<code>happypack</code>插件。这个很简单，主要就是把原来的 loader 换成 happypack 的 loader，然后在 plugin 中配置 happypack 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">exports.plugins = [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">"jsx"</span>,</span><br><span class="line">    threads: <span class="number">4</span>,</span><br><span class="line">    loaders: [<span class="string">"babel-loader"</span>],</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">"styles"</span>,</span><br><span class="line">    threads: <span class="number">2</span>,</span><br><span class="line">    loaders: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>, <span class="string">"less-loader"</span>],</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">exports.module.rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: <span class="string">"happypack/loader?id=jsx"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: <span class="string">"happypack/loader?id=styles"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>非常 easy.</p><h3 id="webpack-自带的优化功能"><a href="#webpack-自带的优化功能" class="headerlink" title="webpack 自带的优化功能"></a>webpack 自带的优化功能</h3><ol><li>tree-shaking<br>当我们使用 import 的方式引用一个模块时，如果只是引用了模块的部分方法，那在生产环境打包的时候，那些没有引用的方法会被删除掉。不会被打包进来。<br>但当使用 require 的方式引用模块时不会删除没用到的代码。<br>这是由<code>require</code>和<code>import</code>的机制相关的。</li><li>scope hosting 作用域提升</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + b + c);</span><br></pre></td></tr></table></figure><p>上面的代码打包的时候，不会把 a、b、c 都打包进来，打包进来的是一个结果，<code>console.log(6)</code>,类似的模块引用等都会做类似的处理。</p><h3 id="抽取公共代码"><a href="#抽取公共代码" class="headerlink" title="抽取公共代码"></a>抽取公共代码</h3><p>抽取公共代码，是当有多个页面的时候(不都是单页面应用 )，多个个页面之间有公共的模块引用，打包的时候，默认会把公用的包在每个引用的页面中都打一份，造成公共代码的重复；<br>比如现在有多个入口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  index: './src/index.js',</span><br><span class="line">  other:'./src/other.js',</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>当 index.js 和 other.js 中引用的有相同的模块时，可以把这些公用的模块抽离出来，这样打包的时候每个页面只有对公共模块的引用，不会在每个包中都包含一份，并且在访问 index 的时候就会被缓存，再访问 other 的时候，就不需要再下载了，从而提高性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 分割代码块</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        <span class="comment">// 缓存组</span></span><br><span class="line">        common: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          chunks: <span class="string">"initial"</span>, <span class="comment">//只优化同步加载的模块</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面是一个很简单的配置，可以去官网查看比较全面的配置，这里需要讲解一下<code>chunks</code>的字段含义。<br><code>chunks</code>有三个可选值，<code>all</code>、<code>initial</code>和<code>async</code></p><ul><li><code>async</code>：指定抽离动态引入的公共模块</li><li><code>initial</code>: 指定抽离非动态引入的公共模块</li><li><code>all</code>: 所有符合条件的公共模块都进行抽离<br>在引入模块时，通常都是非动态的引入，比如<code>import $ from &#39;jquery&#39;</code>;有时候也需要动态的引入一些模块，比如:<code>import (&#39;lodash&#39;)</code></li></ul></blockquote><h4 id="抽离第三方模块"><a href="#抽离第三方模块" class="headerlink" title="抽离第三方模块"></a>抽离第三方模块</h4><blockquote><p>上面讲解了抽离公用的模块，但没有区分是第三方包还是程序中开发的，我们可以把这两种情况分开，把第三方包重复使用的抽离到一起，自己开发的抽离到一起。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 分割代码块</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        <span class="comment">// 缓存组</span></span><br><span class="line">        common: &#123;</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          chunks: <span class="string">"initial"</span>, <span class="comment">//只优化同步加载的模块</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">          priority: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          chunks: <span class="string">"initial"</span>, <span class="comment">//只优化同步加载的模块</span></span><br><span class="line">          priority: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实就是再配置一个抽离方案，但要注意加上<code>priority</code>，因为程序是从上往下执行的，如果不加<code>priority</code>,下面的方案就不会被执行。<br>我们需要让<code>vendors</code>的权重比<code>common</code>的大，才能先把第三方的抽离，然后再抽离公共的。当然，也可以把<code>vendors</code>放到第一个。总之把条件范围小的权重大点，让先执行。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载说白就是使用 es6 草案的<code>import (&#39;jquery&#39;)</code>语法动态的加载 js。</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">devServer: &#123;</span><br><span class="line">hot: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// 打印更新的模块路径</span></span><br><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin() <span class="comment">// 热更新插件</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tapable"><a href="#tapable" class="headerlink" title="tapable"></a>tapable</h3><p><code>Webpack</code>本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是<code>Tapable</code>，<code>Tapable</code>有点类似于<code>nodejs</code>的<code>events</code>库，核心原理也是依赖<strong>订阅发布模式</strong>。</p><ul><li><p>SyncHook<br>这个比较简单，订阅的钩子一个一个都执行。</p></li><li><p>syncBailHook<br>任何一个钩子的返回值不是<code>undefined</code>，后面的钩子就不执行了。</p></li><li><p>SyncWaterfallHook<br>上一个钩子的返回结果传给下一个。</p></li><li><p>SyncLoopHook<br>钩子的返回值不是<code>undefined</code>，就一直执行。<br>上面三个都是同步的 Hook，下面介绍几个异步的 Hook。</p></li><li><p>AsyncParallelHook<br>异步并行的钩子，当所有的异步都执行完后，才执行最后的回调。</p><blockquote><p>这提供了判断“所有异步都结束”的方案，就是在每个钩子的回调函数必须接收一个回调的参数，这个回调的参数就是一个计数的 function，每个钩子结束后必须执行这个计数的 function。当计数和钩子的个数相等时，说明所有异步钩子执行完了。<br>现在使用`promise.all 实现起来就更方便了。</p></blockquote></li><li><p>AsyncSeriesHook<br>异步串行，当上一个异步执行完以后，再执行第二个异步钩子。<br>promise 版本实现原理</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise(...args)&#123;</span><br><span class="line">    <span class="keyword">let</span> [first,...others]=<span class="keyword">this</span>.tasks;</span><br><span class="line">    <span class="keyword">return</span> others.reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.then(<span class="function"><span class="params">()</span>=&gt;</span>n(...args))</span><br><span class="line">    &#125;,first(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用数组的 reduce 方法和 promise 返回是仍是 promise 的特性。redux 的源码也是这个原理。</p><ul><li>AsyncSeriesWaterfallHook<br>异步串行瀑布，上一个异步执行完以后再执行下一个，但是上一个钩子的结果传给下一个，如果有错误，则停止后 面钩子的执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm install各种方式的介绍</title>
      <link href="/2020/01/09/npm-install%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/01/09/npm-install%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-npm-install"><a href="#1-npm-install" class="headerlink" title="1. npm install"></a>1. npm install</h3><p>安装<code>package.json</code>中依赖的所有包。</p><h3 id="2-npm-install-folder"><a href="#2-npm-install-folder" class="headerlink" title="2. npm install folder"></a>2. npm install folder</h3><p>folder 其实就是包名，从 npm 源上安装指定的包。</p><h3 id="3-npm-install"><a href="#3-npm-install" class="headerlink" title="3. npm install "></a>3. npm install <tarball file></h3><p>安装本地的压缩包文件。如果要安装开发中的目录，则可以使用<code>npm link</code></p><h3 id="4-npm-install"><a href="#4-npm-install" class="headerlink" title="4.npm install "></a>4.npm install <tarball url></h3><p>根据压缩文件的<code>url</code>来安装，但是<code>url</code>必须是以<code>http://</code>或<code>https://</code>开头。</p><h3 id="5-npm-install-lt-scope-gt"><a href="#5-npm-install-lt-scope-gt" class="headerlink" title="5. npm install [&lt;@scope&gt;/]"></a>5. npm install [&lt;@scope&gt;/]<name></h3><p>安装指定范围下面的某个包。<br>如果范围前面没加@符号，则会被认为是 github 的仓库名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install githubname/reponame</span><br><span class="line">npm install @myorg/privatepackage</span><br></pre></td></tr></table></figure><h3 id="6-npm-install-lt-scope-gt"><a href="#6-npm-install-lt-scope-gt" class="headerlink" title="6. npm install [&lt;@scope&gt;/]@"></a>6. npm install [&lt;@scope&gt;/]<name>@<tag></h3><p>加 tag</p><h3 id="7-npm-install-lt-scope-gt"><a href="#7-npm-install-lt-scope-gt" class="headerlink" title="7. npm install [&lt;@scope&gt;/]@"></a>7. npm install [&lt;@scope&gt;/]<name>@<version></h3><p>加版本</p><h3 id="8-npm-install"><a href="#8-npm-install" class="headerlink" title="8. npm install "></a>8. npm install <git remote url></h3><p>安装 git 链接的包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[<span class="comment">#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span></span><br></pre></td></tr></table></figure><p><code>protocol</code>(协议)是以下<code>git, git+ssh, git+http, git+https, or git+file</code>其中之一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install git+ssh://git@github.com:npm/cli.git<span class="comment">#v1.0.27</span></span><br><span class="line">npm install git+ssh://git@github.com:npm/cli<span class="comment">#semver:^5.0</span></span><br><span class="line">npm install git+https://isaacs@github.com/npm/cli.git</span><br><span class="line">npm install git://github.com/npm/cli.git<span class="comment">#v1.0.27</span></span><br><span class="line">GIT_SSH_COMMAND=<span class="string">'ssh -i ~/.ssh/custom_ident'</span> npm install git+ssh://git@github.com:npm/cli.git</span><br></pre></td></tr></table></figure><h3 id="9-npm-install"><a href="#9-npm-install" class="headerlink" title="9. npm install /[#]"></a>9. npm install <githubname>/<githubrepo>[#<commit-ish>]</h3><p>安装 github 上的包，其实也是通过 8 中 git 获取到，然后安装。</p><h3 id="10-npm-install-gitlab"><a href="#10-npm-install-gitlab" class="headerlink" title="10. npm install gitlab:/[#]"></a>10. npm install gitlab:<gitlabname>/<gitlabrepo>[#<commit-ish>]</h3><p>安装 gitlab 官网的包，也是通过 8 中的 git 获取，然后安装。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实<code>npm install</code> 可以安装各种源的包，只要设置的方法能获取包的文件即可。</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm link</title>
      <link href="/2020/01/09/npm-link/"/>
      <url>/2020/01/09/npm-link/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Symlink a package folder</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm link (<span class="keyword">in</span> package dir)</span><br><span class="line">npm link [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span>: npm ln</span><br></pre></td></tr></table></figure><p>通俗讲，就是如何使用本地正在开发的包。</p><a id="more"></a><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>假设我们现在正在开发一个自己的包 A，而现在需要在一个项目或 demo 中使用，并调试，link 命令就是解决这个问题的。<br>分为两步：<br>第一步：在需要设置的包文件夹中，执行 npm link 命令，这将在全局安装包目录<code>{prefix}/lib/node_modules/&lt;package&gt;</code>创建一个 symlink。</p><p>第二步：安装 link 的包。在另一个需要安装包的文件夹中执行<code>npm link package-name</code>,包就被从全局的包路径中安装到了 node_modules 中。</p><p>通过上面的“注册”和“安装”，就可以在本地使用自己开发的包，并且当包的代码改变后，不需要重新 link，使用的地方直接获取的就是最新的代码。</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> link </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js生成html用到的模板</title>
      <link href="/2020/01/09/js%E7%94%9F%E6%88%90html%E7%94%A8%E5%88%B0%E7%9A%84%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/01/09/js%E7%94%9F%E6%88%90html%E7%94%A8%E5%88%B0%E7%9A%84%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pug.bootcss.com/api/getting-started.html" target="_blank" rel="noopener">pug</a></p><p><a href="https://github.com/mde/ejs" target="_blank" rel="noopener">EJS</a></p><p><a href="http://www.nooong.com/docs/jade_chinese.htm" target="_blank" rel="noopener">Jade</a></p><p>这些模板工具不仅仅可以用来生成 html 内容，也可以用于生成 js 文件。</p><p><a href="https://www.zhihu.com/question/20355486" target="_blank" rel="noopener">对比文章</a><br><img src="https://upload-images.jianshu.io/upload_images/1348523-201a03caf4211271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="级别体系.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的AST抽象语法树</title>
      <link href="/2020/01/09/javascript%E7%9A%84AST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
      <url>/2020/01/09/javascript%E7%9A%84AST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>可以通过<a href="https://astexplorer.net/" target="_blank" rel="noopener">ast exploer 网站</a>实时查看生成的抽象语法树。</p><p>可以查看<a href="https://segmentfault.com/a/1190000012943992" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012943992</a></p><p>ast 操作的三板斧：</p><ul><li>通过 esprima 生成 AST</li><li>通过 estraverse 遍历和更新 AST</li><li>通过 escodegen 将 AST 重新生成源码</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN学习笔记</title>
      <link href="/2020/01/09/CDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/CDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CDN-定义"><a href="#1-CDN-定义" class="headerlink" title="1. CDN 定义"></a>1. CDN 定义</h3><blockquote><p>CDN 的全称 Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快，更稳定。<br>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据网络流量和各节点的连接，负债情况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>其目的是使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度。</p><p>产生背景：</p><p>BGP 机房虽然可以提升用户体验但是价格昂贵，那么 CDN 的诞生可以提供比 BGP 机房对于用户更好的体验（让地区的同一线路访问当地的同一线路的网站），BGP 机房和普通机房价格将近 5-10 倍的价格差。CDN 使用单线的机房，根据用户的线路以及位置为用户选择靠近用户的位置以及相同的运营商线路，即提升了用户体验价格又降下来了。</p><p>CDN 的价值：为客户省钱，同时提升用户体验。</p></blockquote><a id="more"></a><h3 id="2-CDN-的特点"><a href="#2-CDN-的特点" class="headerlink" title="2.CDN 的特点"></a>2.CDN 的特点</h3><blockquote><ol><li><p>提高访问速度和网站稳定性<br>本地 Cache 加速提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性（省钱，用户体验提升）。</p></li><li><p>消除不同运营商互联瓶颈<br>镜像服务消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。比如联通、网通等等</p></li><li><p>负载均衡<br>远程加速远程访问用过户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度。</p></li><li><p>减轻服务器压力<br>带宽优化自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽，分担网络流量，减轻原站点 WEB 服务器负载等功能。</p></li><li><p>智能 cdn，防止 ddos 攻击<br>集群抗攻击广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 DDOS 攻击对网站的影响，同时保证较好的服务质量。</p></li></ol></blockquote><h3 id="普通的请求过程"><a href="#普通的请求过程" class="headerlink" title="普通的请求过程"></a>普通的请求过程</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-b78cc4a1f18568c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web请求过程.jpg"></p><blockquote><ol><li>用户请求一个域名</li><li>域名服务器解析域名对应真实的 IP 地址</li><li>用户拿到 IP 后请求服务器上的资源</li><li>服务器返回请求的资源</li></ol></blockquote><p>随着业务的扩展，用户可能遍布全国或者全世界，如果都去访问这一个服务器，那服务的压力肯定比较大，较远地区的用户访问，响应也会比较慢，甚至并发较大会宕机等等一系列问题。<br>使用 CDN 就能解决这些问题。<br>###CDN 实现原理<br>CDN 说白了就是在世界各地部署新的服务器，把源服务器上的静态文件在这些新的服务器镜像上存一份镜像，当有人访问网站时，通过智能 DNS 解析出哪个服务离用户最近，然后把这个服务器的 ip 返回给请求方，这时请求方请求的就是最近的服务，从而提高响应速度，提高用户体验。</p><p><img src="https://upload-images.jianshu.io/upload_images/1348523-2d5f6bc9bb0dd486.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CDN服务部署原理.jpg"></p><h3 id="智能-DNS"><a href="#智能-DNS" class="headerlink" title="智能 DNS"></a>智能 DNS</h3><p>CDN 的服务是弄好了，但是请求的时候，如果用户的最终请求还是发到了一个服务器上，那各地的镜像服务就白弄了。需要让客户真正访问最近的服务才能起到作用。<br>这如何做呢？这就是智能 DNS 的作用。<br>可参考下图，当发出请求时，第一步仍是需要通过 DNS 服务器解析域名，但是这时 DNS 服务器并没有直接解析到响应的 IP 地址，而是解析到了智能 DNS 服务器，智能 DNS 服务器判断用户访问离哪个服务器最近，就把最近的服务器 IP 地址返回。<br>智能 DNS 服务器是由 CDN 服务商提供的，因此可以在智能 DNS 服务器上做很多工作，除了判断最近的服务器之外，还可以做负载均衡等等。</p><p><img src="https://upload-images.jianshu.io/upload_images/1348523-d322f8943883be34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cdn加速的web请求过程.jpg"></p><h3 id="CDN-按内容可分为如下几类："><a href="#CDN-按内容可分为如下几类：" class="headerlink" title="CDN 按内容可分为如下几类："></a>CDN 按内容可分为如下几类：</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-77cd93a6d5f1d570.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按内容分类.jpg"></p><h3 id="网页加速"><a href="#网页加速" class="headerlink" title="网页加速"></a>网页加速</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-1c0b8bfec5d4db57.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网页加速.jpg"></p><h3 id="流媒体加速"><a href="#流媒体加速" class="headerlink" title="流媒体加速"></a>流媒体加速</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-659b347b671eb510.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流媒体加速.jpg"></p><p>视频文件存储之前会被流媒体服务进行切片处理，如途中的 1.ts、2.ts 等就是切片后的流媒体文件，plist.xml 记录了流媒体文件的信息。这些文件几乎是不变的，所以使用 cdn 非常合适。并且很多视频在被访问时，通常只会看开头的部分，所以切片后可以大大的提高响应速度。</p><h3 id="大文件加速"><a href="#大文件加速" class="headerlink" title="大文件加速"></a>大文件加速</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-7c790d6d2e8fd855.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="大文件加速.jpg"></p><h3 id="应用协议加速"><a href="#应用协议加速" class="headerlink" title="应用协议加速"></a>应用协议加速</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-23fa4cedc7da5e16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用协议加速.jpg"></p><p>这种比较常见于使用 BT 下载工具。<br>比如当下载一个 rar 的文件时，如果通过浏览器下载，可能受目标服务器带宽的限制，最大只能下载 500k，但是如果通过 BT 下载加速工具后，下载工具可能已经提前把需要下载文件下载到了代理服务器中，用户只需从代理服务器上直接下载即可，而代理服务器的带宽往往要远远大于原始服务器，以此提高下载速度。<br>此外当代理服务器中没有这个文件时，会同时使用多台代理服务器同时下载这个文件，并同时传给用户，以此提高下载速度。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>网站服务的客户群体从独立区域扩张到全国范围，而自身服务器不<br>足以覆盖全网用户，导致部分地区用户访问网站速度慢，到达率不高。<br>•节省开支<br>•不％要考虑未来追加增 M 服务器<br>•加速效果更加明显<br>•覆盖范围更广</li><li>网站已经实现静态动态资源分离，且静态资源服务器能力达到极限， 需要通过增加服务器硬件设备才能解决问题的。<br>•节省开支<br>•比自己搭建反向代理简单方便<br>•不需要对当前业务代码进行任何修改<br>•不需要考虑未来追加增 M 服务器<br>•加速效果更加明显<br>•大幅度降低本地静态资源服务器压力</li><li>网站频繁遭到 DDoS 攻击、CC 攻击、DNS 劫持，导致用户体验差、网络堵塞、无法提供正常服务<br>•提高网站安全性<br>•保证用户访问到达率 4.网站用户跨多个丨 SP (电信、联通、移动、铁通、长城），而自身服务器在其中一个机房的<br>•提高用户访问速度<br>•减少因运营商通道堵塞导致的访问失败</li></ol><h3 id="CDN-推送类型"><a href="#CDN-推送类型" class="headerlink" title="CDN 推送类型"></a>CDN 推送类型</h3><ol><li>主动推送<br>就是把源服务器上的资源主动推送到各个镜像服务器。</li><li>被动获取<br>镜像服务器上没有静态资源，当用户第一次访问时，镜像服务器会去源服务器上拉取资源，然后换成到本地，当用户第二次访问时，就是直接访问的 cdn 服务。</li></ol><h3 id="CDN-防止-DDOS-攻击原理"><a href="#CDN-防止-DDOS-攻击原理" class="headerlink" title="CDN 防止 DDOS 攻击原理"></a>CDN 防止 DDOS 攻击原理</h3><p><strong>节点承受能力强大</strong></p><p>我们知道网站在访问过程中，是具有不确定因素的。也就是说，很有可能在一段时间内，会有大量的访问流量，这种突出情况的出现，如果没有强大的承载能力的话，是很容易使网络瘫痪的。而 cdn 就拥有强大的带宽，每个节点可以承受住大量的访问。因此可以保证网站的运行稳定。网站运行稳定了，没有漏洞了，在一定程度上是可以抵制 ddos 攻击。</p><p><strong>智能分配机制提升网站攻击难度</strong></p><p>抗攻击 cdn 之所以能有效防止 ddos 攻击，主要在于它的智能化。当有 ddos 攻击时，它会将整个系统将被攻击的流量分散开来。一是节省了<a href="http://www.enkj.com/" target="_blank" rel="noopener" title="服务器是指在互联网数据中心中存放网站的服务器。主要用于网站的互联网中的发布、应用，是网络应用的基础硬件设施。">服务器</a>的压力，二是增强了网站的工具难度。三是为服务器管理人员提供了补救的时间。所以使用这种技术可以有效的防止 ddos 攻击，增强网站的安全性能。</p><p><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">DDOS 攻击的原理讲解可以参考阮一峰老师的文章</a></p><p>相关视频教程：<br><a href="https://edu.51cto.com/course/14977.html" target="_blank" rel="noopener">https://edu.51cto.com/course/14977.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端js使用crypto-js进行des加密</title>
      <link href="/2020/01/09/%E5%89%8D%E7%AB%AFjs%E4%BD%BF%E7%94%A8crypto-js%E8%BF%9B%E8%A1%8Cdes%E5%8A%A0%E5%AF%86/"/>
      <url>/2020/01/09/%E5%89%8D%E7%AB%AFjs%E4%BD%BF%E7%94%A8crypto-js%E8%BF%9B%E8%A1%8Cdes%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h3><p>我使用的 react 进行开发，请求数据时，需要把一些常用参数放到 header 中传给服务端，但是由于以前老接口定义的规则，因此需要也这么干。 ###使用的加密库<br>我使用是<code>cryptos-js</code><a href="https://github.com/brix/crypto-js" target="_blank" rel="noopener">https://github.com/brix/crypto-js</a></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CryptoJS <span class="keyword">from</span> <span class="string">"crypto-js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encryptByDES</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> keyHex = CryptoJS.enc.Utf8.parse(key);</span><br><span class="line">  <span class="keyword">var</span> encrypted = CryptoJS.DES.encrypt(value, keyHex, &#123;</span><br><span class="line">    mode: CryptoJS.mode.ECB,</span><br><span class="line">    padding: CryptoJS.pad.Pkcs7,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> encrypted.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###转换成 16 进制字符串<br>上面的方法返回的是 base64 的字符串，如果需要 16 进制的字符串，则需要进行转换，由于官网写的太简单，也没找到参数配置来决定输出的字符串类型，因此我手动做了转换。<br>由于我们是 16 进制，因为这个浪费了三个小时的时间在调查这个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function encryptByDES(value, key, isHex) &#123;</span><br><span class="line">  if (value &#x3D;&#x3D; &quot;&quot;) return &quot;&quot;;</span><br><span class="line">  var keyHex &#x3D; CryptoJS.enc.Utf8.parse(key);</span><br><span class="line">  var encrypted &#x3D; CryptoJS.DES.encrypt(value, keyHex, &#123;</span><br><span class="line">    mode: CryptoJS.mode.ECB,</span><br><span class="line">    padding: CryptoJS.pad.Pkcs7,</span><br><span class="line">  &#125;);</span><br><span class="line">  const result &#x3D; encrypted.toString();</span><br><span class="line"></span><br><span class="line">  if (isHex) &#123;</span><br><span class="line">    &#x2F;&#x2F; 把base64字符串转成crypto自定义的中间类型</span><br><span class="line">    var words &#x3D; CryptoJS.enc.Base64.parse(result);</span><br><span class="line">    return CryptoJS.enc.Hex.stringify(words);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换的灵感来自源码里面 <a href="https://github.com/brix/crypto-js/tree/develop/docs" target="_blank" rel="noopener">docs</a>/QuickStartGuide.wiki<br>但是在 github 上打开这个文件，和下载下来的源码里面的这个文件内容不一样，我是看的下载下来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var words  &#x3D; CryptoJS.enc.Base64.parse(&#39;SGVsbG8sIFdvcmxkIQ&#x3D;&#x3D;&#39;);</span><br><span class="line">    var base64 &#x3D; CryptoJS.enc.Base64.stringify(words);</span><br><span class="line"></span><br><span class="line">    var words  &#x3D; CryptoJS.enc.Latin1.parse(&#39;Hello, World!&#39;);</span><br><span class="line">    var latin1 &#x3D; CryptoJS.enc.Latin1.stringify(words);</span><br><span class="line"></span><br><span class="line">    var words &#x3D; CryptoJS.enc.Hex.parse(&#39;48656c6c6f2c20576f726c6421&#39;);</span><br><span class="line">    var hex   &#x3D; CryptoJS.enc.Hex.stringify(words);</span><br><span class="line"></span><br><span class="line">    var words &#x3D; CryptoJS.enc.Utf8.parse(&#39;𤭢&#39;);</span><br><span class="line">    var utf8  &#x3D; CryptoJS.enc.Utf8.stringify(words);</span><br><span class="line"></span><br><span class="line">    var words &#x3D; CryptoJS.enc.Utf16.parse(&#39;Hello, World!&#39;);</span><br><span class="line">    var utf16 &#x3D; CryptoJS.enc.Utf16.stringify(words);</span><br><span class="line"></span><br><span class="line">    var words &#x3D; CryptoJS.enc.Utf16LE.parse(&#39;Hello, World!&#39;);</span><br><span class="line">    var utf16 &#x3D; CryptoJS.enc.Utf16LE.stringify(words);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/niejunlei/p/7519170.html" target="_blank" rel="noopener">参看链接</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非对称加密 </tag>
            
            <tag> crypto-js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React高阶组件和Render props</title>
      <link href="/2020/01/09/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8CRender-props/"/>
      <url>/2020/01/09/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8CRender-props/</url>
      
        <content type="html"><![CDATA[<h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><blockquote><p>具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件</p></blockquote><p>高阶组件就是一个函数，里面封装了业务处理逻辑；<br>只要多个组件的<strong>业务逻辑一样</strong>，就可以用一个高阶组件，把逻辑封装起来，进行复用，把组件当做参数传递进来显示就行。</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote><ul><li>是个函数</li><li>组件作为参数，可以有其他参数，比如数据源</li><li>返回一个新组件</li></ul></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当多个组件的处理逻辑一样的时候，可以用高阶组件进行封装。但要注意的是，他们的显示方式，数据源可能是不一样的。</p><blockquote><ul><li>业务逻辑一样</li><li>显示方式和数据源可能不一样</li></ul></blockquote><h3 id="Render-props"><a href="#Render-props" class="headerlink" title="Render props"></a>Render props</h3><p>术语  <a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" target="_blank" rel="noopener">“render prop”</a>  是指一种在 React 组件之间使用一个值为函数的 prop 在 React 组件间共享代码的简单技术。</p><blockquote><p>说白了就是：给组件接受一个<strong>函数</strong><code>props</code>，而这个函数返回的是一个组件。组件使用 props 函数返回的组件进行显示。<br>这样可以在组件外定义显示的内容，组件内的状态数据可以得到重用。</p></blockquote><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>共享状态或一个组件的行为封装到其他需要相同状态的组件中。</p><blockquote><p>说白了就是实现对 state 的重用。</p></blockquote><h3 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h3><p>通过上面的描述，render props 好像做了和高阶组件同样的事情，但又感觉稍有不同，不细心对比，很难说清楚，下面做一个对比。</p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>他们都封装了相同逻辑，实现了重用。但程度不同。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>属性</th><th>高阶组件</th><th>render props</th></tr></thead><tbody><tr><td>本质</td><td>一个函数</td><td>组件的 props</td></tr><tr><td>用途</td><td>封装业务逻辑</td><td>共享 state</td></tr><tr><td>区别</td><td>显示不同，数据源可能不同</td><td>显示不同</td></tr></tbody></table><p>其实<code>render props</code>就是轻量级的高阶组件，他不仅封装了相同的逻辑，连 state 都是一样的，只是显示不同。<br>因此可以轻易的把 render props 组件封装成高阶组件,只要把组件的 render props 函数的组件通过高阶组件参数的方式传递进来就升级成高阶组件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withMouse</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;Mouse render=&#123;mouse =&gt; &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt;&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so easy.</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React新特性--context</title>
      <link href="/2020/01/09/React%E6%96%B0%E7%89%B9%E6%80%A7-context/"/>
      <url>/2020/01/09/React%E6%96%B0%E7%89%B9%E6%80%A7-context/</url>
      
        <content type="html"><![CDATA[<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, createContext &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CountContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leafe</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CountContext.Consumer</span>&gt;</span>&#123;count =&gt; <span class="tag">&lt;<span class="name">h2</span>&gt;</span>count:&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">CountContext.Consumer</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Leafe.contextType = CountContext;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Leafe</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">class App extends Component &#123;</span></span><br><span class="line"><span class="xml">  state = &#123;</span></span><br><span class="line"><span class="xml">    count: 100,</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  onClick = () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    let &#123; count &#125; = this.state;</span></span><br><span class="line"><span class="xml">    this.setState(&#123; count: --count &#125;);</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    const &#123; count &#125; = this.state;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div className="App"&gt;</span><br><span class="line">        &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">          &lt;Middle /&gt;</span><br><span class="line">          &lt;button onClick=&#123;this.onClick&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">        &lt;/CountContext.Provider&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default App;</span></span><br></pre></td></tr></table></figure><p>通过<code>Provider</code>的 value 提供值，在需要使用<code>context</code>值的地方使用<code>Consumer</code>获取，<code>Consumer</code>接收一个函数，函数的第一个参数就是<code>context</code>的值。</p><p>如果有多个 Context，可以声明多个，然后嵌套使用即可，如果每个 context 有自己的名字，那和嵌套顺序无关，如果都使用 provider、consumer 命名，则 consumer 会找最近的 provider。</p><h3 id="contextType"><a href="#contextType" class="headerlink" title="contextType"></a>contextType</h3><p>每次调用都写 Consumer 很麻烦，可以使用 contextType 解决。<br>contextType 声明成组件的<strong>静态属性</strong>，则可以直接使用 context 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leafe</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//static contextType = CountContext;</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 通过this.context直接获取context的值。</span></span><br><span class="line">    <span class="keyword">const</span> count = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>count:&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Leafe.contextType = CountContext;</span><br></pre></td></tr></table></figure><p>上面展示了两种声明方式。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript原型链容易混淆的相关知识</title>
      <link href="/2020/01/09/Append%E5%92%8CAppendChild%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/09/Append%E5%92%8CAppendChild%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><ol><li><code>append</code>是<code>ParentNode</code>的方法</li><li><code>append()</code>允许追加   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" target="_blank" rel="noopener" title="DOMString 是一个UTF-16字符串。由于JavaScript已经使用了这样的字符串，所以DOMString 直接映射到 一个String。"><code>DOMString</code></a>  对象</li><li><code>ParentNode.append()</code> <a href="https://repl.it/FgPh/1" target="_blank" rel="noopener">没有返回值</a>，</li><li><code>ParentNode.append()</code>  可以追加多个节点和字符串，</li></ol><h2 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h2><ol><li><code>AppendChild</code>是<code>Node</code>的方法</li><li><code>Node.appendChild()</code>  只接受  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node" target="_blank" rel="noopener" title="Node 是一个接口，许多 DOM API 对象的类型会从这个接口继承。它允许我们使用相似的方式对待这些不同类型的对象；比如, 继承同一组方法，或者用同样的方式测试。"><code>Node</code></a>  对象。</li><li><code>Node.appendChild()</code>  返回追加的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node" target="_blank" rel="noopener" title="Node 是一个接口，许多 DOM API 对象的类型会从这个接口继承。它允许我们使用相似的方式对待这些不同类型的对象；比如, 继承同一组方法，或者用同样的方式测试。"><code>Node</code></a>  对象。</li><li><code>ParentNode.append()</code>  可以追加多个节点和字符串，而  <code>Node.appendChild()</code>  只能追加一个节点。</li></ol><h3 id="DOMString"><a href="#DOMString" class="headerlink" title="DOMString"></a>DOMString</h3><p>DOMString 就是 js 中的字符串，不是拼接的 html 字符串，如果传递是 html 字符串，html 标签会被当做内容显示出来。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>也就是说，这两个方法添加像 innerHTML 那样的 html 拼接字符串<strong>都没用</strong>。</p><h2 id="Window-和-window-的区别"><a href="#Window-和-window-的区别" class="headerlink" title="Window 和 window 的区别"></a>Window 和 window 的区别</h2><p>Window 是一个接口，是包含 DOM 文档窗口的接口。<br>window 是暴露给 JavaScript 代码的一个全局变量。<br>每个 tab 有自己独立的 window 全局变量，其实就是一个实例。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP的持久化连接和管线化</title>
      <link href="/2020/01/09/HTTP%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%AE%A1%E7%BA%BF%E5%8C%96/"/>
      <url>/2020/01/09/HTTP%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%AE%A1%E7%BA%BF%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是持久化连接"><a href="#什么是持久化连接" class="headerlink" title="什么是持久化连接"></a>什么是持久化连接</h3><p>所谓持久化连接(长连接)，就是当 http 建立了连接通信后，TCP 连接不断开，下次请求可以直接使用，无需再创建 TCP 连接。<br>持久接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><a id="more"></a><h3 id="为什么要用长连接"><a href="#为什么要用长连接" class="headerlink" title="为什么要用长连接"></a>为什么要用长连接</h3><p>发出请求时需要创建 TCP 连接，但是创建 TCP 连接需要三次握手；<br>因为页面上只有一两个请求的页面很少，如果每个请求都创建自己的 TCP 连接，每个都要重复的建立和断开，这非常的浪费服务端资源，并且请求响应时间也相对较长。<br>在这种情况下，长连接就应运而生了。<br>HTTP/1.1 中默认都是长连接，TCP 连接创建后，后面的请求都会使用已创建的 TCP 连接。从而减轻服务端的负载，提高响应时间，加快页面显示速度。</p><p>###管线化<br>所谓管线化，就是不用等待响应可直接发送下一个请求。<br>持久连接使得多数请求以管线化（ pipelining）方式发送成为可能。从前发送请求后需等待并收到响应， 才能发送下一个请求。管线化技术出现后，不用等待响应可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求， 而不需要一个接一个地等待响应了。</p><ul><li>管线化机制通过持久化连接完成，仅 HTTP/1.1 支持此技术</li><li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li><li>初次建立连接时不应启动管线化机制，因为对方(服务器)不一定支持 HTTP/1.1 版本</li><li>管线化不会影响响应到来的顺序，响应的返回顺序并未发生改变</li><li>HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求管线化的请求不失败即可。</li><li>由于上面提到的服务端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不友好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript异步加载的三种方式</title>
      <link href="/2020/01/09/JavaScript%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/01/09/JavaScript%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-defer-——-以前适用于-IE，现在适用于所有主流浏览器"><a href="#1-defer-——-以前适用于-IE，现在适用于所有主流浏览器" class="headerlink" title="1. defer —— 以前适用于 IE，现在适用于所有主流浏览器"></a>1. defer —— 以前适用于 IE，现在适用于所有主流浏览器</h2><p>defer 属性规定是否对脚本进行延迟执行；</p><p>这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发  <code>DOMContentLoaded</code>  事件前执行。如果缺少  <code>src</code>  属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用。对动态嵌入的脚本使用  <code>async=false</code>  来达到类似的效果。</p><p>defer 属性的值只有 defer 一个，即 defer = ‘defer’，可直接写 defer</p><p>用法：在 script 标签里加入 defer 属性即可，适用于所有 script 脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>添加 defer 属性后，js 脚本在所有元素加载完成后执行，而且是按照 js 脚本声明的顺序执行</p><h2 id="2-async-——-h5-新属性"><a href="#2-async-——-h5-新属性" class="headerlink" title="2. async —— h5 新属性"></a>2. async —— h5 新属性</h2><p>async 是否在允许的情况下异步执行该脚本。</p><p>async 的用法和 defer 一样，但 async 只适用于外部引用的脚本，即 script 有 src 属性时才可使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>不同的是，添加 async 属性后，js 脚本是乱序执行的，不管你声明的顺序如何，只要某个 js 脚本加载完就立即执行</p><h2 id="3-动态生成-script-标签"><a href="#3-动态生成-script-标签" class="headerlink" title="3. 动态生成 script 标签"></a>3. 动态生成 script 标签</h2><p>在 js 里创建 script 标签，插入 DOM 中，加载完成后 callback</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  s.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.readyState) &#123;</span><br><span class="line">    s.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//兼容IE</span></span><br><span class="line">      <span class="keyword">if</span> (s.readyState == <span class="string">"complete"</span> || s.readyState == <span class="string">"loaded"</span>) &#123;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//safari chrome opera firefox</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s.src = url;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样所有的 js 脚本都会在 onload 事件后才加载，onload 事件会在所有文件内容（包括文本、图片、CSS 文件等）加载完成后才开始执行，极大的优化了网页的加载速度，提高了用户体验</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextjs+React+KOA-1</title>
      <link href="/2020/01/09/Nextjs+React+KOA-1/"/>
      <url>/2020/01/09/Nextjs+React+KOA-1/</url>
      
        <content type="html"><![CDATA[<h1 id="next-js-koa-笔记"><a href="#next-js-koa-笔记" class="headerlink" title="next.js koa 笔记"></a>next.js koa 笔记</h1><p>nextjs 是自身带有服务器，但它这个服务器只是用于处理 ssr 服务器渲染。像 http 请求数据，数据库连接、session 状态这些操作 nextjs 的这个服务都不处理，所以需要使用 koa 等类似的服务，手动来处理。</p><a id="more"></a><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure><h3 id="next-默认不支持-css-文件"><a href="#next-默认不支持-css-文件" class="headerlink" title="next 默认不支持 css 文件"></a>next 默认不支持 css 文件</h3><blockquote><p>从服务端原理讲解课程中了解到，<code>style-loader</code>无法把<code>css</code>挂载到页面上，因为服务端渲染不生成<code>html</code>文件，所以即使生成了<code>css</code>文件，也没地方挂，服务端返回的直接是 html 字符串。所以需要使用<code>isomorphic-style-loader</code>，使用这个<code>loader</code>，在组件中可以以对象的方式获取到引用的<code>css</code>，然后把<code>css</code>内容放到<code>context</code>的全局对象中，在返回<code>html</code>内容时把全局中的 css 字符串都拼接好，然后拼到<code>html</code>字符串中。</p></blockquote><p>添加 nextjs 的配置文件，在根目录创建<code>next.config.js</code>，使用官网推荐的<code>@zeit/next-css</code><br>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @zeit&#x2F;next-css</span><br></pre></td></tr></table></figure><p>在配置文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const withCss &#x3D; require(&quot;@zeit&#x2F;next-css&quot;);</span><br><span class="line"></span><br><span class="line">if (typeof require !&#x3D;&#x3D; &quot;undefined&quot;) &#123;</span><br><span class="line">  require.extensions[&quot;.css&quot;] &#x3D; file &#x3D;&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; withCss(&#123;&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以在组件中<code>import css</code>文件了，并且生成的是 css 的 chunk 文件并在文件中引用，而不像 style-loader 那样是把 css 内容直接插进 html 中。</p><h3 id="使用-antd"><a href="#使用-antd" class="headerlink" title="使用 antd"></a>使用 antd</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i and --save</span><br></pre></td></tr></table></figure><p>###配置 antd 的按需加载<br>官网推荐了两种方式，一种是使用<code>babel-import-plugin</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .babelrc or babel-loader option</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;import&quot;, &#123;</span><br><span class="line">      &quot;libraryName&quot;: &quot;antd&quot;,</span><br><span class="line">      &quot;libraryDirectory&quot;: &quot;es&quot;,</span><br><span class="line">      &quot;style&quot;: &quot;css&quot; &#x2F;&#x2F; &#96;style: true&#96; 会加载 less 文件 -------注意：ssr这个不能配置</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种是使用绝对路径来引入每个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import DatePicker from &#39;antd&#x2F;es&#x2F;date-picker&#39;; &#x2F;&#x2F; 加载 JS</span><br><span class="line">import &#39;antd&#x2F;es&#x2F;date-picker&#x2F;style&#x2F;css&#39;; &#x2F;&#x2F; 加载 CSS</span><br><span class="line">&#x2F;&#x2F; import &#39;antd&#x2F;es&#x2F;date-picker&#x2F;style&#39;;         &#x2F;&#x2F; 加载 LESS</span><br></pre></td></tr></table></figure><p>第一种使用方便，使用第一种方式，打包的时候，babel 会转换成第二种，所以推荐第一种。</p><h3 id="解决-antd-样式问题"><a href="#解决-antd-样式问题" class="headerlink" title="解决 antd 样式问题"></a>解决 antd 样式问题</h3><p>上面的标注写了，无法配置样式的引入，所以需要在手动来处理。<br>###_app.js<br><code>_app.js</code>是覆盖 nextjs 默认 app 组件的地方。<br>在 pages 文件夹中新建<code>_app.js</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import App from &quot;next&#x2F;app&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入antd的样式，但这样会把所有的样式都引入进来，可以通过配置babel来解决，但是现在支持不好</span><br><span class="line">import &quot;antd&#x2F;dist&#x2F;antd.css&quot;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>这样 andt 的组件就有样式了。</p><p>###前端路由跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#39;next&#x2F;link&#39;</span><br><span class="line"></span><br><span class="line">&lt;Link href&#x3D;&quot;&#x2F;a&quot; title&#x3D;&quot;desc&quot;&gt;</span><br><span class="line">    &lt;Button&gt;click &lt;&#x2F;Button&gt;</span><br><span class="line">&lt;&#x2F;Link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Link 本身是没有标签的（可以 F12 查看），所以需要指定渲染的内容，必须给它传递一个有 onclick 的组件，Link 就是给他的子组件绑定 click 事件，click 事件跳转到指定的路径。并且 Link 只能有一个直接子节点。</p></blockquote><p>####手动跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Router from &#39;next&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Router.push(&#39;a&#x2F;b&#39;)</span><br></pre></td></tr></table></figure><p>###动态路由</p><ul><li>query 参数<br>接收的时候需要用到<code>next/Router</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;withRouter&#125; from &#39;next&#x2F;router</span><br><span class="line"></span><br><span class="line">const A&#x3D;(&#123;router&#125;)&#x3D;&gt;&lt;span&gt;A&#123;router.query.Id&#125;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">export default withRouter(A)</span><br></pre></td></tr></table></figure><ul><li>路由映射<br>使用 as 属性定义显示的方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;LInk href&#x3D;&quot;&#x2F;a?id&#x3D;1&quot; as &#x3D;&quot;&#x2F;a&#x2F;1&quot; &gt;</span><br></pre></td></tr></table></figure><p>这样<code>/a?id=1</code>会被显示成<code>/a/1</code>; 但这有个问题，当刷新的时候就会出现 404，因为这种映射是在前端的，服务端并没有<code>/a/1</code>的资源。<br>因此服务端需要对<code>/a/1</code>的请求做下处理，转换成原来的<code>/a?id=1</code>；使用 koa 的 router</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new Router()</span><br><span class="line">router.get(&#39;&#x2F;a&#x2F;:id&#39;,(ctx)&#x3D;&gt;&#123;</span><br><span class="line">    const id&#x3D;ctx.params.id;</span><br><span class="line">    handle&#x3D;(ctx.req,ctx.res,&#123;</span><br><span class="line">          pathname:&#39;&#x2F;a&#39;,</span><br><span class="line">          query:&#123;</span><br><span class="line">            id</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">ctx.respond&#x3D;false;</span><br><span class="line">&#125;)</span><br><span class="line">server.use(router.routes())</span><br></pre></td></tr></table></figure><h3 id="getInitialProps"><a href="#getInitialProps" class="headerlink" title="getInitialProps"></a>getInitialProps</h3><p>只有放在 pages 文件下的 getInitialProps 才会被调用;具体内容查看官网介绍；</p><ul><li>在页面中获取数据</li><li>在 App 文件中获取数据<br>需要注意的是：<blockquote><p>如果在 getinitialProps 中异步获取数据，当点击 Link 进行跳转时，等到异步数据获取到才会跳转过去，这就会有延迟的问题。点击跳转可能半天才过去。</p></blockquote></li></ul><h3 id="自定义-App"><a href="#自定义-App" class="headerlink" title="自定义 App"></a>自定义 App</h3><p><code>nextjs</code>的<code>app</code>(也就是<code>_app.js</code>)相当于母版、基类的作用。我的理解就是一个高阶组件。pages 文件夹下的每个页面都会经过 App 进行“包装”。<br>app 的作用：</p><blockquote><ul><li>固定 Laout</li><li>保持一些公共的状态</li><li>给页面传入一些自定义数据</li><li>自定义错误处理</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import App, &#123; Container &#125; from &quot;next&#x2F;app&quot;;</span><br><span class="line">import &quot;antd&#x2F;dist&#x2F;antd.css&quot;;</span><br><span class="line"></span><br><span class="line">class MyApp extends App &#123;</span><br><span class="line">  &#x2F;&#x2F;每次页面跳转都会执行这个方法；</span><br><span class="line">  &#x2F;&#x2F;如果组件中也定义了这个方法，则需要在这手动执行,并把返回数据传给组件</span><br><span class="line">  static async getInitialProps(&#123; Component,ctx &#125;) &#123;</span><br><span class="line">    let pageProps;</span><br><span class="line">    if (Component.getInitialProps) &#123;</span><br><span class="line">      pageProps &#x3D; await Component.getInitialProps(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    return pageProps;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; Component就是pages文件夹下的组件</span><br><span class="line">    const &#123; Component, pageProps &#125; &#x3D; this.props;</span><br><span class="line">    &#x2F;&#x2F;需要使用Container进行包裹</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;div&gt;公共部分&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;Component &#123;...pageProps&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Container&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>###自定义 document<br>document 是只有在服务端渲染的时候才会被调用。<br>用来修改服务端渲染的文档内容。<br>一般用来配合第三方 css-in-js 方案使用。<br>创建和_app.js 一样，在 pages 文件夹下创建下划线开头的文件<code>_document.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import Document, &#123; Html, Head, Main, NextScript &#125; from &quot;next&#x2F;document&quot;;</span><br><span class="line"></span><br><span class="line">class MyDocument extends Document &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Html&gt;</span><br><span class="line">        &lt;Head&gt;</span><br><span class="line">          &lt;title&gt;my doc&lt;&#x2F;title&gt;</span><br><span class="line">          &lt;style&gt;&#123;&#96;.myClass&#123; color:red;&#125;&#96;&#125;&lt;&#x2F;style&gt;</span><br><span class="line">        &lt;&#x2F;Head&gt;</span><br><span class="line">        &lt;body className&#x3D;&quot;myClass&quot;&gt;</span><br><span class="line">          &lt;Main&gt;&lt;&#x2F;Main&gt;</span><br><span class="line">          &lt;NextScript &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;body&gt;</span><br><span class="line">      &lt;&#x2F;Html&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MyDocument;</span><br></pre></td></tr></table></figure><h3 id="style-css"><a href="#style-css" class="headerlink" title="style-css"></a>style-css</h3><p>是组件级的，每个组件中的样式不会影响其他组件，组件和组件之间是隔离的，即使定义的是 global 的，也是组件级的。每个组件的元素上会添加一个类似<code>jsx-12342131231</code>的样式，这就是组件隔离的原因所在。并且当组件别卸载时，样式也会被删除，所以不会影响其他组件的样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx&gt;</span><br><span class="line">  &#123;&#96;</span><br><span class="line">    .fontSize &#123;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line">  &#96;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>上面的样式在元素上就会是<code>jsx-32342342 fontSize</code>;<br>但如果同一个页面中的两个子组件都定义了相同的全局样式，还是会影响的（废话）。</p><p>###LazyLoading</p><ul><li>异步加载模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const moment &#x3D; await import(&quot;moment&quot;);</span><br><span class="line">&#x2F;&#x2F;注意：这是要先调用default</span><br><span class="line">const time&#x3D;moment.default(Date.now() - 60 * 1000 * 2).fromNow(),</span><br></pre></td></tr></table></figure><ul><li>异步加载组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import dynamic from &quot;next&#x2F;dynamic&quot;;</span><br><span class="line"></span><br><span class="line">const DynamicDemo &#x3D; dynamic(import(&quot;.&#x2F;DynamicDemo&quot;));</span><br></pre></td></tr></table></figure><p>###next.config.js 的配置<br>这个文件就是让我们来重置 nextjs 的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 编译文件的输出目录</span><br><span class="line">  distDir: &quot;build&quot;,</span><br><span class="line">  &#x2F;&#x2F; 是否给每个路由生成Etag,这是用来进行缓存验证用的。如果ngix有配置，这个可以关闭，提高性能</span><br><span class="line">  generateEtags: true,</span><br><span class="line">  &#x2F;&#x2F; 页面内容缓存策略</span><br><span class="line">  onDemandEntries: &#123;</span><br><span class="line">    &#x2F;&#x2F; 内容在内存中缓存的时长(ms)</span><br><span class="line">    maxInactiveAge: 25 * 1000,</span><br><span class="line">    &#x2F;&#x2F; 同时缓存多少个页面</span><br><span class="line">    pagesBufferLength: 2,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 在pages目录下哪种后缀的文件会被认为是页面</span><br><span class="line">  pageExtensions: [&quot;jsx&quot;, &quot;js&quot;],</span><br><span class="line">  &#x2F;&#x2F; 配置buildId</span><br><span class="line">  generateBuildId: async () &#x3D;&gt; &#123;</span><br><span class="line">    if (process.env.YOUR_BUILD_ID) &#123;</span><br><span class="line">      return process.env.YOUR_BUILD_ID;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回null使用默认的unique id</span><br><span class="line">    return null;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 修改webpack的配置</span><br><span class="line">  webpack(config, options) &#123;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 修改webpackDevMiddleware配置</span><br><span class="line">  webpackDevMiddleware: config &#x3D;&gt; &#123;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 可以在页面上通过 process.env.customKey 获取value</span><br><span class="line">  env: &#123;</span><br><span class="line">    yourKey: &quot;your value&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 下面两个要通过 &#39;next&#x2F;config&#39; 来读取</span><br><span class="line">  &#x2F;&#x2F; 只有在服务器渲染时才会获取的配置</span><br><span class="line">  serverRuntimeConfig: &#123;</span><br><span class="line">    mySecret: &quot;secret&quot;,</span><br><span class="line">    secondSecret: process.env.SECOND_SECRET,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 在服务端渲染和客户端渲染都可以获取的配置</span><br><span class="line">  publicRuntimeConfig: &#123;</span><br><span class="line">    staticFolder: &quot;&#x2F;static&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###redux-devtools-extension 的使用<br>安装后，把 applyMiddleware 传给它的方法即可。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> nextjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextjs+React+KOA-2</title>
      <link href="/2020/01/09/Nextjs+React+KOA-2/"/>
      <url>/2020/01/09/Nextjs+React+KOA-2/</url>
      
        <content type="html"><![CDATA[<p>OAuth 认证方式有多种，但常用的有两种</p><ul><li>Password</li><li>Authorize Code</li></ul><h3 id="Password-方式"><a href="#Password-方式" class="headerlink" title="Password 方式"></a>Password 方式</h3><p>这种方式比较简单，就是把用户名和密码传递给认证平台，认证平台返回 token。<br>比如我们使用<code>github</code>，把在<code>github</code>上注册的用户名密码传给<code>github</code>，<code>github</code>认证后返回<code>token</code>。<br>但这有个很明显的弊端：就是当前系统可以知道你在 github 上的账号密码，比较不安全。</p><h3 id="Authorize-Code"><a href="#Authorize-Code" class="headerlink" title="Authorize Code"></a>Authorize Code</h3><p>这种方式和<code>Password</code>方式最大的区别就是，这个登录是在认证平台(<code>github</code>)提供的登录页面，也就是在<code>github</code>的网站进行登录和验证，验证通过后返回一个<code>code</code>,然后系统拿着这个<code>code</code>再去认证平台获取<code>token</code>。</p><p>这种方式比较安全，当前网站无法接触到你在认证平台上的任何信息。</p><h3 id="Auth-字段"><a href="#Auth-字段" class="headerlink" title="Auth 字段"></a>Auth 字段</h3><ul><li>client_id</li><li>scope</li><li>redirect_uri<br>如果传这个参数，则必须和注册的时候输入的地址完全一样，不然获取不到 code；不传则跳转到注册填写的地址。</li><li>login</li><li>state<br>跳转的时候带上的这个 state 和返回 code 的时候返回的 state 保持一致。</li><li>allow_signup<br>是否允许动态注册，就是如果用户没有注册，则自动注册，然后返回信息。</li></ul><p><a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/" target="_blank" rel="noopener">https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/</a></p><h3 id="请求授权，获取-code"><a href="#请求授权，获取-code" class="headerlink" title="请求授权，获取 code"></a>请求授权，获取 code</h3><p>GET <a href="https://github.com/login/oauth/authorize" target="_blank" rel="noopener">https://github.com/login/oauth/authorize</a><br>链接上可以传上面的 auth 字段参数</p><h3 id="请求-token"><a href="#请求-token" class="headerlink" title="请求 token"></a>请求 token</h3><p>请求 token 时，client_id、client_secret、code 是必须的，<br>redirect_uri、state 不是必须的</p><p>POST <a href="https://github.com/login/oauth/access_token" target="_blank" rel="noopener">https://github.com/login/oauth/access_token</a></p><h3 id="OAuth-Code-如何保证安全"><a href="#OAuth-Code-如何保证安全" class="headerlink" title="OAuth Code 如何保证安全"></a>OAuth Code 如何保证安全</h3><ul><li>一次性的 code<br>code 获取了 token 后就失效了</li><li>id+secret<br>没这两个值，是无法获取 token 的</li><li>redirect_uri<br>如果这个和注册时不一致，就会报错</li></ul><h3 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h3><p>cookie 是存储在客户端，每次请求都会携带它，不管是文件请求还是 api 的请求，服务端可以读取到 cookie 的值。</p><h3 id="登录后让在当前页"><a href="#登录后让在当前页" class="headerlink" title="登录后让在当前页"></a>登录后让在当前页</h3><p>这个实现起来也很简单，就是登录之前先把当前页面的地址存起来，登录成功后再跳转到即可。<br>通过<code>next/router</code>中的<code>withRouter</code>可以获取到当前页面的<code>url</code>地址<br>实现思路有两种：</p><ul><li>在登录事件中，先请求服务器，把 url 地址存起来，然后再跳转到登录页面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onGoToAuth = useCallback(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  axios.get(<span class="string">`prepare-auth?url=<span class="subst">$&#123;router.asPath&#125;</span>`</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">      location.href = publicRuntimeConfig.OAUTH_URL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"prepare-auth failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">server.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path, method &#125; = ctx;</span><br><span class="line">  <span class="keyword">if</span> (path === <span class="string">"/prepare-auth"</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = ctx;</span><br><span class="line">    ctx.session.urlBeforeOAuth = query.url;</span><br><span class="line">    ctx.body = <span class="string">"ready"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>另一种是超链接直接链接过去，在服务端跳转</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&#123;<span class="string">`prepare-auth?url=<span class="subst">$&#123;router.asPath&#125;</span>`</span>&#125;&gt;</span><br><span class="line">  &lt;Avatar sieze=&#123;<span class="number">40</span>&#125; icon=<span class="string">"user"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/a&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">server.use(async (ctx, next) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; path, method &#125; = ctx;</span></span><br><span class="line"><span class="regexp">  if (path === "/</span>prepare-auth<span class="string">") &#123;</span></span><br><span class="line"><span class="string">    const &#123; query &#125; = ctx;</span></span><br><span class="line"><span class="string">    ctx.session.urlBeforeOAuth = query.url;</span></span><br><span class="line"><span class="string">    //ctx.body = "</span>ready<span class="string">";</span></span><br><span class="line"><span class="string">    ctx.redirect(config.github.OAUTH_URL);</span></span><br><span class="line"><span class="string">  &#125; else &#123;</span></span><br><span class="line"><span class="string">    await next();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><h3 id="请求代理"><a href="#请求代理" class="headerlink" title="请求代理"></a>请求代理</h3><p>上一个项目使用的是 express 的 http 代理插件，轻松搞定，这个是纯手写。<br>其实就是根据规则转发请求。</p><h3 id="前端和服务端请求的解决"><a href="#前端和服务端请求的解决" class="headerlink" title="前端和服务端请求的解决"></a>前端和服务端请求的解决</h3><p><code>getInitalProps</code>在客户端和服务端都会执行，当在客户端发起请求时比价好办，上面的代理直接转给了真正的服务服务器。但在服务端执行时，由于写的是相对路径，服务器默认会在自己身上找，那这个请求肯定是找不到的，所以请求是服务端发出的还是客户端发出的，需要区别对待。</p><blockquote><p>上一个项目是通过<code>createStore</code>的第三个参数<code>thunk.withExtraArgument</code>来解决。可参考</p></blockquote><p>这里做的比较直接，直接是在发出请求的时候判断下，是服务端还是客户端，然后做响应的处理，服务端的话，就要以全路径的方式请求。把路径拼全就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isServer = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">"undefined"</span>;</span><br><span class="line"><span class="keyword">const</span> github_base_url = <span class="string">"https://api.github.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">requestGithub</span>(<span class="params">method, url, data, headers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> axios(&#123;</span><br><span class="line">    method,</span><br><span class="line">    url: <span class="string">`<span class="subst">$&#123;github_base_url&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">    data,</span><br><span class="line">    headers,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">&#123; method = <span class="string">"GET"</span>, url, data = &#123;&#125; &#125;, req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"url muste provide."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="keyword">const</span> session = req.session;</span><br><span class="line">    <span class="keyword">const</span> githubAuth = session.githubAuth || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> headers = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (githubAuth.access_token) &#123;</span><br><span class="line">      headers[<span class="string">"Authorization"</span>] = <span class="string">`<span class="subst">$&#123;githubAuth.token_type&#125;</span> <span class="subst">$&#123;githubAuth.access_token&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> requestGithub(method, url, data, headers);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> axios(&#123;</span><br><span class="line">      method,</span><br><span class="line">      url: <span class="string">`/github<span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">      data,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###获取 post 请求的数据<br>使用<code>koa-body</code>插件即可，安装完后在 server 中注册即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server &#x3D; new Koa();</span><br><span class="line">&#x2F;&#x2F;这样就可以通过ctx.request.body来获取post的值</span><br><span class="line">server.use(koaBody());</span><br></pre></td></tr></table></figure><p>在 post 的请求里面，就可以通过<code>ctx.request.body</code>的方式来获取 post 传递的值。</p><h3 id="getInitialProps-的参数为什么和官网的不一样"><a href="#getInitialProps-的参数为什么和官网的不一样" class="headerlink" title="getInitialProps 的参数为什么和官网的不一样"></a>getInitialProps 的参数为什么和官网的不一样</h3><p>今天在做项目时，教程里<code>getInitialProps</code>的参数有<code>ctx</code>参数，而页面的<code>getInitialProps</code>中没有。结果看了下官网给的绑定 redux 的 demo，在绑定 redux 的地方也是有 ctx 的。因为我自定义了_app.js 文件，所以怀疑可能是这引起的。<br>因为所有的页面都会执行 app.js，所以这的定义可能会影响到组件中的功能。<br>看了下我的<code>_app.js</code>中是没有定义<code>getInitialProps</code>，所以各个组件的<code>getInitialProps</code>是默认的，官网上显示<code>getInitialProps</code>默认是没有 ctx 属性的，所以就在<code>_app.js</code>中自定义了<code>getInitialProps</code>，并验证这里是有<code>ctx</code>属性的，所以透传下去，各个组件也就也有<code>ctx</code>属性了。</p><h3 id="getInitialProps返回的对象在组件中获取不到"><a href="#getInitialProps返回的对象在组件中获取不到" class="headerlink" title="getInitialProps返回的对象在组件中获取不到"></a><code>getInitialProps</code>返回的对象在组件中获取不到</h3><p>原因是在<code>_app.js</code>中我自定义了<code>getInitialProps</code>，但是没有把从<code>getInitialProps</code>获取到的值返回方式和接收方式不一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(appContext) &#123;</span><br><span class="line">    <span class="keyword">let</span> pageProps = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (appContext.Component.getInitialProps) &#123;</span><br><span class="line">      pageProps = <span class="keyword">await</span> appContext.Component.getInitialProps(appContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return pageProps;   错误写法</span></span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">pageProps</span>: &#123; ...pageProps &#125; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收是这样的，要保持一致</span></span><br><span class="line">&lt;Component &#123;...pageProps&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="解决路由切换回来-tab-选中丢失情况"><a href="#解决路由切换回来-tab-选中丢失情况" class="headerlink" title="解决路由切换回来 tab 选中丢失情况"></a>解决路由切换回来 tab 选中丢失情况</h3><p>使用<code>next/router</code>提供的 router 功能，把 tab key 的值放到 url 中，然后从 url 中获取 tab key 的值即可。<br>这样切换路由再回来时，url 中是带参数的。</p><h3 id="缓存本页的数据"><a href="#缓存本页的数据" class="headerlink" title="缓存本页的数据"></a>缓存本页的数据</h3><p>由于页面上数据变化不大，因此可以在本页缓存数据，以避免每次点击 tab 都会重新请求数据<br>在页面中声明一个全局变量，存储远程获取的数据，然后在<code>getInitialProps</code>中判断，如果缓存变量中有数据就直接返回不再请求。</p><p>// index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cachedUserRepos;</span><br><span class="line">Index.getInitialProps = <span class="keyword">async</span> (&#123; ctx &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (cachedUserRepos) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userRepos: cachedUserRepos,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> userRepos = <span class="keyword">await</span> api.request(&#123; <span class="attr">url</span>: <span class="string">"/user/repos"</span> &#125;, ctx.req, ctx.res);</span><br><span class="line">  cachedUserRepos = userRepos.data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    userRepos: cachedUserRepos,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这有一个弊端，如果是首页，也就是当<code>getInitialProps</code>是在服务端执行时，全局变量的值会一直存在，即使在新的客户端用新的用户登录，全局变量中的数据仍然存在；这是为什么呢？<br>这是<code>因为全局变量是这个模块的全局变量，并不是Index组件(或方法)的变量，即使重新渲染，原来缓存的数据仍然存在；当nextjs启动服务加载了index.js模块后，这个全局变量就一直存在。</code>我们赋值过后它就一直有值。所以需要判断如果是服务端渲染就不从这个变量中取值，也不给他们赋值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isServer = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">"undefined"</span>;</span><br><span class="line">Index.getInitialProps = <span class="keyword">async</span> (&#123; ctx &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isServer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedUserRepos &amp;&amp; cachedUserStaredRepos) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        userRepos: cachedUserRepos,</span><br><span class="line">        userStaredRepos: cachedUserStaredRepos,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> userRepos = <span class="keyword">await</span> api.request(&#123; <span class="attr">url</span>: <span class="string">"/user/repos"</span> &#125;, ctx.req, ctx.res);</span><br><span class="line">  <span class="keyword">const</span> userStaredRepos = <span class="keyword">await</span> api.request(&#123; <span class="attr">url</span>: <span class="string">"/user/starred"</span> &#125;, ctx.req, ctx.res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isServer) &#123;</span><br><span class="line">    cachedUserRepos = userRepos.data;</span><br><span class="line">    cachedUserStaredRepos = userStaredRepos.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    userRepos: userRepos.data,</span><br><span class="line">    userStaredRepos: userStaredRepos.data,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>模块中的其他全局变量也要注意这个问题的存在！！！</p></blockquote><h3 id="切换-tab-时，url-的-key-参数没有发生变化"><a href="#切换-tab-时，url-的-key-参数没有发生变化" class="headerlink" title="切换 tab 时，url 的 key 参数没有发生变化"></a>切换 tab 时，url 的 key 参数没有发生变化</h3><p>这需要吧 withRouter 放到 connect 外面，放里面就有上面的说的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(connect(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">user</span>: state.user &#125;))(Index));</span><br></pre></td></tr></table></figure><h3 id="第一次服务端获取到的数据没缓存"><a href="#第一次服务端获取到的数据没缓存" class="headerlink" title="第一次服务端获取到的数据没缓存"></a>第一次服务端获取到的数据没缓存</h3><p>第一次服务端获取到的数据没缓存，当第一次切换 tab 时仍重新请求了数据，这可以使用<code>useEffect</code>来解决，第一次页面加载时，如果 props 中有值就缓存起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (userRepos &amp;&amp; userStaredRepos) &#123;</span><br><span class="line">    cachedUserRepos = userRepos;</span><br><span class="line">    cachedUserStaredRepos = userStaredRepos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="使用lru-cache指定缓存策略"><a href="#使用lru-cache指定缓存策略" class="headerlink" title="使用lru-cache指定缓存策略"></a>使用<code>lru-cache</code>指定缓存策略</h3><p>上面的缓存没问题，但是缓存是一直存在的，不会过期，这不是太好，可以通过<code>lru-cache</code>来制定有时效的换成策略。<br>这个使用起来比较简单，查看官网写即可。</p><h3 id="详情页"><a href="#详情页" class="headerlink" title="详情页"></a>详情页</h3><p>查询、翻页等操作都反应到 url 参数中，这样页面进行回退等操作时，能记录上次的状态。</p><blockquote><p>github 限制了列表请求最多只返回 1000 条数据的请求，超过第 1000 条数据的请求就报错不返回了，比如你每页 20 条，最大只能访问 50 页；因为没人会翻在 000 条数据内还找不到要找的库。</p></blockquote><h3 id="客户端数据缓存"><a href="#客户端数据缓存" class="headerlink" title="客户端数据缓存"></a>客户端数据缓存</h3><p>有很多数据是变化不大的，可以针对客户端请求做缓存策略。注意服务端渲染时不要做缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isServer = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">"undefined"</span>;</span><br></pre></td></tr></table></figure><h3 id="转换-base64-编码成可识别文字"><a href="#转换-base64-编码成可识别文字" class="headerlink" title="转换 base64 编码成可识别文字"></a>转换 base64 编码成可识别文字</h3><p>window 全局提供了一个方法可以转换，方法就是<code>atob(content)</code>，但是服务端没这个方法，所以可以安装<code>atob</code>包，在服务端把这个包赋给全局变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> atob = <span class="built_in">require</span>(<span class="string">"atob"</span>);</span><br><span class="line">global.atob = atob;</span><br></pre></td></tr></table></figure><h3 id="转换显示-markdown-文件"><a href="#转换显示-markdown-文件" class="headerlink" title="转换显示 markdown 文件"></a>转换显示 markdown 文件</h3><p><code>markdown</code>文件默认读取出的内容是 base64 字节流，通过<code>atob</code>方法可以转换成它本来的内容，但是特殊符号例如空格仍是<code>&amp;nbsp;</code>,所以仍需转换真正的 html 字符串，通过<code>markdown-it</code>组件可以完成<br>react 做了 xss 攻击处理，所以需要通过下面的方式显示 html 字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把base64转换成了原来的字符串，但是特殊符号还不是html的显示方式</span></span><br><span class="line"><span class="keyword">const</span> content = atob(readme.content);</span><br><span class="line"><span class="comment">// 转换成html的方式显示</span></span><br><span class="line"><span class="keyword">const</span> html = md.render(content);</span><br><span class="line"><span class="comment">// 由于react做了防XSS(跨站脚本攻击)的处理，所以不能直接把html字符串进行显示</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span> <span class="attr">__html:</span> <span class="attr">html</span> &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="markdown-内容中文乱码问题"><a href="#markdown-内容中文乱码问题" class="headerlink" title="markdown 内容中文乱码问题"></a>markdown 内容中文乱码问题</h3><p>需要把 base64 转换 utf8</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64_to_utf8</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">escape</span>(atob(str)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = base64_to_utf8(readme.content);</span><br><span class="line"><span class="keyword">const</span> html = md.render(content);</span><br></pre></td></tr></table></figure><h3 id="图片无法显示问题"><a href="#图片无法显示问题" class="headerlink" title="图片无法显示问题"></a>图片无法显示问题</h3><p>markdown 中的 html 是无法直接显示，通过制定显示 markdown 中的 html 可以解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> md = <span class="keyword">new</span> MarkdownIt(&#123;</span><br><span class="line">  html: <span class="literal">true</span> <span class="comment">/* 显示markdown中的html文件 */</span>,</span><br><span class="line">  linkify: <span class="literal">true</span> <span class="comment">/* 文档中的链接可以点击*/</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>github-markdown-css</code>样式，使 markdown 内容显示更完美</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i github-markdown-css</span><br><span class="line"></span><br><span class="line">import <span class="string">'github-markdown-css'</span></span><br></pre></td></tr></table></figure><h3 id="生成分析文件"><a href="#生成分析文件" class="headerlink" title="生成分析文件"></a>生成分析文件</h3><p>首先 next 对应的插件<code>@zeit/next-bundle-analyzer</code>，然后在<code>next.config.js</code>中进行配置，并设置打包命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = withBundleAnalyzer(</span><br><span class="line">  withCss(</span><br><span class="line">    <span class="comment">// 下面的配置就是使用webpack的分析工具，生成分析文件</span></span><br><span class="line">    analyzeBrowser: [<span class="string">"browser"</span>, <span class="string">"both"</span>].includes(process.env.BUNDLE_ANALYZE),</span><br><span class="line">    bundleAnalyzerConfig: &#123;</span><br><span class="line">      server: &#123;</span><br><span class="line">        analyzerMode: <span class="string">"static"</span>,</span><br><span class="line">        <span class="comment">// 服务端分析文件生成路径</span></span><br><span class="line">        reportFilename: <span class="string">"../bundles/server.html"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      browser: &#123;</span><br><span class="line">        analyzerMode: <span class="string">"static"</span>,</span><br><span class="line">        reportFilename: <span class="string">"../bundles/client.html"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line"> <span class="string">"analyze:browser"</span>: <span class="string">"cross-env BUNDLE_ANALYZE=browser next build"</span></span><br></pre></td></tr></table></figure><h3 id="动态加载不变的文件"><a href="#动态加载不变的文件" class="headerlink" title="动态加载不变的文件"></a>动态加载不变的文件</h3><p>封装了一个 Markdown 文件显示的组件，这个组件的内容是不变的，所以可以动态加载，动态加载的文件的会被 webpack 单独打包，因为它的打包后的 hash 不变，可以方便浏览器缓存，提高体验。</p><h3 id="优化-moment-包"><a href="#优化-moment-包" class="headerlink" title="优化 moment 包"></a>优化 moment 包</h3><p><code>moment</code>中包含很多我们用不上的文件，比如它的国际化文件中包含了很多国家的语言文件，我们只需要中文的，所以只需要加载中文的语言包就行。</p><ul><li>配置<code>webpack</code>忽略<code>moment</code>组件的所有语言包</li><li>在使用<code>moment</code>的地方手动引入要用的语言包</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line">  withCss(&#123;</span><br><span class="line">    webpack(config) &#123;</span><br><span class="line">      config.plugins.push(<span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/));</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的地方</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">"moment"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"moment/locale/zh-cn"</span>;</span><br></pre></td></tr></table></figure><h3 id="去抖动"><a href="#去抖动" class="headerlink" title="去抖动"></a>去抖动</h3><p>做自动匹配查询时，可以使用<code>lodash/debounce</code>来去抖动</p><p>Gatsby</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> nextjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-新特性Hooks</title>
      <link href="/2020/01/09/React-%E6%96%B0%E7%89%B9%E6%80%A7Hooks/"/>
      <url>/2020/01/09/React-%E6%96%B0%E7%89%B9%E6%80%A7Hooks/</url>
      
        <content type="html"><![CDATA[<h3 id="Hook-解决的问题"><a href="#Hook-解决的问题" class="headerlink" title="Hook 解决的问题"></a>Hook 解决的问题</h3><ul><li>state 共享重用(useState)</li><li>class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题(useEffect)</li></ul><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>在前端开发中，经常会听到副作用的这个说法，很多人以为和吃药有副作用是一个意思，其实不是，前端的主要作用就是 data 到 UI 的渲染，所以这里说的副作用就是除了 data 渲染成 UI 以为的其他操作都算是副作用。比如事件绑定，获取数据等等。</p><a id="more"></a><hr><p>useState 是有顺序要求的，并且每次调用，需要调用所有声明过的 useState。</p><blockquote><p>也就是说：调用时，必须按照已有的顺序和数量进行调用。 ###如何避免少调用了 useState<br>可以通过<code>eslint-plugin-react-hooks</code>来帮助检验。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D eslint-plugin-react-hooks</span><br></pre></td></tr></table></figure><p>在 package.json 中增加配置,在顶级增加如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"eslintConfig": &#123;</span><br><span class="line">    "extends": "react-app",</span><br><span class="line">    "plugins": [</span><br><span class="line">      <span class="string">"react-hooks"</span></span><br><span class="line">    ],</span><br><span class="line">    "rules": &#123;</span><br><span class="line">      "react-hooks/rules-of-hooks": "error"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这样有地方写的不符合规则，就会报错。</p><h3 id="useState-使用函数初始化"><a href="#useState-使用函数初始化" class="headerlink" title="useState 使用函数初始化"></a>useState 使用函数初始化</h3><p>有时候，我们需要根据条件去初始化 state，如果先计算好条件，然后在把结果传递给 useState，这样会使计算过程每次渲染都会执行，然而只有第一次初始化是需要用到这些条件判断的，以后的每次执行都是浪费，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultCount = props.defaultCount || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(defaultCount);</span><br></pre></td></tr></table></figure><p>只有第一次从 props 中获取 defaultCount 是有用的，以后的每次渲染这样代码照样执行，但是是没有价值的。<br>可以给 useState 传递函数来初始化，函数的返回值就是默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="function"><span class="params">()</span> =&gt;</span> props.defaultCount || <span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>每次 state 的改变 App 函数都会执行，react 是如何知道每次的调用是不是第一次？<br>useState 的内部机制做了处理。并且在 state 没发生改变的时候，是不会引起新的渲染的。</p></blockquote><h3 id="class-中的-setState-和-useState-更新-state-的区别"><a href="#class-中的-setState-和-useState-更新-state-的区别" class="headerlink" title="class 中的 setState 和 useState 更新 state 的区别"></a>class 中的 setState 和 useState 更新 state 的区别</h3><ul><li>class 组件中的 setState 是用更新的属性和原来的 state 进行合并，然后再更新。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  name: <span class="string">"zhangsan"</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: <span class="string">"lisi"</span> &#125;);</span><br></pre></td></tr></table></figure><p>当通过 setState 只更改 name 时，age 也不会丢失，react 会先用现在发生变化的 state 和原来的 state 进行合并，然后再更新。</p><ul><li>useState 更新 state 是替换原来的 state。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [person, setPerson] = useState(&#123; <span class="attr">name</span>: <span class="string">"zhagnsan"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;);</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">setPerson(&#123; <span class="attr">name</span>: <span class="string">"lisi"</span> &#125;);</span><br></pre></td></tr></table></figure><p>通过上面的更新，原来的 person 会被替换，age 属性丢失了。</p><h3 id="ContextHook"><a href="#ContextHook" class="headerlink" title="ContextHook"></a>ContextHook</h3><p>我们可以通过 Consumer 获取 context 的值，但是每次声明 Consumer 很麻烦，所以有了静态的 contextType,但是 contextType 每个组件只能有一个，如果声明多个，最后一个有效。<br>使用 contexthook 可以轻松解决上面的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = useContext(CountContext);</span><br><span class="line"><span class="keyword">const</span> name = useContext(NameContext);</span><br></pre></td></tr></table></figure><h3 id="memoHook"><a href="#memoHook" class="headerlink" title="memoHook"></a>memoHook</h3><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener">官网解释</a></p><p>useMemo<br>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 。</p><blockquote><p>注意：只要是依赖项改变，就会重新计算。（有时候不要被设置的布尔值给迷惑了）</p></blockquote><p>如果只需要 useMemo 计算一次，第二个参数传空数组即可。<br>useMemo 也可以用于返回一个函数，如果返回的是函数，则可以直接使用 useCallback.第二个参数如果是空数组，则 useCallback 则会只生成的一次函数，即使返回的是箭头函数，也不影响。</p><h3 id="effect-hook"><a href="#effect-hook" class="headerlink" title="effect hook"></a>effect hook</h3><p>React 将按照 effect 声明的顺序依次调用组件中的<em>每一个</em> effect。<br>effect 每次调用都会用一个新的函数，生成一个新的 effect，所以每次调用之前都会清楚之前的。</p><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p><a href="https://zh-hans.reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update" target="_blank" rel="noopener">官网解释</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hooks </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWA笔记</title>
      <link href="/2020/01/09/PWA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/PWA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://lavas.baidu.com/pwa/README" target="_blank" rel="noopener">https://lavas.baidu.com/pwa/README</a></p><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。</p><p>PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p><p>PWA 的主要特点包括下面三点：</p><p>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现<br>体验 - 快速响应，并且有平滑的动画响应用户的操作<br>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面。</p><a id="more"></a><h3 id="Web-App-Manifest"><a href="#Web-App-Manifest" class="headerlink" title="Web App Manifest"></a>Web App Manifest</h3><p>manifest 其实就是一个 json 文件<code>manifest.json</code>。它的作用：</p><ul><li>将 PWA 站点添加至桌面</li><li>设置主屏幕启动时的过渡画面</li><li>隐藏浏览器的相关 UI</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"short_name"</span>: <span class="string">"短名称"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"这是一个完整名称"</span>,</span><br><span class="line">    <span class="attr">"icon"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"src"</span>: <span class="string">"icon.png"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"image/png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span>: <span class="string">"48x48"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"start_url"</span>: <span class="string">"index.html"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件中引用</span></span><br><span class="line">&lt;link rel="manifest" href="./manifest.json"&gt;</span><br></pre></td></tr></table></figure><p>###service worker<br>创建一个注册文件<code>sw-register.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">// 因为service worker需要启动一个新的线程，所以为了避免阻塞进程，在loader事件中执行。可以避免一些低配置的设置扛不住</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">"/sw.js"</span>, &#123; <span class="attr">scope</span>: <span class="string">"/"</span> &#125;)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注册成功</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ServiceWorker registration successful with scope: "</span>, registration.scope);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注册失败:(</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ServiceWorker registration failed: "</span>, err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  navigator.serviceWorker.oncontrollerchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    showToast(<span class="string">"页面已更新！"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (navigator.online) &#123;</span><br><span class="line">    showToast(<span class="string">"网络已断开，内容可能已过期"</span>);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"online"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showToast(<span class="string">"网络已连接"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sw.js 中注册 service worker 的事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听 service worker 的 install 事件</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  event.waitUntil 回调函数 保证里面的所有操作执行完，安装才会结束。</span></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="comment">// 操作 CacheStorage 缓存，使用 caches.open() 打开一个对应缓存空间。</span></span><br><span class="line">        caches.open(<span class="string">'my-test-cache-v1'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 通过 cache 缓存对象的 addAll 方法设置缓存列表</span></span><br><span class="line">            <span class="keyword">return</span> cache.addAll([</span><br><span class="line">                <span class="string">'/'</span>,</span><br><span class="line">                <span class="string">'/index.html'</span>,</span><br><span class="line">                <span class="string">'/main.css'</span>,</span><br><span class="line">                <span class="string">'/main.js'</span>,</span><br><span class="line">                <span class="string">'/image.jpg'</span></span><br><span class="line">            ]);</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;self.skipWaiting()&#125;);</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装成功后就该激活</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="built_in">Promise</span>.all([</span><br><span class="line">            <span class="comment">// 使首次加载的页面可以直接被控制</span></span><br><span class="line">            <span class="keyword">this</span>.clients.claim();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 激活后，获取缓存列表</span></span><br><span class="line">       caches.keys.then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheList</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">                cacheList.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>)</span>&#123;</span><br><span class="line">                      <span class="comment">// 删除不必要的缓存</span></span><br><span class="line">                      <span class="keyword">if</span>(cacheName!==<span class="string">'my-test-cache-v1'</span>)&#123;</span><br><span class="line">                          <span class="keyword">return</span> catches.delete(cacheName)</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">      &#125;);</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>service worker 激活后，就获取了对页面的所有控制权，但是 service worker 只能控制激活后打开的页面，因此首次激活这个 service worker 的页面是无法被控制的，因此如果首次加载的页面也想被 service worker 控制，则需要刷新下页面才行，为了实现首页和激活后打开的页面一样直接就被 service worker 控制，就需要使用<code>this.clients.claim()</code></p><blockquote><p>在 install 中缓存资源，在 activate 中删除没必要的缓存，在 fetch 中获取缓存中的资源，fetch 中也可以缓存资源。</p></blockquote><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><ul><li>Cache only<br>资源直接从缓存中获取，获取不到，则请求失败。该模式假定资源之前已被缓存，可能 install 期间就做了缓存，比较适合静态资源。</li><li>Network only<br>只从网络返回，适合前端用户行为日志大点之类的请求。</li><li>Cache，falling back to Network<br>优先从 cache 返回内容，如果失败则从网络请求。</li><li>Network, falling back to cache<br>优先从网络返回内容，如果失败了则从缓存获取。适用于频繁更新的内容，希望用户总是看到最新的内容。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>避免使用 http 缓存</li><li>最长 24 小时</li><li>避免缓存跨域资源</li></ul><h3 id="工具-workbox"><a href="#工具-workbox" class="headerlink" title="工具 workbox"></a>工具 workbox</h3><p>service worker 的工具<a href="https://github.com/googlechrome/workbox" target="_blank" rel="noopener">https://github.com/googlechrome/workbox</a></p><h3 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h3><ul><li>查看通知权限<br>在控制台输入下面命令，就可以查看当前网站的通知权限</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.permission;</span><br></pre></td></tr></table></figure><p>权限值有三个：</p><blockquote><ul><li>default</li><li>granted</li><li>denied</li></ul></blockquote><ul><li>请求设置通知权限</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.requestPermission().then(<span class="function"><span class="params">permission</span> =&gt;</span> <span class="built_in">console</span>.log(permission));</span><br></pre></td></tr></table></figure><p>requestPermission 静态方法返回的是一个 promise 对象</p><ul><li>发送通知<br>权限设置允许后，就可以发送通知了。<br>Notification 的一个实例，就相当于发送一个通知。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Notification(<span class="string">"this is title"</span>, &#123; <span class="attr">body</span>: <span class="string">"this is content."</span> &#125;);</span><br></pre></td></tr></table></figure><p>###service worker 中发送通知<br>在 service worker 中是不允许弹出提示，所以通知权限默认是 denied，不是 default。<code>（可以在控制台中切换成service worker环境进行测试）</code><br>因为 service worker 控制是整个项目的请求，所以它不知道是哪个页面的通知。另外它也不允许控制 dom。<br>那该如何在 service worker 中发送通知呢？<br>只需要在页面中设置通知权限，然后在 service worker 中发送请求即可。<br>service worker 发送通知和在页面中发送通知不同。在 service worker 中不能把 Notification 当成构造函数来创建通知，使用下面方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.registration.showNotification(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p><code>registration</code>就是注册 service worker 时生成的对象。</p><blockquote><p>删除除 serviceWorker.js 之外的所有文件和文件夹，如果都是文件，可不加-dr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | grep -v serviceWorker.js | xargs rm -dr</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> pwa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React新特性-memo</title>
      <link href="/2020/01/09/React%E6%96%B0%E7%89%B9%E6%80%A7-memo/"/>
      <url>/2020/01/09/React%E6%96%B0%E7%89%B9%E6%80%A7-memo/</url>
      
        <content type="html"><![CDATA[<p>memo 解决在运行时的效率问题。</p><p>memo 其实就是用来解决无状态组件（函数组件）的“purecomponent”功能。</p><p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener">具体可参考官网</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> memo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Taro笔记</title>
      <link href="/2020/01/09/Taro%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/Taro%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li>jsx 语法只能在 render 函数中使用，不支持在其他方法中调用。<br>在 web 开发中，这种使用很常用，但是小程序不支持。</li><li>小程序不支持在事件上直接使用箭头函数的方式绑定事件，为了统一最好使用 bind 方式或者定义函数的时候使用箭头函数，直接调用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面是错误的方式</span><br><span class="line">onClick()&#123;&#125;</span><br><span class="line">&lt;Button onClick&#x3D;&#123;()&#x3D;&gt;&#123;onClick()&#125;&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>为了兼容小程序，给组件传递的属性是函数时，属性需要以 on 开头，比如 onShowName</li><li>组件时间冒泡，使用<code>stopPropagation</code></li><li>环境变量 process.env.TARO_ENV，当执行命令时，<code>npm run dev:h5</code>就已经指定了环境变量 6.像素单位要大写，小写会被转换成 rem，比如<code>font-size:24PX;</code></li><li>为了兼容小程序，引入组件时，组件名字必须和定义的一致，即使使用了<code>export default</code></li></ol><blockquote><p>jsx 中 src 直接写路径，为什么不管用？<br>使用<code>require(&#39;&#39;../img/img.jpg)</code>，打包时图片会被 copy 到打包目录</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> taro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> taro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex换行时元素没有挨着上一行显示</title>
      <link href="/2020/01/09/flex%E6%8D%A2%E8%A1%8C%E6%97%B6%E5%85%83%E7%B4%A0%E6%B2%A1%E6%9C%89%E6%8C%A8%E7%9D%80%E4%B8%8A%E4%B8%80%E8%A1%8C%E6%98%BE%E7%A4%BA/"/>
      <url>/2020/01/09/flex%E6%8D%A2%E8%A1%8C%E6%97%B6%E5%85%83%E7%B4%A0%E6%B2%A1%E6%9C%89%E6%8C%A8%E7%9D%80%E4%B8%8A%E4%B8%80%E8%A1%8C%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>在做 flex 布局时，每行显示三个，超过自动换行，一页显示三行，高度固定；<br>但是当有两行数据时，第二行没有挨着上一行进行显示，而是在下面的空白垂直居中的方式显示了；<br>和上一行的间距较大，设置 align-items 也不行；</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>需要设置<code>align-content:flex-start</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron+react+七牛云开发笔记</title>
      <link href="/2020/01/09/electron+react+%E4%B8%83%E7%89%9B%E4%BA%91%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/electron+react+%E4%B8%83%E7%89%9B%E4%BA%91%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Electron-和-React-双剑合璧做-markdown"><a href="#Electron-和-React-双剑合璧做-markdown" class="headerlink" title="Electron 和 React 双剑合璧做 markdown"></a>Electron 和 React 双剑合璧做 markdown</h1><p>使用 Electrong 、 React 和七牛云做一个在线 markdown。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>使用<code>creact-react-app</code>创建 react，然后在里面添加 electron 的代码和配置即可。<br>react 和 electron 结合，需要启动两个服务，在 electron 的窗口中嵌入 react 启动的页面。</p><h2 id="优化启动命令"><a href="#优化启动命令" class="headerlink" title="优化启动命令"></a>优化启动命令</h2><ol><li>一个命令窗口启动项目</li><li>当 react 启动后再启动 electron</li><li>关闭 create-react-app 启动时自动打开浏览器的功能</li></ol><h3 id="一个命令窗口启动项目"><a href="#一个命令窗口启动项目" class="headerlink" title="一个命令窗口启动项目"></a>一个命令窗口启动项目</h3><p>因为 electron 和 react 需要分别启动，所以每次打开两个命令窗口比较麻烦，可以使用<code>Concurrently</code>插件的来实现这个功能。<br>Concurrently 的优点</p><ol><li>跨平台(window 和 mac 对 npm 原生的多命令同时运行符号&amp;支持不同)</li><li>控制台输出信息友好</li><li>一键停止启动的所有命令</li></ol><h3 id="当-react-启动后再启动-electron"><a href="#当-react-启动后再启动-electron" class="headerlink" title="当 react 启动后再启动 electron"></a>当 react 启动后再启动 electron</h3><p>上面配置完后，一个命令就把 electron 和 react 都启动了，由于是并行的，所以当 electron 启动时会先显示一个白屏，然后等 react 也启动了需要手动刷新一下，react 的页面才会显示出来。我们可以设置让 react 的服务启动后再启动 electron，这个可以使用 wait-on 插件</p><h3 id="禁止-react-自动打开浏览器"><a href="#禁止-react-自动打开浏览器" class="headerlink" title="禁止 react 自动打开浏览器"></a>禁止 react 自动打开浏览器</h3><p>这个是 webpac 的功能，设置自动开发浏览器的选项为 false 即可。这个<code>create-react-app</code>已经帮我们做了处理，只需设置环境变量即可。考虑到跨平台，使用<code>cross-env</code>设置环境变量。</p><h2 id="react-markdown-编辑器"><a href="#react-markdown-编辑器" class="headerlink" title="react-markdown 编辑器"></a>react-markdown 编辑器</h2><p>编辑器地址<a href="https://github.com/RIP21/react-simplemde-editor" target="_blank" rel="noopener">https://github.com/RIP21/react-simplemde-editor</a></p><h3 id="设置-key"><a href="#设置-key" class="headerlink" title="设置 key"></a>设置 key</h3><p>在给编辑器赋值时，如果编辑器的值是根据不同条件显示不同的内容，这时需要设置一个 key，不然即使条件发生变化，页面重新渲染，编辑器也无法读取到新的值。</p><h3 id="扁平化处理"><a href="#扁平化处理" class="headerlink" title="扁平化处理"></a>扁平化处理</h3><p>由于数组在操作时，操作某个元素都需要遍历查找，所以把数组扁平化处理，操作起来更方便。</p><h2 id="检测-electron-是否是开发环境"><a href="#检测-electron-是否是开发环境" class="headerlink" title="检测 electron 是否是开发环境"></a>检测 electron 是否是开发环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install electron-is-dev</span><br><span class="line"></span><br><span class="line">const isDev = require(<span class="string">'electron-is-dev'</span>);</span><br></pre></td></tr></table></figure><h2 id="在-react-中使用-Node-js-的-API"><a href="#在-react-中使用-Node-js-的-API" class="headerlink" title="在 react 中使用 Node.js 的 API"></a>在 react 中使用 Node.js 的 API</h2><p>前面说过，在 electron 的渲染进程中的 js 不仅可以使用前端的各种 API， 我们还可以使用 Node 的 API。</p><blockquote><p>main.js 中启动 electron，并且创建窗口就是运行在主进程中，创建的各个窗口就是渲染进程，窗口中页面引用的 js 就是运行在渲染进程中的 js。</p></blockquote><p>因此我们可以在页面的 js 中直接使用 node 的 api 对本地系统资源进行操作。</p><h3 id="require-的小-bug"><a href="#require-的小-bug" class="headerlink" title="require 的小 bug"></a>require 的小 bug</h3><p>在网页的<code>js</code>中使用<code>require</code>关键字引入<code>node</code>的<code>api</code>，发现获取到的对象是空对象，在<code>electron</code>的<code>issues</code>中知道解决方法，把<code>require</code>改成<code>window.require</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const fs = require('fs')  // 获取不到对象</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">window</span>.require(<span class="string">"fs"</span>);</span><br></pre></td></tr></table></figure><p>原因：</p><blockquote><p>原来在写 demo 时没遇到这个问题，为什么现在遇到了呢？<br>因为原来写 demo 比较简单，使用最原始的方式写，运行是没问题的。但是现在的环境是使用了 react，因为我们的 react 使用了 webpack 进行了打包，webpack 会对 es6 的 import 和 require 都进行处理，webapck 对引入文件的寻找有自己的路径方式，所以当我们使用 require 的方式引入 fs 时，被 webpack 编译截胡了，所以就找不到对象了，前面加上 window,webpack 知道是原生的对象，就不做处理了。</p></blockquote><h3 id="查看-electron-的-node-版本"><a href="#查看-electron-的-node-版本" class="headerlink" title="查看 electron 的 node 版本"></a>查看 electron 的 node 版本</h3><p>这里要用到 promise 版本的 fs，但是这个是 node 10 版本后推出的，所以要确保 node 的版本是 10 之后，但是这里说的 node 版本不是本地安装的版本，而是 electron 中使用的版本。<br>如何查看 electron 的版本呢？<br>这个在 electron 给的 demo 中已经显示了各个工具的版本号，在页面的 js 中调用环境变量查看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.versions.node;</span><br></pre></td></tr></table></figure><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>node 提供了操作本地文件的功能，我们可以使用 node 提供的 api 把内容写入到本地系统的文件中。<br>electron 的主进程提供的<code>app.getPath(name)</code>方法可以方便获取本地一些目录路径，具体参考官网文档介绍。<br>我们把文件写入到这些路径中。</p><p>网页数据持久化<br>文档的的内容我们通过 node api 把文件写入到了本地磁盘上，网页上的数据列表我们也需要持久化，以避免刷新一下网页数据就没了;<br>我们插件<code>electron-store</code>，其实这个插件也是把数据存储在本地磁盘，数据存储在一个 json 文件中。</p><p>electron-store 的数据存储路径是通过<code>app.getPath(&#39;userData&#39;)</code>获取的，根据 electron 官网，mac 对应的是<code>~/Library/Application Support</code>文件夹中。<br>进入上面的文件夹，会看到一个和你项目同名的文件夹，<code>electron-store</code>的数据就存储在这个文件夹中。文件默认名字叫<code>config</code>，可以根据参数<code>name</code>来更改。</p><blockquote><p>mac 系统，在终端中进入包含空格的文件夹的方式</p><ol><li>使用*代替空格</li><li>使用反斜杠转义空格</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Application\ Support</span><br><span class="line">cd Application*Support</span><br></pre></td></tr></table></figure></blockquote><h2 id="菜单功能"><a href="#菜单功能" class="headerlink" title="菜单功能"></a>菜单功能</h2><p>菜单也是主进程提供的 api，根据 electron 提供的 Menu 和 MenuItem 来创建菜单。</p><h3 id="实现上线文菜单功能"><a href="#实现上线文菜单功能" class="headerlink" title="实现上线文菜单功能"></a>实现上线文菜单功能</h3><p>所谓上下文菜单，主要是右键菜单。当点击右键时，触发上下文菜单事件<code>contextmenu</code>事件，然后把通过 Menu 创建的菜单实例传递给要显示的窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> menu = <span class="keyword">new</span> Menu();</span><br><span class="line">menuItems.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  menu.append(<span class="keyword">new</span> MenuItem(item));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onOpenContextMenu = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断点击的元素是否在指定的元素范围内</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(targetSelctor).contains(e.target)) &#123;</span><br><span class="line">    clickedElemnt.current = e.target;</span><br><span class="line">    <span class="comment">// 指定菜单在哪个窗口中显示</span></span><br><span class="line">    menu.popup(&#123; <span class="attr">window</span>: remote.getCurrentWindow &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 打开上下文菜单时触发</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"contextmenu"</span>, onOpenContextMenu);</span><br></pre></td></tr></table></figure><h3 id="获取菜单的数据"><a href="#获取菜单的数据" class="headerlink" title="获取菜单的数据"></a>获取菜单的数据</h3><p>在点击菜单时，可以根据点击的元素来获取元素的属性，比如 id，但是我们可能需要更多的信息，我们可以自定义一些属性，然后通过节点的属性获取；这是老方法，html5 提供了更方便更规范的方法，即设置<code>data-*</code>属性，通过这种方式设置的属性，可以通过<code>HTMLElement.dataset</code>来获取他们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"user"</span> data-id=<span class="string">"1234567890"</span> data-user=<span class="string">"johndoe"</span> data-date-<span class="keyword">of</span>-birth&gt;</span><br><span class="line">  John Doe</span><br><span class="line">&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var el = document.querySelector("#user");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ el.id ===&gt; 'user'</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ el.dataset.id ===&gt; '1234567890'</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ el.dataset.user ===&gt; 'johndoe'</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ el.dataset.dateOfBirth ===&gt; ''</span></span><br></pre></td></tr></table></figure><h3 id="判断元素是否用了某个样式-class"><a href="#判断元素是否用了某个样式-class" class="headerlink" title="判断元素是否用了某个样式 class"></a>判断元素是否用了某个样式 class</h3><p>以前用 jquery，可以很方便做各种操作，其实现在原生的也提供了很多方便的 api。<br>元素的 classList 就是元素所有的样式类，并且提供了多种操作方法，判断是否包含某一个，可以简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.classList.contains(<span class="string">"classname"</span>); <span class="comment">// true | false</span></span><br></pre></td></tr></table></figure><h2 id="menu-的事件"><a href="#menu-的事件" class="headerlink" title="menu 的事件"></a>menu 的事件</h2><p>menu 触发的事件是在主进程中触发的，所以 menu 事件需要通过进程之间的通信方式来通信。<br>同一进程之间的通信使用 ipcMain 来进行，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发</span></span><br><span class="line">ipcMain.emit(<span class="string">"事件名"</span>);</span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">ipcMain.on(<span class="string">"事件名"</span>, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>在<code>menuTemplate</code>中的 menu 事件都发送到了 main 中进行处理，其实可以直接处理，然后把结果返回给渲染进程。这里是为了统一。</p><p>主进程和渲染进程之间的通信是通过 主窗口的实例(mainWindow) 和 ipcRender，在主进程中使用 mainWindow.webContents.send()，在渲染进程中使用 ipcRender；<br>在渲染进程中，即在页面中可以直接使用 node 的 api 进行业务处理。</p><h2 id="应用程序打包"><a href="#应用程序打包" class="headerlink" title="应用程序打包"></a>应用程序打包</h2><p>为缓解 Windows 下路径名过长的<a href="https://github.com/nodejs/node-v0.x-archive/issues/6960" target="_blank" rel="noopener">问题</a>， 略微加快一下 <code>require</code> 的速度以及<strong>隐藏你的源代码</strong>，你可以选择把你的应用打包成 <code>asar</code> 档案文件，这只需要对你的源代码做一些很小的改动。<br>大部分用户可以毫不费力地使用这个功能，因为它在 electron-packager,、electron-forge 和 electron-builder 中都得到了支持，开箱即用。</p><h3 id="asar-的优点"><a href="#asar-的优点" class="headerlink" title="asar 的优点"></a>asar 的优点</h3><ol><li>缓解 Windows 下路径名过长的问题</li><li>略微加快 require 的速度</li><li>隐藏源代码</li></ol><h3 id="打包-View-层的代码"><a href="#打包-View-层的代码" class="headerlink" title="打包 View 层的代码"></a>打包 View 层的代码</h3><p>因为项目里面使用的 react，不能在浏览器中直接使用，所以需要使用 webpack 打包成浏览器能识别的静态资源，这和常规打包没什么区别，直接使用<code>create-react-app</code>提供的 build 命令即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>设置加载路径，把 electron 的加载页面路径设置成打包后文件的路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urlLocation = isDev</span><br><span class="line">  ? <span class="string">"http://localhost:3000/"</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">"./build/index.html"</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><h3 id="electron-builder"><a href="#electron-builder" class="headerlink" title="electron-builder"></a>electron-builder</h3><p>我们使用 electron-builder 来打包。</p><ol><li><p>配置<br>electrong-builder 的配置比价简单，直接在 package.json 中进行配置。<br>在根节点增加<code>build</code>项，在里面写相关的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>: &#123;</span><br><span class="line"> <span class="string">"appId"</span>: <span class="string">"electron-react-markdown"</span>,</span><br><span class="line"> <span class="string">"productName"</span>: <span class="string">"七牛云文档管理"</span>,</span><br><span class="line"> <span class="string">"copyright"</span>: <span class="string">"Copyright @ 2019-12 $&#123;author&#125;"</span>,</span><br><span class="line"> <span class="comment">// 这个默认设置了入口文件的名字，关闭会用我们自己的入口文件</span></span><br><span class="line"> <span class="string">"extends"</span>: <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 如果不同平台需要单独配置相关参数，可以增加相关的配置，比如下面是mac系统的配置</span></span><br><span class="line"> <span class="string">"mac"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增加 build 命令</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="string">"pack"</span>: <span class="string">"electron-builder --dir"</span>,</span><br><span class="line">  <span class="string">"dist"</span>: <span class="string">"electron-builder"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>pack 和 dist 的区别<br>pack 生成的是安装包安装后生成的那些文件。<br>dist 生成安装包</p><p>增加钩子<br>我们可以在执行命令的时候，指定先执行哪个命令，这个是 npm 提供的钩子；<br>方式是把相关命令的前面加上<code>pre</code>即可，比如下面是执行 pack 的时候，先执行 build</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"pack"</span>: <span class="string">"electron-builder --dir"</span>,</span><br><span class="line"><span class="string">"prepack"</span>:<span class="string">"npm run build"</span></span><br></pre></td></tr></table></figure><h3 id="自定义需要打包的文件"><a href="#自定义需要打包的文件" class="headerlink" title="自定义需要打包的文件"></a>自定义需要打包的文件</h3><p>build 的 files 字段配置了打包时，哪些文件会被打包到程序中。它有自己的默认配置，但是一旦自定义了这个字段，默认的就不起作用了。<br>这里需要指定的文件是在 electron 进程中用到的文件，react 中用到的都已打包到 build 目录中，只需指定 build 目录即可。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"build":&#123;</span><br><span class="line">    "files": [</span><br><span class="line">      "build/**/*",</span><br><span class="line">      "node_modules/**/*",</span><br><span class="line">      "settings/**/*",</span><br><span class="line">      "package.json",</span><br><span class="line">      "main.js",</span><br><span class="line">      "./menuTemplate.js",</span><br><span class="line">      "./src/AppWindow.js",</span><br><span class="line">      <span class="string">"./src/utils/QiNiuManager.js"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>files 的配置说明</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">// match all files|| 匹配所有文件</span></span><br><span class="line">  <span class="string">"**/*"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// except for js files in the foo/ directory || 不匹配foo文件夹下js，其他文件仍能匹配</span></span><br><span class="line">  <span class="string">"!foo/*.js"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unless it's foo/bar.js || 匹配foo/bar.js文件</span></span><br><span class="line">  <span class="string">"foo/bar.js"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h3><p>在 package.json 中设置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"homepage": "./",</span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>通过上面的配置，现在执行打包命令，因为 pack 生成的就是安装后的文件，所以可以进入文件夹直接打开使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run pack</span><br></pre></td></tr></table></figure><h2 id="查看安装包内容"><a href="#查看安装包内容" class="headerlink" title="查看安装包内容"></a>查看安装包内容</h2><p>我用的是 mac 系统，点击生成的安装包，右键–查看包内容，可以看到一个 Contents 文件夹，文件中包含了所有的文件。</p><h2 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h2><p>配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "appId": "electron-react-markdown",</span><br><span class="line">  "productName": "七牛云文档管理",</span><br><span class="line">  "copyright": "Copyright @ 2019-12 $&#123;author&#125;",</span><br><span class="line">  "extends": null,</span><br><span class="line">  "files": [</span><br><span class="line">    "build/**/*",</span><br><span class="line">    "node_modules/**/*",</span><br><span class="line">    "settings/**/*",</span><br><span class="line">    "package.json",</span><br><span class="line">    "main.js",</span><br><span class="line">    "./menuTemplate.js",</span><br><span class="line">    "./src/AppWindow.js",</span><br><span class="line">    <span class="string">"./src/utils/QiNiuManager.js"</span></span><br><span class="line">  ],</span><br><span class="line">  "directories": &#123;</span><br><span class="line">    <span class="comment">// 指定静态资源的路径</span></span><br><span class="line">    "buildResources": "assets"</span><br><span class="line">  &#125;,</span><br><span class="line">  "mac": &#123;</span><br><span class="line">    <span class="comment">// mac电脑的应用程序有分类，这里指定安装到哪个分类下</span></span><br><span class="line">    "category": "public.app-category.productivity",</span><br><span class="line">    <span class="comment">// 打出的安装包的名字</span></span><br><span class="line">    "artifactName": "$&#123;productName&#125;-$&#123;version&#125;-$&#123;arch&#125;.$&#123;ext&#125;"</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  "dmg": &#123;</span><br><span class="line">    "background": "assets/appdmg.png",</span><br><span class="line">    "icon": "assets/icon.icns",</span><br><span class="line">    "iconSize": 100,</span><br><span class="line">    "contents": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">380</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">280</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">280</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 打开的安装窗口大小</span></span><br><span class="line">    "window": &#123;</span><br><span class="line">      "width": 500,</span><br><span class="line">      "height": 500</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "win": &#123;</span><br><span class="line">    <span class="comment">// 这里指定打包出两种类型的安装包</span></span><br><span class="line">    "target": [</span><br><span class="line">      "msi",</span><br><span class="line">      <span class="string">"nsis"</span></span><br><span class="line">    ],</span><br><span class="line">    "icon": "assets/icon.ico",</span><br><span class="line">    "artifactName": "$&#123;productName&#125;-Web-Setup-$&#123;version&#125;.$&#123;ext&#125;",</span><br><span class="line">    "publisherName": "温木"</span><br><span class="line">  &#125;,</span><br><span class="line">  "nsis": &#123;</span><br><span class="line">    "allowToChangeInstallationDirectory": true,</span><br><span class="line">    "oneClick": false,</span><br><span class="line">    "perMachine": false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加打包前执行 build</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"predist":"npm run build"</span><br></pre></td></tr></table></figure><p>打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dist</span><br></pre></td></tr></table></figure><p>这就会根据你的环境生成对应的包，比如你是 mac 则生成 mac 对应的安装包。</p><h2 id="优化安装包"><a href="#优化安装包" class="headerlink" title="优化安装包"></a>优化安装包</h2><p>上面虽然成功生成了安装包，但是体积比较大，通过生成的文件我们知道，主要有两个文件我们可以优化，一个是 app.asar,一个是 electron.asar，app.asar 中是我们业务程序的代码，electron.asar 是系统的，我们没法改变。<br>那能优化就是 app.asar.它包含的内容如下：</p><p>.<br>├── build<br>├── main.js<br>├── menuTemplate.js<br>├── node_modules<br>├── package.json<br>├── settings<br>└── src</p><blockquote><p>asar extract app.asar tmp_app<br>使用上面的命令，把 app.asar 中的内容“解压”到 tmp_app 文件夹中<br>使用<code>tree -L 1</code>查看目录结构</p></blockquote><p>我们知道<code>node_modules</code>中<code>react</code>使用到的安装包，其实已经打包到了<code>build</code>文件夹中，是不需要再进行打包的。<br>由于<code>electron-build</code>不会对开发依赖项进行打包，因此可以把不需要打包的依赖项移动到开发依赖项中(开发过程中可能不能这么干，只能在打包的时候这么做)。</p><p>优化打包文件引入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"files": [</span><br><span class="line">  "build/**/*",</span><br><span class="line">  "node_modules/**/*",</span><br><span class="line">  "settings/**/*",</span><br><span class="line">  "package.json",</span><br><span class="line">  "main.js",</span><br><span class="line">  "./menuTemplate.js",</span><br><span class="line">  "./src/AppWindow.js",</span><br><span class="line">  <span class="string">"./src/utils/QiNiuManager.js"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>现在配置了很多个打包文件，其实需要引入的就两类文件，一个是前端的，一个是 electron 的。前端的都已打包到 build 文件夹中。<br>而 electron 的 js 代码我们是一个一个单独引用的。我们也可以把他们打包到一起，这样就可以只引入一个文件了。</p><p>1.新建一个 webpack 的配置文件 webpack.config.js<br>webpack.config.js 是 webpack 的默认配置文件，因为前端是通过编写的代码进行打包的，所以并没有使用到这个配置文件，所以我们新建一个也不会对前端打包造成影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  target: <span class="string">"electron-main"</span>,</span><br><span class="line">  entry: <span class="string">"./main.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"./build"</span>),</span><br><span class="line">    filename: <span class="string">"main.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  node: &#123;</span><br><span class="line">    __dirname: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>配置 target 为<code>electron-main</code></li><li>配置 node 设置<strong>dirname，教程说是</strong>dirname 默认返回一个斜杠，但我测试返回没问题，加不加这个配置都一样。</li></ol><p>增加 build 的命令</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"buildElectron": "webpack",</span><br></pre></td></tr></table></figure><h3 id="electron-代码打包到一起后需要修改的地方"><a href="#electron-代码打包到一起后需要修改的地方" class="headerlink" title="electron 代码打包到一起后需要修改的地方"></a>electron 代码打包到一起后需要修改的地方</h3><ol><li><p>package.json 中的 build 的 files<br>这是只需要设置打包后的 main.js 文件即可，但已配置了 build 目录，所以把 electron 的代码引用都删除即可。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"files": [</span><br><span class="line">  "build/**/*",</span><br><span class="line">  "node_modules/**/*",</span><br><span class="line">  "settings/**/*",</span><br><span class="line">  <span class="string">"package.json"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p>electron 的入口文件<br>electron 默认读取的是 package.json 的 main 字段配置的文件，打包读取的也是这个，但是现在打包需要读取 build 中的 main.js，所以增加 build 的配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"extraMetadata": &#123;</span><br><span class="line">  "main": "./build/main.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样打包的时候就会读取这里指定的文件。</p></li><li><p>修改 npm 的钩子</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"prepack": "npm run build &amp;&amp; npm run buildElectron",</span><br><span class="line">"predist": "npm run build &amp;&amp; npm run buildElectron"</span><br></pre></td></tr></table></figure><ol start="4"><li>修改 main.js 文件<br>因为生产环境 main.js 的路径和前端页面在同一个文件夹下，所以引用路径也发生改变</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urlLocation = isDev ? <span class="string">"http://localhost:3000/"</span> : <span class="string">`file://<span class="subst">$&#123;join(__dirname, <span class="string">"./index.html"</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>把生产环境依赖项移动到开发依赖项中</li></ol><h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2><p>自动更新就是当每次打开软件时，会和远程存储下载资源的版本进行对比，如果有新版本，就提示自动更新。<br>既然要自动更新，那首先设置资源存储的地方并自动发布。electron-builder 提供了自动发布的功能，并且支持很多平台，其中我们喜欢的 GitHub 就在之列。具体详情可在官网的<a href="https://www.electron.build/configuration/publish" target="_blank" rel="noopener">Publish</a>模块查看。</p><h3 id="自动发布"><a href="#自动发布" class="headerlink" title="自动发布"></a>自动发布</h3><ol><li>指定发布使用的平台<br>在<code>electron-builder</code>的配置项中增加<code>publish</code>配置。由官网可看出，<code>publish</code>的值可以是<code>String | Object | Array&lt;Object | String&gt;</code>，其实如果设置了 GitHub 的 token(GH_TOKEN)，默认使用的就是 GitHub 平台。可以同时指定多个平台。<br>在 package.json 中增加<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>:&#123;</span><br><span class="line">     <span class="string">"publish"</span>: [<span class="string">"github"</span>, <span class="string">"bintray"</span>],</span><br><span class="line">     <span class="comment">// 或者如下</span></span><br><span class="line">     <span class="string">"publish"</span>: [&#123;<span class="attr">provider</span>: <span class="string">"github"</span>&#125;, &#123;<span class="attr">provider</span>: <span class="string">"bintray"</span>&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置发布命令<br>GitHub 的下载资源都在 release 模块，<code>electron-builder</code>提供了往 GitHub 的 release 模块推送静态资源的方式。<br>官网给出了，使用<code>npm script</code>只需要增加<code>release</code>命令即可。这样每次生成安装包后，自动发布到 GitHub 上的 release。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  ......</span><br><span class="line">  "release": "electron-builder",</span><br><span class="line">  "prerelease": "npm run build &amp;&amp; npm run buildElectron"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>上面配置完，还需要 github 的 token，不然 push 不上去。<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">获取 token 的地址</a><br>点击头像-&gt;设置-&gt;Developer settings-&gt;Personal access tokens<br>然后生成一个 <code>token</code> 传给 <code>electron-builder</code> 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"release"</span>: <span class="string">"cross-env GH_TOKEN=d728e4bd5fefe3ba74881c0171284b85bb95cd6d electron-builder"</span>,</span><br></pre></td></tr></table></figure><p>到目前为止，所有的配置就完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run release</span><br></pre></td></tr></table></figure><p>执行后，不仅重新生成了安装包，并且上传到了 GitHub 上，在项目的 release 模块可看到，生成的安装包文件都被上传了。<br>这时，上传的文件还是 draft 状态，也就是草稿状态，可以点击编辑，编写一些描述，然后点击发布，这时就成了发布状态；也可以点击保存成 draft。</p><h3 id="自动更新-1"><a href="#自动更新-1" class="headerlink" title="自动更新"></a>自动更新</h3><p>electron 本身也提供了程序更新的方式，但是官网也说了，如果使用 electron-builder 进行打包，可以使用 electron-updater 模块，它不依赖任何服务器并且可以从 S3, GitHub 或者任何其它静态文件存储更新. 这避开了 Electron 内置的更新机制，</p><p>安装 electron-updater</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-udpater --save-dev</span><br></pre></td></tr></table></figure><p>然后在主进程中添加检查更新的代码，重新打包，然后点击生成的安装后文件中的程序，就可以看到效果。注意 GitHub 上的项目需要设置成公共的，私有的是获取不到的。</p><h3 id="开发模式下测试自动更新"><a href="#开发模式下测试自动更新" class="headerlink" title="开发模式下测试自动更新"></a>开发模式下测试自动更新</h3><p>上面的配置都是在开发完后，打包成功后，点击安装包，然后查看效果，比较费劲，出了问题还的盲改后，再打包来看效果，效率比较低。<br>如果能在开发过程中就查看效果，那就很方便了。<br>上面说过，查看打包后自动更新，需要使用 release 命令，使用 dist 是会报错的，因为更新需要一个叫 app-update.yml 的文件告诉它一些更新需要的信息，比如用户名，仓库名等等。。<br>开发模式下，我们可以手动创建这个文件，名字前加上 dev，叫<code>dev-app-update.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">owner:</span> <span class="string">codepandy</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">electron_react_markdown</span></span><br><span class="line"><span class="attr">provider:</span> <span class="string">github</span></span><br><span class="line"><span class="attr">updaterCacheDirName:</span> <span class="string">electron-react-markdown-updater</span></span><br></pre></td></tr></table></figure><p>上面内容是从正式生成的<code>app-update.yml</code>中 copy 的，最后一个可以不要。<br>然后在程序中判断，如果是开发模式，就使用我们创建的<code>dev-app-update.yml</code>配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript原型链容易混淆的相关知识</title>
      <link href="/2020/01/09/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/09/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>讲解一下关于原型链的知识。</p><a id="more"></a><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> <span class="keyword">constructor</span>;</span><br></pre></td></tr></table></figure><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。<br>简单来说就是检查<code>constructor.prototype</code>是否出现在<code>object.__proto__</code>上面。<br>注意：这个对比的不是输入时的参数，而是他们的原型，这也是和<code>isPrototypeOf</code>的区别</p><blockquote><p>听起来是不是很奇怪？为什么是<code>constructor.prototype</code>是否出现在<code>object.__proto__</code>上面，而不是<code>object.__proto__</code>出现在<code>constructor.prototype</code>上面？<br>大家都知道这个是用来判断继承或者一个实例是否是某个类的。<br>这就要想清楚继承的真正含义，别被想当然给误解了。<br>类 A 继承 Z，那么 A 的实例 a 应该都“属于”A 和 Z，也就是 instaceof 都是 true。<br><code>继承其实是子类包含父类，而不是父类包含子类。</code><br>那为什么说子类属于父类呢？<br>这个是从不同概念上来说的，子类属于父类是从抽象的概念上来说的，上面说的包含是从内容上面来说。比如男人女人都属于人类，但是男人包含了所有人类这个层面抽象的所有内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从抽象概念上说：子类是父类的一部分，属于父类。</span><br><span class="line">从内容的角度出发：子类的内容包含了抽象的父类的内容。</span><br></pre></td></tr></table></figure><h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a>isPrototypeOf</h3><p>isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prototypeObj.isPrototypeOf(object)</span><br></pre></td></tr></table></figure><p>检测<code>prototypeObj</code>是否在<code>object</code>的原型链上。</p><blockquote><p>注意：这个做对比时，就是<code>prototypeObj</code>本身，而不是他的原型，这是和<code>instanceof</code>的区别。写是<code>o</code>，那对比的就是<code>o</code>，写的是<code>o.__proto__</code>，对比的就是<code>o.__proto__</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;&#125;</span><br><span class="line">let c&#x3D;new C();</span><br><span class="line">let o&#x3D;new Object();</span><br><span class="line"></span><br><span class="line">o.isPrototypeOf(c); &#x2F;&#x2F; false， 因为o不在c.__proto__上</span><br><span class="line">o.__proto__.isPrototypeOf(c); &#x2F;&#x2F; true</span><br><span class="line">o.__proto__.isPrototypeOf(C); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o&#x3D;Object.create(proto[, propertiesObject])</span><br><span class="line">o.__proto__&#x3D;&#x3D;&#x3D;proto</span><br></pre></td></tr></table></figure><p><code>Object.create()</code>方法创建一个新对象<code>o</code>，使用现有的对象<code>proto</code>来提供新创建的对象<code>o</code>的<code>__proto__</code>。</p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf"></a>Object.getPrototypeOf</h3><p>Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(object);</span><br></pre></td></tr></table></figure><p><code>proto</code>就是<code>object</code>的<code>__proto__</code></p><h3 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：</p><ul><li>创建一个空的简单 JavaScript 对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li><li>将步骤 1 新创建的对象作为 this 的上下文 ；</li><li>如果该函数没有返回对象，则返回 this。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">"lisi"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car();</span><br><span class="line">car.name; <span class="comment">// lisi</span></span><br></pre></td></tr></table></figure><p>因为函数有自己的返回值，所以实例化的对象就是返回的对象，而不是 this；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car1 = <span class="keyword">new</span> Car(<span class="string">"dongfeng"</span>);</span><br><span class="line"><span class="keyword">let</span> car2 = <span class="built_in">Object</span>.create(car1);</span><br><span class="line"><span class="keyword">let</span> car3 = <span class="built_in">Object</span>.create(car1.__proto__);</span><br><span class="line">car2.name; <span class="comment">// dongfeng</span></span><br><span class="line">car3.name; <span class="comment">// undefined;</span></span><br></pre></td></tr></table></figure><p>这里解释为什么<code>car2</code>的<code>name</code>有值，<code>car3</code>没有；<br>首先要明白<code>new</code>运算符的执行过程；从上面定义我们知道，创建的<code>car1</code>是有属性<code>name</code>的，<code>car1</code>的<code>__proto__</code>是指向<code>Car.prototype</code>，这上面是没有<code>name</code>的。<br>然后需要明白<code>Object.create</code>的使用，它是把创建的对象的<code>__proto__</code>指向了传入的对象。<br>因此<code>car2.__proto__===car1</code>，因此有<code>name</code>属性；<code>car3.__proto__</code>指向<code>car1.__proto__</code>也就是<code>Car.prototype</code>，所以没有<code>name</code>属性。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nextjs配合redux笔记</title>
      <link href="/2020/01/09/nextjs%E9%85%8D%E5%90%88redux%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/nextjs%E9%85%8D%E5%90%88redux%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>具体可查看<a href="https://github.com/zeit/next.js" target="_blank" rel="noopener">github 上官方提供的 demo</a><br>下面对代码关键地方做说明，主要讲解如何实现数据共享。</p><a id="more"></a><p>with-redux-store 的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; initializeStore &#125; <span class="keyword">from</span> <span class="string">"../store"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isServer = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">"undefined"</span>;</span><br><span class="line"><span class="keyword">const</span> __NEXT_REDUX_STORE__ = <span class="string">"__NEXT_REDUX_STORE__"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrCreateStore</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Always make a new store if server, otherwise state is shared between requests</span></span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="keyword">return</span> initializeStore(initialState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create store if unavailable on the client and set it on the window object</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>[__NEXT_REDUX_STORE__]) &#123;</span><br><span class="line">    <span class="built_in">window</span>[__NEXT_REDUX_STORE__] = initializeStore(initialState);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>[__NEXT_REDUX_STORE__];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">AppWithRedux</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(appContext) &#123;</span><br><span class="line">      <span class="comment">// 在这可以把一些服务端请求数据对state进行初始化，如果没有就用下面注释掉的默认方式</span></span><br><span class="line">      <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; req &#125; = appContext.ctx;</span><br><span class="line">        <span class="keyword">const</span> session = req.session;</span><br><span class="line">        <span class="comment">// 根据放到session中的用户数据初始化state</span></span><br><span class="line">        <span class="keyword">if</span> (session &amp;&amp; session.userInfo) &#123;</span><br><span class="line">          reduxStore = getOrCreateStore(&#123; <span class="attr">user</span>: session.userInfo &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reduxStore = getOrCreateStore();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reduxStore = getOrCreateStore();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get or Create the store with `undefined` as initialState</span></span><br><span class="line">      <span class="comment">// This allows you to set a custom default initialState</span></span><br><span class="line">      <span class="comment">//const reduxStore = getOrCreateStore()</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Provide the store to getInitialProps of pages</span></span><br><span class="line">      appContext.ctx.reduxStore = reduxStore;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> appProps = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> App.getInitialProps === <span class="string">"function"</span>) &#123;</span><br><span class="line">        appProps = <span class="keyword">await</span> App.getInitialProps(appContext);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...appProps,</span><br><span class="line">        initialReduxState: reduxStore.getState(), <span class="comment">//获取服务端store中的state，传递给前端的store</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="comment">// 创建前端的store实例，前端绑定store时必须使用这个实例，不然新创建的store实例肯定获取不到这个实例的内容，也就会造成state有值，但是就是拿不到</span></span><br><span class="line">      <span class="keyword">this</span>.reduxStore = getOrCreateStore(props.initialReduxState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">reduxStore</span>=<span class="string">&#123;this.reduxStore&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure><p>在_app.js 中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"next/app"</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> withReduxStore <span class="keyword">from</span> <span class="string">"../lib/with-redux-store"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 注意，这传给store的对象一定是里面返回的reduxStore这个，不能再重新获取一个</span></span><br><span class="line">    <span class="keyword">const</span> &#123; Component, pageProps, reduxStore &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;reduxStore&#125;&gt;</span><br><span class="line">        &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withReduxStore(MyApp);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>no-cache和no-store的区别</title>
      <link href="/2020/01/09/no-cache%E5%92%8Cno-store%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/09/no-cache%E5%92%8Cno-store%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>从字面意思上很容易把 <code>no-cache</code> 误解成为不缓存，但事实上 <code>no-cache</code> 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源， 也许称为 <code>do-not-serve-from-cache-without-revalidation</code> 更合适。<br>也就是每次还是需要向服务端发送请求确认是否过期。<br><code>no-store</code> 才是真正地不进行缓存，请读者注意区别理解。</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>onLoad和DOMContentLoaded的区别</title>
      <link href="/2020/01/09/onLoad%E5%92%8CDOMContentLoaded%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/09/onLoad%E5%92%8CDOMContentLoaded%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p>当纯 HTML 被完全加载以及解析时，DOMContentLoaded 事件会被触发，而不必等待样式表，图片或者子框架完成加载。</p><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>The <strong><code>load</code></strong> event is fired when the whole page has loaded, including <code>all dependent resources</code> such as stylesheets and images. This is in contrast to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event" target="_blank" rel="noopener" title="The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading."><code>DOMContentLoaded</code></a>, which is fired as soon as the page DOM has been loaded, without waiting for resources to finish loading.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react服务端渲染笔记</title>
      <link href="/2020/01/09/react%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/react%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1348523-da23aad53417fb16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-c71c18796084afb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-4759920497527f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-e440776fdffcdf1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-8075a4c51d5aeb8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1348523-1c7481761f44fd51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack的code splitting和懒加载</title>
      <link href="/2020/01/09/webpack%E7%9A%84code%20splitting%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2020/01/09/webpack%E7%9A%84code%20splitting%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h3><p>原来一直以为 code splitting 了，就已经实现了懒加载了，但现在 react 又单独退出了懒加载功能，突然就迷茫了，webpack 已经实现懒加载了，为什么 react 还要单独实现这个功能呢？细心思考才明白两者之间的关系。</p><hr><p>code splitting 实现了代码分割，就是不把所有的代码打包到一起，这只是解决了单个大文件加载慢的问题（因为浏览器现在可以同时多个线程下载文件），而不是懒加载的问题。</p><hr><p>什么是懒加载？<br>懒加载就是没用到某个文件的时候，这文件不<strong>下载</strong>，用到的时候才下载加载，从而提高性能。</p><blockquote><p>注意：懒加载时，如果文件没用到，连下载都不下载，而不是下载下来不加载。</p></blockquote><p>而要实现懒加载，那首先各个文件是分开的，这就依赖 code splitting 功能，不然代码都在一个文件里，动态加载个屁。</p><h3 id="react-懒加载"><a href="#react-懒加载" class="headerlink" title="react 懒加载"></a>react 懒加载</h3><p>react 的懒加载，提供了 lazy 和 suspense，另外需要借助 js 的 import()“函数”（<code>其实本质不是个函数</code>）。</p><blockquote><p>懒加载解决了页面首次加载的性能问题。</p></blockquote><h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h3><p>lazy 接收一个无参的函数，返回一个新的 react 组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;lazy&#125; <span class="keyword">from</span> <span class="string">'react;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const About = lazy(() =&gt; import("./About"));</span></span><br></pre></td></tr></table></figure><p><strong>可以指定动态加载 chunk 的名字,通过在 import 里面加注释实现。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"about" */</span> <span class="string">"./About"</span>));</span><br></pre></td></tr></table></figure><p>这在浏览器的 network 中，就可以看到 About 组件的 chunk 文件名叫<code>about.chunk.js</code>,如果不指定，则是 0.chunk.js 这样，用数字命名。</p><blockquote><p>注意<code>webpackChunkName:&quot;about&quot;</code>两边要有空格，如果没有空格，也不报错，只是 chunk 文件中的代码以文本的方式显示，所有代码都是黑色的。带空格就会以代码的格式，字体有颜色。<br>另外注意 value 上的双引号。</p></blockquote><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>使用<code>lazy</code>必须使用<code>Suspense</code>组件，<code>Suspense</code>是<code>react</code>的一个内置组件。<br>suspense 是干什么的，因为 lazy 是动态加载，所以加载过程中会有一个空档期，Suspense 就是执行，这个空档期显示什么。<br>Suspense 的 fallback 属性执行了要显示的组件，fallback 接收的是一个组件的实例，而不是组件的类型（感觉一句废话）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./About"</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading,please wait……&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;About /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果组件下载失败，会报错，Suspense 没有处理错误的能力。那错误如何处理呢？使用 ErrorBoundary(错误边界)，其实就是利用了组件的<code>componentDidCatch</code>生命周期。<br>当 UI 渲染有错误时，就会触发 getDerivedStateFromError 和 componentDidCatch，可以在设置 state 的状态，然后根据 state 判断是否显示错误组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"about" */</span> <span class="string">"./About"</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    hasError: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidCatch(error) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; hasError &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>组件获取失败！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading,please wait……&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;About /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>getDerivedStateFromError</code>返回一个新的 state 对象并合并到原来的 state 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromError(error, info) &#123;</span><br><span class="line">  <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//componentDidCatch(error, info) &#123;</span></span><br><span class="line">  <span class="comment">//this.setState(&#123; hasError: true &#125;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>官方建议：当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。<br><a href="https://react.docschina.org/docs/error-boundaries.html" target="_blank" rel="noopener">错误边界的介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> code splitting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从基础到实战 手把手带你掌握新版Webpack4.0-3</title>
      <link href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-3/"/>
      <url>/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-3/</url>
      
        <content type="html"><![CDATA[<h3 id="快速使用-PWA"><a href="#快速使用-PWA" class="headerlink" title="快速使用 PWA"></a>快速使用 PWA</h3><p>根据<a href="https://www.webpackjs.com/guides/progressive-web-application/" target="_blank" rel="noopener">官网上的推荐</a>简单配置一下就行了。</p><h3 id="配置-typescript"><a href="#配置-typescript" class="headerlink" title="配置 typescript"></a>配置 typescript</h3><p>使用第三方库时，需要安装对应的类型库，不然不会提示。比如<code>@types/jquery</code>，可以在如下网站中查看有哪些 types<br><a href="http://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">http://microsoft.github.io/TypeSearch/</a></p><h3 id="单页面路由访问提示找不到资源"><a href="#单页面路由访问提示找不到资源" class="headerlink" title="单页面路由访问提示找不到资源"></a>单页面路由访问提示找不到资源</h3><p>比如我们使用的是单页面模式，<code>BrowserRouter</code>的方式，当我们根据路由去访问页面时，可能会提示找不到资源的情况，比如访问<code>http://localhost:8000/list</code>，提示找不到<code>list</code>；因为是单页面应用，所以只有 index.html 页面<br>配置 devServer 来解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">historyApiFallback: <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="ESLint-5-6"><a href="#ESLint-5-6" class="headerlink" title="ESLint 5-6"></a>ESLint 5-6</h3><p>首先安装，然后使用<br>检测 src 目录下的代码是否符合规范</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx eslint src</span><br></pre></td></tr></table></figure><p>webpack 结合 eslin<br>如果编辑器没有安装 eslint 插件，编辑器就无法检查代码规范。因此可以在 webpack 中配置 loader 来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules:&#123;</span><br><span class="line">    test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">    use:[<span class="string">'babel-loader'</span>,<span class="string">'eslint-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在每次打包的时候就会在打包信息中显示不符合规范的地方，但是这样和直接运行<code>npx eslint src</code>一样，错误信息在控制台输出中，不方便发现。<br>可以通过配置 devServer 的 overlay 来解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    overlay:<span class="literal">true</span>,</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置了 overlay，如果代码不符合 eslint 规范，编译后，页面会弹出下面的页面！每当修改掉一个 error，就会自动刷新。<br><img src="https://upload-images.jianshu.io/upload_images/1348523-2181fb06960c68cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="使用-git-钩子来检测代码规范"><a href="#使用-git-钩子来检测代码规范" class="headerlink" title="使用 git 钩子来检测代码规范"></a>使用 git 钩子来检测代码规范</h3><p>当提交带的时候，通过 git 钩子来对代码进行规范检测。</p><h3 id="提升-webpack-打包速度"><a href="#提升-webpack-打包速度" class="headerlink" title="提升 webpack 打包速度"></a>提升 webpack 打包速度</h3><p>1.跟上技术迭代（升级 node、Npm、Yarm 版本） 2.在尽可能少的模块上应用 loader<br>善于使用 exclude 和 include，图片没必要使用，因为所有的图片都需要进行打包处理。<br>3.plugin 尽可能精简并确保可靠<br>4.resolve 参数合理配置<br>比如配置了多个<code>extensions</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">"css"</span>, <span class="string">"jpg"</span>, <span class="string">"js"</span>, <span class="string">"jsx"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置，当引入一个没写后缀的文件时，会先去找对应名称的 css，然后 jpg，依次往下匹配，直到匹配到，这样的话，如果配置的后缀比较多，肯定会影响效率。<br>所以建议配置逻辑代码的文件，资源类的最好在引入时写全后缀。</p><p>mainFiles 指定默认加载文件,默认是 index，当我们引入自定义组件时，通常引入到文件夹就行了，就是因为这个配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  mainFiles: [<span class="string">"index"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属性同样有上面性能问题。</p><h3 id="自定义-loader"><a href="#自定义-loader" class="headerlink" title="自定义 loader"></a>自定义 loader</h3><p>其实 loader 就是一个函数，函数会接收被执行文件的内容，然后在 loader 中对内容做处理即可。<br>下面是一个自定义<code>loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要使用箭头函数，this的指向会出现问题。loader中的this需要绑定webpack响应的上下文</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">"eluanshi"</span>, <span class="string">"wenmu"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的 loader 开发完成，然后在 webapack 中配置即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js/</span>,</span><br><span class="line">      use: [path.resolve(__dirname, <span class="string">"./loaders/myloader.js"</span>)],</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打完包后，<code>js</code>文件中所欲的<code>eluanshi</code>都会被替换成<code>wenmu</code><br>如果返回值是多个，则需要用到<code>callback</code>函数<br>异步方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  callback(<span class="literal">null</span>, result);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="自定义-plugin"><a href="#自定义-plugin" class="headerlink" title="自定义 plugin"></a>自定义 plugin</h3><p>loader 是一个方法，plugin 是一个类。因为在使用的时候需要 new 一个实例。</p><p>调试开发的 plugin，使用 node 的调试，配置一个新的命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">      <span class="string">"debug"</span>:<span class="string">"node --inspect --inspect-brk node_modules/webpack/bin/webpack.js</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>inspect 开启调试模式</li><li>inspect-brk 在代码第一行截住<br>并且可以在代码中使用<code>debugger</code></li></ul></blockquote><h3 id="什么时候执行-resolve？"><a href="#什么时候执行-resolve？" class="headerlink" title="什么时候执行 resolve？"></a>什么时候执行 resolve？</h3><p>当引入一个模块时，会执行 resolve 中的配置。</p><h3 id="什么时候执行-resolveLoader"><a href="#什么时候执行-resolveLoader" class="headerlink" title="什么时候执行 resolveLoader"></a>什么时候执行 resolveLoader</h3><p>和 resolve 类似，这个是当引入 loader 的时候，执行里面的配置。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从基础到实战 手把手带你掌握新版Webpack4.0-2</title>
      <link href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-2/"/>
      <url>/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-2/</url>
      
        <content type="html"><![CDATA[<h3 id="懒加载和-chunk-是什么"><a href="#懒加载和-chunk-是什么" class="headerlink" title="懒加载和 chunk 是什么"></a>懒加载和 chunk 是什么</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">'/* webpackChunkName:"lodash" */ lodash'</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    element.innnerHTML = _.join([<span class="string">"Hello"</span>, <span class="string">"Every"</span>, <span class="string">"One"</span>], <span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当点击页面时才加载lodash</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在页面加载时，上面的代码所依赖的<code>lodash</code>模块是不会被加载的，可以查看请求记录，只有当点击页面时，<code>lodash</code>被打的包才会被加载 。 这就是懒加载。（注意上面的语法）</p><blockquote><p>懒加载实际上是 ES6 的概念，不是 webpack 的，只是 webpack 支持这个语法而已。</p></blockquote><h3 id="css-进行代码分割"><a href="#css-进行代码分割" class="headerlink" title="css 进行代码分割"></a>css 进行代码分割</h3><p>使用<code>mini-css-extract-plugin</code>插件，注意修改 tree shaking 的配置。比如<code>sideEffects:[&quot;*.css&quot;]</code></p><p>如果想把多个入口的 css 打包到同一个文件中，或者分开打包，都需要参考 cacheGroup,参考官网配置。</p><h3 id="filename-和-chunkFileName-的区别"><a href="#filename-和-chunkFileName-的区别" class="headerlink" title="filename 和 chunkFileName 的区别"></a>filename 和 chunkFileName 的区别</h3><p>如果生成的文件是被入口 index.html 文件直接引用的，则使用 filename 指定的规则，如果是被其他模块引用的文件也就是二级引用则走 chunkFileName 规则。</p><h3 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h3><p>这个意思就是“垫片”，什么是垫片呢，举个例子；<br>比如你引入了一个第三方的模块 A，他依赖 jquery，但是它本身自己没有对 jquery 的引用，虽然你在自己的项目安装也引用了 jquery，但是由于 webpack 打包是基于模块的，A 是无法使用项目中引入的 jquery 的，但是第三方安装包，我们又不能改代码，Shimming 就是来解决这个问题的。<br>这需要用到<code>webpack</code>的<code>ProvidePlugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    <span class="comment">// 这个指定，只要有用到$的地方，就在这个使用的模块中引入jquery，并命名成$</span></span><br><span class="line">    $: <span class="string">"jquery"</span>,</span><br><span class="line">    <span class="comment">// 把lodash中的join方法打包成_join，这样也就可以在代码中直接使用了。</span></span><br><span class="line">    _join: [<span class="string">"lodash"</span>, <span class="string">"join"</span>],</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h4 id="模块中的-this-指向-window"><a href="#模块中的-this-指向-window" class="headerlink" title="模块中的 this 指向 window"></a>模块中的 this 指向 window</h4><blockquote><p>模块中的 this 指向模块本身<br>使用<code>imports-loader</code>可以轻松做到这个。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"babel-loader"</span> &#125;,</span><br><span class="line">      <span class="comment">// 加上下面的配置,模块中的this就指向window了</span></span><br><span class="line">      &#123; <span class="attr">loader</span>: <span class="string">"imports-loader?this=&gt;window"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这也是<code>shimming</code>的一种</p><h3 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h3><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis" target="_blank" rel="noopener">参考官网介绍</a><br><a href="https://www.webpackjs.com/guides/code-splitting/#bundle-%E5%88%86%E6%9E%90-bundle-analysis-" target="_blank" rel="noopener">中文版</a><br>也可以参考《项目性能和规范总结》一文中的介绍。<br>官网给了多种分析方式，其中一种是<a href="https://github.com/webpack/analyse" target="_blank" rel="noopener">官方分析工具</a>，这个比较简单，直接在 webpack 的 bu 打包生产环境的命令中传几个参数即可。<code>--profile --json &gt; stats.json</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">      "build":"webpack --profile --json &gt; stats.json --config webpack.pro.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样打包后会有一个<code>stats.json</code>文件，打开这个工具提供的<a href="http://webpack.github.com/analyse" target="_blank" rel="noopener">分析网站</a>，把生成的<code>stats.json</code>文件上传，就会生成界面化的分析结果。</p><h3 id="查看-js-代码使用率"><a href="#查看-js-代码使用率" class="headerlink" title="查看 js 代码使用率"></a>查看 js 代码使用率</h3><p>在 chrome 浏览器的开发者工具中，在下面窗口的<code>Coverage</code>窗口中可以录制代码的使用率，并且打开代码也可以看到哪些代码使用了，哪些代码没使用到，这样可以有针对性的把第一次没有用到的代码使用动态加载的方式来做，提高效率。</p><h3 id="prefetching"><a href="#prefetching" class="headerlink" title="prefetching"></a>prefetching</h3><p>在官网的概念模块讲解了 prefetching 的概念，这个就是当访问页面时，主文件先下载，等主要文件下载完了，线程有空闲了再下载<code>prefetching</code>的文件。<br>这个需要和懒加载一起使用，通过注释的方式来指定是否<code>prefetching</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">"LoginModal"</span>);</span><br></pre></td></tr></table></figure><h3 id="根据文件内容命名文件"><a href="#根据文件内容命名文件" class="headerlink" title="根据文件内容命名文件"></a>根据文件内容命名文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].[contenthash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>webpack4 之前的版本需要配置 runtime；老版本因为把 manifest 打包到了各个 chunk 中，所以老版本的 webpack 打包，即使内容没改变，打出的包的名字 hash 也可能不一样，因为 manifest 可能发生了变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">"runtime"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="library"><a href="#library" class="headerlink" title="library"></a>library</h3><p>当开发一个工具包时，我们也可以通过 webpack 进行打包，并发布到 npm 仓库中。<br>配置很简单，和常用的配置差别不大，甚至没那么复杂。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"webpack-numbers.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的配置就已经做完了，这样就可以进行打包了。但是可以从以下几个方面进行优化会更好：</p><ol><li>外部化 lodash</li><li>支持多种方式访问包，比如 amd，cmd，es6 等等</li><li>把包暴露给指定的全局变量</li><li>指定包的执行文件</li><li>发布到 npm 仓库</li></ol><h4 id="外部化"><a href="#外部化" class="headerlink" title="外部化"></a>外部化</h4><p>首先介绍下什么是外部化：外部化就是使用用户环境中的第三方库，而不是把第三方库打包到我们的包中。<br>比如我们开发一个数字处理的工具包 A，我们的代码中用到了<code>lodash</code>、<code>moment</code>等等多种第三方包，如果不做外部化处理，这些在代码中用到的第三方包都会和我们的逻辑代码一起进行打包。这就有个问题，使用我们包 A 的用户的项目中如果也用到了<code>lodash</code>、<code>moment</code>,那就会出现重复的打包。<br>因此在我们的开发包 A 中不对这些第三方的包进行打包，而是让使用我们包 A 的用户去安装我们依赖的这些包，然后使用包 A 的地方也引入包 A 所依赖的包即可；<br>实现这个功能需要用到<code>externals</code>的配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  lodash: &#123;</span><br><span class="line">    commonjs: 'lodash', // 指定在commonjs环境下引入lodash的名字</span><br><span class="line">    commonjs2: 'lodash',</span><br><span class="line">    amd: 'lodash',</span><br><span class="line">    root: '_', // script标签引入lodash的变量名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们虽然使用了 lodash，但 lodash 不会被打包到包 A 中。</p><h4 id="支持多种方式访问包"><a href="#支持多种方式访问包" class="headerlink" title="支持多种方式访问包"></a>支持多种方式访问包</h4><p>我们的包打包后，应该支持 amd、cmd、es6 以及在文件中引入等方式的使用。实现这个功能也很简单，配置<code>output</code>属性的<code>library</code>和<code>libraryTarget</code>即可。具体的参数可参见官网上的详细介绍</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, 'dist'),</span><br><span class="line">  filename: 'webpack-numbers.js',</span><br><span class="line">  library: 'myLibrary',// 通过配置这个，可以让通过script标签的方式引入，通过全局变量myLibrary来访问</span><br><span class="line">  libraryTarget: 'umd'</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>libraryTarget 的值不同，包可被访问的方式就不同。</p><ul><li>变量：默认值。作为一个全局变量，通过 script 标签来访问（libraryTarget:’var’），需要配置 library 属性来指定变量的名字。</li><li>this：通过 this 对象访问（libraryTarget:’this’）。</li><li>window：通过 window 对象访问，在浏览器中（libraryTarget:’window’）。</li><li>UMD：在 AMD 或 CommonJS 的 require 之后可访问（libraryTarget:’umd’）。<blockquote><p>只配置<code>libraryTarget</code>不支持通过 script 标签的方式引入。</p></blockquote></li></ul><h4 id="指定包的执行文件"><a href="#指定包的执行文件" class="headerlink" title="指定包的执行文件"></a>指定包的执行文件</h4><p>当别人使用我们的包时，加载的是哪个文件可以在 package.json 中的 main 字段进行配置。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main: "./dist/webpack-numbers.js";</span><br></pre></td></tr></table></figure><h4 id="发布到-npm-仓库"><a href="#发布到-npm-仓库" class="headerlink" title="发布到 npm 仓库"></a>发布到 npm 仓库</h4><p>首先需要在 npm 官网上有一个账号。在命令行中运行<code>npm adduser</code>，然后输入用户名和密码，接着运行发布命令<code>npm publish</code>，这样你的 npm 包就发送完成了，包名就是 package.json 中 name 指定的名字。<code>npm install 包名</code>就可以安装了。</p><blockquote><p>动态链接库用的也是这块的功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从基础到实战 手把手带你掌握新版Webpack4.0-1</title>
      <link href="/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-1/"/>
      <url>/2020/01/09/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0-1/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack-是什么？"><a href="#webpack-是什么？" class="headerlink" title="webpack 是什么？"></a>webpack 是什么？</h3><p>webpack 是模块打包工具。它不能理解成 es6 的翻译器，因为它只认识 import 语法，其他的高级语法不认识。因为它是模块打包工具，所以各种模块的语法它都认识。</p><a id="more"></a><h3 id="url-loader-和-file-loader"><a href="#url-loader-和-file-loader" class="headerlink" title="url-loader 和 file-loader"></a>url-loader 和 file-loader</h3><p>url-loader 可以完全替代 file-loader;</p><h3 id="css-loader-的配置"><a href="#css-loader-的配置" class="headerlink" title="css-loader 的配置"></a>css-loader 的配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  text:/\.css|less$/,</span><br><span class="line">  use:[</span><br><span class="line">        'style-loader',</span><br><span class="line">        &#123;</span><br><span class="line">            loader:'css-loader',</span><br><span class="line">            options:&#123;</span><br><span class="line">                <span class="comment">// 指定通过import引入的样式也走后面的2个loader</span></span><br><span class="line">                importLoaders:2,</span><br><span class="line">                <span class="comment">// css模块化打包</span></span><br><span class="line">                modules:true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        'less-loader',</span><br><span class="line">        'postcss-loader'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>importLoaders 的含义<br>样式在解析时，通常是从下到上或从右到左的依次执行<code>loader</code>,但是在写样式时，有时会出现<code>@import ../list/index.less</code>的语法，这时在打包的时候<code>import</code>的样式可能就不会走<code>css-loader</code>后面的 loader，直接走<code>css-loader</code>，所以通过设置<code>importLoadders</code>，让通过<code>import</code>引入的样式,在引入之前也都走<code>css-loader</code>后的 2 个<code>loader</code></li><li>css 模块化<br>在引入 css 时通常有如下两种方式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的方式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块的方式</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br></pre></td></tr></table></figure><p>两种方式的区别</p><ul><li>全局的方式引入，只要有元素使用的样式在<code>index.less</code>中有定义，样式就会起作用。如果多个<code>css</code>文件中有相同名字的样式，则会出现样式污染的情况。</li><li>模块式引入，要想使用模块式样式，需要在<code>css-loader</code>中配置<code>modules:true</code>,这样在使用时，<ul><li>只有引入的模块，</li><li>并且指定了样式的地方才会起作用。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有效（非react语法）</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=&#123;styles.name&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 无效，虽然上面已经引入了样式，即使是单页面应用，由于下面的使用方式不是模块调用，所以即使样式名在index.less中有也没用</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"name"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="打包字体文件"><a href="#打包字体文件" class="headerlink" title="打包字体文件"></a>打包字体文件</h3><p>使用 file-loader 即可。</p><h3 id="代码映射"><a href="#代码映射" class="headerlink" title="代码映射"></a>代码映射</h3><table><thead><tr><th>devtool</th><th align="center">构建速度</th><th align="center">重新构建速度</th><th>生产环境</th><th>品质(quality)</th></tr></thead><tbody><tr><td>(none)</td><td align="center">+++</td><td align="center">+++</td><td>yes</td><td>打包后的代码</td></tr><tr><td>eval</td><td align="center">+++</td><td align="center">+++</td><td>no</td><td>生成后的代码</td></tr><tr><td><strong>cheap-eval-source-map</strong></td><td align="center">+</td><td align="center">++</td><td>no</td><td>转换过的代码（仅显示行）；<code>eval</code>是最快的，另外这个不包含第三方模块，所以感觉开发中使用这个最合适。</td></tr><tr><td><strong>cheap-module-eval-source-map</strong></td><td align="center">o</td><td align="center">++</td><td>no</td><td>原始源代码（仅显示行）；<code>但是视频推荐使用这个</code>。</td></tr><tr><td>eval-source-map</td><td align="center">–</td><td align="center">+</td><td>no</td><td>原始源代码</td></tr><tr><td><strong>cheap-source-map</strong></td><td align="center">+</td><td align="center">o</td><td>no</td><td>转换过的代码（仅显行）</td></tr><tr><td>cheap-module-source-map</td><td align="center">o</td><td align="center">-</td><td>no</td><td>原始源代码（仅显行）</td></tr><tr><td>inline-cheap-source-map</td><td align="center">+</td><td align="center">o</td><td>no</td><td>转换过的代码（仅显示行）</td></tr><tr><td>inline-cheap-module-source-map</td><td align="center">o</td><td align="center">-</td><td>no</td><td>原始源代码（仅显示行）</td></tr><tr><td>source-map</td><td align="center">–</td><td align="center">–</td><td>yes</td><td>原始源代码</td></tr><tr><td>inline-source-map</td><td align="center">–</td><td align="center">–</td><td>no</td><td>原始源代码</td></tr><tr><td>hidden-source-map</td><td align="center">–</td><td align="center">–</td><td>yes</td><td>原始源代码</td></tr><tr><td>nosources-source-map</td><td align="center">–</td><td align="center">–</td><td>yes</td><td>无源代码内容</td></tr></tbody></table><blockquote><p>+++ 非常快速, ++ 快速, + 比较快, o 中等, - 比较慢, – 慢</p></blockquote><ul><li><code>cheap</code>的含义：只针对业务代码进行映射，不包括安装的第三方包。另外 cheap 是只映射到行，不会映射到列，即行中的第几个字符。</li><li><code>module</code>的含义：就是包含安装的第三方模块。比如<code>cheap-module-source-map</code></li><li><code>eval</code>的含义，<code>eval</code>就是把源代码打包成字符串，放到<code>eval</code>中。<code>eval</code>的打包速度是最快的。<blockquote><p>视频中推荐开发模式使用<code>cheap-module-eval-source-map</code>，生产环境使用<code>cheap-module-source-map</code></p></blockquote></li></ul><p>自我理解</p><blockquote><p>带<code>eval</code>和<code>inline</code>关键字的，会把源代码和打包后的文件打包在一起，不包含的会对源代码进行单独打包，生成一个单独的文件。</p></blockquote><h3 id="dev-server"><a href="#dev-server" class="headerlink" title="dev-server"></a>dev-server</h3><p><code>dev-server</code>就是先通过<code>webpack</code>打包，然后启动一个<code>node服务</code>，把打包后的静态资源启动起来，但是<code>dev-server</code>是把静态资源放到内存中了，并没有放到磁盘上。<br>所以可以在<code>dev-server</code>的<code>before</code>钩子中写自己的<code>mock</code>。</p><blockquote><p>就是启动了一个 node 服务</p></blockquote><h3 id="手写一个简单的-dev-server"><a href="#手写一个简单的-dev-server" class="headerlink" title="手写一个简单的 dev-server"></a>手写一个简单的 dev-server</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">"webpack-dev-middleware"</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">"./webpack.config.js"</span>);</span><br><span class="line"><span class="comment">// 使用webpack进行打包</span></span><br><span class="line"><span class="keyword">const</span> complier = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = expres();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用express中间件，每当文件发生变化，webpackDevMiddleware使用complier进行打包。</span></span><br><span class="line">app.use(</span><br><span class="line">  webpackDevMiddleware(complier, &#123;</span><br><span class="line">    publickPath: config.output.publicPath,</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"server is runing."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>自己写需要配置的东西比较多，推荐使用<code>dev-server</code>.</p><h3 id="热更新-HMR"><a href="#热更新-HMR" class="headerlink" title="热更新 HMR"></a>热更新 HMR</h3><p>不配置 HMR，当有改动时，也会自动更新，但是这时是重新加载，如果页面上有数据或者状态值发生改变，是不会保留的。<br>而 HMR 是只更新变化的部分，并且保留页面的状态和数据。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  contentBase:'./dist/,</span><br><span class="line">  open:true,</span><br><span class="line">  port:3000,</span><br><span class="line">  hot:true,</span><br><span class="line">  hotOnly:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hot 是开启 hmr 模式</li><li>hotOnly 表示，启用热模块替换，在构建失败时不刷新页面作为回退。配置了这个有时候需要手动刷新，还是不要配置了。</li></ul><blockquote><p>记得配置<code>new webpack.HotModuleReplacementPlugin()</code></p></blockquote><p>上面讲解了热更新及它的配置，但是这还没完，配置后，如果想让它起作用，需要在代码中编写相关的代码才行，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter();</span><br><span class="line">number();</span><br><span class="line"><span class="comment">// 如果开启了HMR</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">"./number"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 删除老的元素</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"number"</span>));</span><br><span class="line">    <span class="comment">// 重新执行变更的元素</span></span><br><span class="line">    number();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多人奇怪，不对啊，在开发过程中没写过这样的代码啊，只要上面的配置完，<code>HMR</code>就已经起作用了啊，这是为什么呢？</p><blockquote><p>这是因为在开发过程中，我们使用的<code>loader</code>都已经实现了 HMR 的接口，也就是做了上面类似的操作。所以我们不需要手动再写。比如<code>style-loader</code>、<code>vue-loader</code>、react 的<code>bable-preset</code>等，都已经实现了 HMR 接口。可参考官网“概念”模块里面的讲解。</p></blockquote><h3 id="Babel-解决-ES6-语法"><a href="#Babel-解决-ES6-语法" class="headerlink" title="Babel 解决 ES6 语法"></a>Babel 解决 ES6 语法</h3><p>由于现在很多浏览器还不支持 ES6 语法，所以需要使用 babel 把 es6 语法转换成所有浏览器都支持的 ES5 语法。<br><code>babel-loader</code>并不会直接把<code>ES6</code>语法转换成<code>ES5</code>，它只是搭建<code>babel</code>和<code>webpack</code>的桥梁，它需要使用<code>babel/preset-env</code>插件对 ES6 进行转换。<br><code>babel/preset-env</code>只能转换 ES6 语法，比如箭头函数、let 等，它不能转换 ES6 中的函数，比如 Promise、Array.map()等，如果需要支持这些 ES6 的函数，需要使用<code>babel/polyfill</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"@babel/polyfill"</span>;</span><br></pre></td></tr></table></figure><p>在使用时，我们需要引入；<br>由于 polyfill 文件很大，所以在打包时如果把没有用到的方法也打包进来，那打包后的文件会很大，如果只打包用到的方法，这样就比较符合我们的用意。通过设置<code>useBuiltIns:&#39;usage&#39;</code>可以达到我们的目的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.jsx?$/,</span><br><span class="line">                exclude:/node_modules/,</span><br><span class="line">                loader:'babel-loader',</span><br><span class="line">                options:&#123;</span><br><span class="line">                    presets:[</span><br><span class="line">                          ['@babel/preset-env',&#123;</span><br><span class="line">                              <span class="comment">// 指定需要适应的浏览器版本，如果浏览器版本已经支持了ES6，那么代码就不会被转换了</span></span><br><span class="line">                              targets:&#123;chrome:'67'&#125;</span><br><span class="line">                              <span class="comment">// 指定polyfill只打包用到的函数，比如只用了promise，那只会打包polyfill中的promise。当配置了这个，就不需要手动import ‘@babel/polyfill’了</span></span><br><span class="line">                              useBuiltIns:'usage'</span><br><span class="line">                          &#125;]</span><br><span class="line">                    ],</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开发第三方库时-polyfill-的配置"><a href="#开发第三方库时-polyfill-的配置" class="headerlink" title="开发第三方库时 polyfill 的配置"></a>开发第三方库时 polyfill 的配置</h3><p>由于上面的引入是全局的，所以如果开发第三方包时也那样做，就会污染全局变量，应该使用下面的方式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.jsx?$/,</span><br><span class="line">                exclude:/node_modules/,</span><br><span class="line">                loader:'babel-loader',</span><br><span class="line">                options:&#123;</span><br><span class="line">                    "plugins":[["@babel/plugin-transform-runtime",&#123;</span><br><span class="line">                              "corejs":2,</span><br><span class="line">                              "helpers":true,</span><br><span class="line">                              "regenerator":true,</span><br><span class="line">                              "useESModules":false,</span><br><span class="line">                    &#125;]]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外 impor 的地方需要删除掉。同时需要安装<code>npm install --save @babel/runtime-corejs2</code></p><blockquote><p>不想在 options 中配置，可以创建 babel 的配置文件<code>.babelrc</code>来专门配置 babel</p></blockquote><h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><p><a href="https://www.webpackjs.com/guides/tree-shaking/" target="_blank" rel="noopener">官网解释</a>其实已经很明确了。<br>就是移除没用到的代码，打包的时候只把用到的代码进行打包。它依赖于 ES2015 模块系统中的<a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure" target="_blank" rel="noopener">静态结构特性</a>，例如  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener"><code>import</code></a>  和  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener"><code>export</code></a>。也就是说 Tree Shaking 只支持<code>ES6</code>的<code>module</code>，对于<code>commonjs</code>的模块是不支持的，因为它是动态结构。</p><blockquote><p>Tree Shaking 形象的描述了这一行为，摇动树，把没用的树叶摇掉，只留下有用的。</p></blockquote><p>在开发环境下，这个功能默认是没开启的，所以在<code>development</code>环境下，需要设置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins:[],</span><br><span class="line">optimization:&#123;</span><br><span class="line">    usedExports:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在开发模式下，就只会对使用到的代码进行打包，但是这样有个问题，比如<code>@babel/polyfill</code>这类文件，需要引入，但是不需要专门导出其中的某个方法，这时打包时就会认为这个包没用到，打包时就会删除它，这样就会有问题。<br>我们可以通过设置<code>package.json</code>中的<code>sideEffects</code>来指定哪些包不需要<code>tree shaking</code>的包。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样就不会对@babel/polyfill进行tree shaking了</span></span><br><span class="line">"sideEffects":["@babel/polyfill"]</span><br></pre></td></tr></table></figure><p>但是由于<code>@babel/polyfill</code>不需要手动引入，所以我们需要对所有的文件进行<code>tree shaking</code>,这时把<code>siideEffects</code>设置成<code>false</code>即可。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对所有的文件进行tree shaking</span></span><br><span class="line">"sideEffects":false</span><br></pre></td></tr></table></figure><p>但是如果 css 没有使用 module 的模式，则会认为 css 文件没有导出任何东西，也会被移除，所以需要对 css 进行配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不对所有的css进行tree shaking</span></span><br><span class="line">"sideEffects":["*.css"]</span><br></pre></td></tr></table></figure><p>上面配置完，开发模式下的 tree shaking 就配置完了，但是通过查看打包后的文件发现，没用到的代码还是被打包了 😂，是不是没起作用，其实起作用了，在注释里面标记了文件有哪些方法，真正用到的是哪些方法，只是标记了一下，为什么不移除掉呢，因为如果移除掉，在调试的时候，代码的行数可能就对不上了，<strong>所以开发模式下配置这个就是脱裤放屁，妈了个巴子</strong></p><p>所以 tree shaking 真正有意义的是在生产环境，但是生产环境不需要手动做 tree shaking 配置，webpack 自动都配置好了，所以这功能了解就行，不需要做什么。sideEffects 需要设置下。</p><h3 id="webpack-和-code-spliting"><a href="#webpack-和-code-spliting" class="headerlink" title="webpack 和 code spliting"></a>webpack 和 code spliting</h3><p>code spliting 就是把代码打包成多个包，这样在浏览器加载的时候就可以并行加载，提高性能和效率。<br>实现的方式有很多种，下面列举一些常用的。</p><ol><li>把全局使用的包单独打包<br>比如<code>lodash</code>,这个包封装了一些封装了一些常用的方法，完全可以挂在在 window 全局上，而不需要在每个使用的地方 import。<br>新建一个<code>js</code>文件<code>lodash.js</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line"><span class="built_in">window</span>._ = _;</span><br></pre></td></tr></table></figure><p>然后打包的时候，就可以把这个文件单独打包，这样就不会在每个使用的地方都打包一次（也可以通过 webpack 提取模板的方式解决）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    main:'./index.js',</span><br><span class="line">    lodash:'./lodash.js'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样打包的时候，<code>lodash</code>就被单独打包了。</p><h3 id="使用-webpack-自带的代码分割"><a href="#使用-webpack-自带的代码分割" class="headerlink" title="使用 webpack 自带的代码分割"></a>使用 webpack 自带的代码分割</h3><p>我们不需要专门的对 lodash 这种第三方模块进行处理，通过配置 webpack，它自动做代码分割。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务代码中</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="comment">// ... 业务代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack 配置</span></span><br><span class="line">plugins:[],</span><br><span class="line">optimization:&#123;</span><br><span class="line">      splitChunks:&#123;</span><br><span class="line">            chuks:<span class="string">'all'</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置是对同步代码的；<br>如果是异步加载，那么上面的配置就不需要了，webpack 会把异步加载的包自动单独进行打包。<br>默认打出的 chunk 包名是用包的 id 来命名的，也就是 0，1，2 等等，可以手动指定 chunk 的包名。<br>异步加载组件支持一种语法叫做“魔法注释”，可以通过这种方式设置生成 chunk 的名字。<br>比如下面是一段异步加载的代码（注意两端的空格）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">'/* webpackChunkName:"lodash" */ lodash'</span>).then(&#123;<span class="attr">default</span>:_&#125;=&gt;&#123;</span><br><span class="line">             <span class="keyword">var</span> element=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">             element.innnerHTML=_.join([<span class="string">'Hello'</span>,<span class="string">'Every'</span>,<span class="string">'One'</span>],<span class="string">'-'</span>);</span><br><span class="line">             <span class="keyword">return</span> element;</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面打包后<code>lodash</code>的包就会被命名成<code>vendors~lodash.js</code>； 是不是奇怪为什么会多一个<code>vendors~</code>，如果不想让带着前缀，可以通过配置插件<code>SplitChunksPlugin</code>来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">"all"</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: <span class="literal">false</span>, <span class="comment">// 这个设置成false</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">false</span>, <span class="comment">// 这个设置成false</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样再打包，包名就成<code>lodash.js</code>了。</p><p>其实代码分割就是通过配置<code>SplitChunksPlugin</code>插件来实现的。虽然上面是通过注释的方式，其实也是走的<code>SplitChunksPlugin</code>插件。</p><h3 id="SplitChunksPlugin-详细讲解"><a href="#SplitChunksPlugin-详细讲解" class="headerlink" title="SplitChunksPlugin 详细讲解"></a>SplitChunksPlugin 详细讲解</h3><p><code>SplitChunksPlugin</code>有一个默认配置，<a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">参见官网</a><br>，手动设置成空对象或不配置，走的都是这个默认配置。</p><ul><li>chunks</li></ul><table><thead><tr><th>chunks 参数值</th><th>含义</th></tr></thead><tbody><tr><td>all</td><td>把动态和非动态模块同时进行优化打包；所有模块都扔到 vendors.bundle.js 里面。依赖<code>cacheGroup</code>中的配置，如果<code>cacheGroup</code>中的配置设置成 false，则不会分割打包。</td></tr><tr><td>initial</td><td>把非动态模块打包进 vendor，动态模块优化打包</td></tr><tr><td>async</td><td>把动态模块打包进 vendor，非动态模块保持原样（不优化）</td></tr></tbody></table><ul><li>minSize<br>需要进行代码分割的最小尺寸。只有大于这个值的包才会进行代码分割。单位是字节，（1024 字节=1kb）</li><li>maxSize<br>配置打包后 chunk 的包的大小，比如配置 50000，50kb，那么<code>lodash</code>包的大小超过了这个，打包的时候<code>lodash</code>会被拆分多个 50kb 的包。一般不配置这个选项。</li><li>minChunks<br>设置模块被引用多少次才进行代码拆分。<blockquote><p>这里说的引用是指被打包后生成的 chunk 所引用的次数，不是开发代码中引用的次数（是这样吗？）</p></blockquote></li><li>maxAsyncRequests<br>设置页面同时加载的模块数量。比如设置 5，当打包前 5 个库的时候，会分别打包成 5 个包文件，超过 5 个的模块就不再进行代码分割。</li><li>maxInitialRequests<br>设置整个网站首页或入口文件在进行加载时，可能也会引入其他代码库，这个就是设置入口文件引入的库最多拆分几个包。比如设置成 3，即使入口文件引入了 5 个文件，那也会只拆分成三个包。</li><li>automaticNameDelimiter<br>设置生成文件时名称之间的连接符。</li><li>name<br>设置<code>cacheGroup</code>中的名字是否有效,这个参数一般不动。</li><li>cacheGroups<br>配置拆分的规则。为什么叫“缓存组”，比如有两个第三方包，lodash 和 jquery，当遇到 lodash 时，看下是否满足拆规则，如果满足则先缓存下来，然后再分析 jquery，等把包都分析完了，把都满足规则的包一起打包到对应组指定的文件中。<ul><li>reuseExistingChunk<br>指定打过包的文件不会再被打包。比如有 a,b 两个包，在 c 文件中引入了 a,b,但是 a 中也引入了 b，这样在打包的时候，由于在对 a 打包的时候已经打过 b 的包，所以在对 c 打包的时候，不会再对 b 进行打包。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">"async"</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">"~"</span>,</span><br><span class="line">      automaticNameMaxLength: <span class="number">30</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>, <span class="comment">//指定打过包的模块不会被重复打包。</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点串讲-1</title>
      <link href="/2020/01/09/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-1/"/>
      <url>/2020/01/09/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-的-meta-配置"><a href="#HTML-的-meta-配置" class="headerlink" title="HTML 的 meta 配置"></a>HTML 的 meta 配置</h2><p>1.X-UA-Compatible</p><p><code>X-UA-Compatible</code>是自从<code>IE8</code>新加的一个设置，对于<code>IE8</code>以下的浏览器是不识别的。 通过在 meta 中设置 X-UA-Compatible 的值，可以指定<strong>网页的兼容性模式设置</strong>。</p><p>在网页中指定的模式优先权高于服务器中(通过 HTTP Header)所指定的模式。 兼容性模式设置优先级：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta tag &gt; http header</span><br></pre></td></tr></table></figure><p>常用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;7&quot;&gt;</span><br><span class="line">#以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8&#x2F;9都会以IE7引擎来渲染页面。</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;8&quot;&gt;</span><br><span class="line">#以上代码告诉IE浏览器，IE8&#x2F;9都会以IE8引擎来渲染页面。</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">#以上代码告诉IE浏览器，IE8&#x2F;9及以后的版本都会以最高版本IE来渲染页面。</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;7,IE&#x3D;9&quot;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;7,9&quot;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge,chrome&#x3D;1&quot;&gt;</span><br><span class="line">#以上代码IE&#x3D;edge告诉IE使用最新的引擎渲染网页，chrome&#x3D;1则可以激活Chrome Frame.</span><br></pre></td></tr></table></figure><p>京东、淘宝用的就是最后一个。</p><p><strong>content = “IE=Edge,chrome=1”</strong></p><p>meta 信息中常有这么一句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>chrome=1</code>不是说 IE 的技术增强了可以模拟<code>Chrome</code>浏览器，而是与谷歌开发的<code>Google Chrome Frame</code>(谷歌内嵌浏览器框架<code>GCF</code>)有关。这个插件可以让用户的 IE 浏览器外观不变，但用户在浏览网页时实际上使用的是 Chrome 的内核，并且支持 Windows XP 及以上系统的 IE6/7/8。</p><ol start="2"><li>指定双核浏览器优先使用什么内核渲染运行</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面的配置说明如果是双核浏览器，优先以 webkit 内核运行。</p><h3 id="dns-域名预解析"><a href="#dns-域名预解析" class="headerlink" title="dns 域名预解析"></a>dns 域名预解析</h3><p>dns 域名预解析可以提高网页性能，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//static.360buyimg.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/goloving/p/9368965.html" target="_blank" rel="noopener">dns 域名预解析文章</a><br>不同的浏览器对<strong>单个域名</strong>的最大并发连接数有一定的限制，所以不同的资源需要放到不同的域名上面。这就用到了 dns 域名预解析。<br>字体文件<br>自定义字体<br>自定义图标<br>webp 图片</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点串讲-2</title>
      <link href="/2020/01/09/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-2/"/>
      <url>/2020/01/09/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2-2/</url>
      
        <content type="html"><![CDATA[<h2 id="float-的理解"><a href="#float-的理解" class="headerlink" title="float 的理解"></a>float 的理解</h2><ul><li>在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。</li><li>CSS 属性将一个元素放在其容器的左边或右边，允许文本和内联元素环绕它。元素将从页面的正常流中删除，但仍然保留为流的一部分(与绝对定位相反)。</li><li>如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。</li><li>假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。</li></ul><h3 id="仍保留流的一部分怎么理解？"><a href="#仍保留流的一部分怎么理解？" class="headerlink" title="仍保留流的一部分怎么理解？"></a>仍保留流的一部分怎么理解？</h3><p>这里先解释下流的理解。首先流分为三种，标准文档流、文档流、文本流；</p><p>标准文档流 = 文档流 + 文本流</p><p>其实 float 的元素是从正常流中脱离的，说的是文档流，所以浮动元素会浮在正常流元素上面；仍然保留一部分说的文本流，正常流中的文本或内联元遇到浮动元素会换行。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>把 div3 的填充满内容，然后把 div2 的高度设置成小于 div3 ；可以看到 div2 是压在 div3 上面，这说明 float 元素是脱离文档流的，但是文本在遇到 float 元素时是换行显示的，并没有被 float 元素所遮挡，这就是文本流。</p><p><a href="https://www.imooc.com/article/8915" target="_blank" rel="noopener">推荐阅读内容</a></p><h2 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h2><h3 id="基本概念：标准模型-IE-模型"><a href="#基本概念：标准模型-IE-模型" class="headerlink" title="基本概念：标准模型+IE 模型"></a>基本概念：标准模型+IE 模型</h3><p>盒子模型就是块的组成部分，<code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>。<br><code>标准模型</code>就是宽高只计算<code>content</code>，也就是<code>content-box</code>。<br><code>IE模型</code>就是宽高把<code>border</code>和<code>padding</code>包含进来，注意不包含<code>margin</code>，也就是<code>border-box</code>。</p><h3 id="标准模型和-IE-模型的区别"><a href="#标准模型和-IE-模型的区别" class="headerlink" title="标准模型和 IE 模型的区别"></a>标准模型和 IE 模型的区别</h3><p>区别就是上面说的宽高的计算方式不同。</p><h3 id="CSS-如何设置这两种模型"><a href="#CSS-如何设置这两种模型" class="headerlink" title="CSS 如何设置这两种模型"></a>CSS 如何设置这两种模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing:content-box; &#x2F;&#x2F; 标准模型，默认</span><br><span class="line">box-sizing:border-box; &#x2F;&#x2F; IE模型</span><br></pre></td></tr></table></figure><h3 id="JS-如何设置获取盒模对应的宽和高"><a href="#JS-如何设置获取盒模对应的宽和高" class="headerlink" title="JS 如何设置获取盒模对应的宽和高"></a>JS 如何设置获取盒模对应的宽和高</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这个只能获取内联样式的宽和高，也就是通过style属性设置的，不然即使css中设置了高度也获取不到</span><br><span class="line">dom.style.width&#x2F;height</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个是获取渲染后的宽和高，但是这个只有IE支持</span><br><span class="line">dom.currentStyle.width&#x2F;height</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个和上面一样，但是兼容所有主流浏览器------所以用这个</span><br><span class="line">window.getComputedStyle(dom).width&#x2F;height</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个也能获取渲染后的宽高，但是这个主要用于计算位置，因为返回值里面有位置和宽高信息</span><br><span class="line">dom.getBoundingClientRect().width&#x2F;height</span><br></pre></td></tr></table></figure><h3 id="根据盒模型解释边距重叠"><a href="#根据盒模型解释边距重叠" class="headerlink" title="根据盒模型解释边距重叠"></a>根据盒模型解释边距重叠</h3><h3 id="BFC-边距重叠解决方案"><a href="#BFC-边距重叠解决方案" class="headerlink" title="BFC(边距重叠解决方案)"></a>BFC(边距重叠解决方案)</h3><ol><li>BFC 的概念<br>BFC 就是块级格式化上下文。</li><li>BFC 的原理<br>原理说白了就是渲染规则，规则是：<blockquote><ol><li>BFC 这个元素的垂直方向的边距会发生重叠</li><li>BFC 的区域不会与浮动元素的 box 重叠，这用来清除浮动和布局<br>我们知道 float 的元素是覆盖在其他元素上面，比如 A，只是文本会受浮动元素影响，但是当把 A 设置成 BFC(overflow:hidden)，float 元素就不会在 A 元素上面了。</li></ol></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    html * &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .parent &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123;</span><br><span class="line">      margin-top: 10px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      height: 100px;</span><br><span class="line">      &#x2F;* overflow: hidden; *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    .float &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      height: 50px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;section class&#x3D;&quot;parent&quot; id&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;float&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;article class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;article&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>BFC 在页面上是个独立的容器，外面的元素不会影响里面的元素，里面的也不会影响外面的</li><li>计算 BFC 高度时，浮动元素也会参与计算<br>正常情况下，容器中有浮动元素，容器的高度是不受浮动元素影响，即使浮动元素独自占一行。但是如果容器设置成 BFC，高度就受浮动元素的影响了</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    html * &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .parent &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123;</span><br><span class="line">      margin-top: 10px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    .float &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      height: 50px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;section class&#x3D;&quot;parent&quot; id&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">    &lt;article class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;article&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;float&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    window.onload &#x3D; function() &#123;</span><br><span class="line">      console.log(window.getComputedStyle(document.getElementById(&quot;parent&quot;)).height);</span><br><span class="line">    &#125;;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h3><ul><li>根元素(<code>&lt;html&gt;</code>)</li><li>浮动元素（元素的  <code>float</code>  不是  <code>none</code>）</li><li>绝对定位元素（元素的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener" title="CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。"><code>position</code></a>  为  <code>absolute</code>  或  <code>fixed</code>）</li><li>行内块元素（元素的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a>  为  <code>inline-block</code>）</li><li>表格单元格（元素的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a>为  <code>table-cell</code>，HTML 表格单元格默认为该值）</li><li>表格标题（元素的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a>  为  <code>table-caption</code>，HTML 表格标题默认为该值）</li><li>匿名表格单元格元素（元素的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a>为  <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或  <code>inline-table</code>）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow" target="_blank" rel="noopener" title="CSS属性 overflow 定义当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。它是 overflow-x 和overflow-y的 简写属性 "><code>overflow</code></a>  值不为  <code>visible</code>  的块元素</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener" title="display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。"><code>display</code></a>  值为  <a href="https://drafts.csswg.org/css-display/#valdef-display-flow-root" target="_blank" rel="noopener"><code>flow-root</code></a>  的元素</li></ul><p><a href="https://www.cnblogs.com/mlw1814011067/p/10397999.html" target="_blank" rel="noopener">一篇不错的 BFC 的讲解，貌似和我听的一套课程</a></p><p>##DOM 事件类</p><h3 id="DOM-事件的级别"><a href="#DOM-事件的级别" class="headerlink" title="DOM 事件的级别"></a>DOM 事件的级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DOM0 element.onclick&#x3D;function()&#123;&#125; || &lt;div onclick&#x3D;&quot;clickme()&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">DOM2 element.addEventListener(&#39;click&#39;,function()&#123;&#125;,false)</span><br><span class="line"></span><br><span class="line">DOM3 element.addEventListener(&#39;keyup&#39;,function()&#123;&#125;,false)</span><br></pre></td></tr></table></figure><p>与其说是级别，不如说是版本。<br>DOM0 就是上面两种添加事件的时代。<br>DOM1 没有制定事件相关的内容<br>DOM2 就是增加了使用<code>addEventListener</code>添加事件的方式<br>DOM3 增加了很多的事件类型，比如鼠标事件、键盘事件等等</p><h3 id="DOM-事件模型"><a href="#DOM-事件模型" class="headerlink" title="DOM 事件模型"></a>DOM 事件模型</h3><p>说的就是冒泡和捕获</p><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>事件流分为三个阶段：<br>捕获阶段—目标阶段—冒泡阶段</p><h3 id="描述-DOM-事件捕获的具体流程"><a href="#描述-DOM-事件捕获的具体流程" class="headerlink" title="描述 DOM 事件捕获的具体流程"></a>描述 DOM 事件捕获的具体流程</h3><p>window–document—html—body—继续向下到目标</p><blockquote><p>注意第一个对象是 window，不是 html</p></blockquote><h3 id="EVent-对象的常见应用"><a href="#EVent-对象的常见应用" class="headerlink" title="EVent 对象的常见应用"></a>EVent 对象的常见应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault()</span><br><span class="line">event.stopPropagation()</span><br><span class="line">event.stopImmediatePropagation()</span><br><span class="line">event.currentTarget &#x2F;&#x2F; 绑定事件的元素</span><br><span class="line">event.target &#x2F;&#x2F; 触发事件的元素</span><br></pre></td></tr></table></figure><p>前两个没啥可说的，直接说第三个；<br>比如给按钮绑定了两个事件<code>eventA</code>和<code>eventB</code>,正常情况下，点击按钮后，<code>eventA</code>和<code>eventB</code>都会被执行；<br>如果想执行<code>eventA</code>后不再执行<code>eventB</code>，在 eventA 中调用<code>event.stopImmediatePropagation()</code>就行了。<br>event.target 比较好理解，表示触发事件的元素。<br>event.currentTarget 表示绑定事件的元素；比如把事件绑定在父元素<code>ul</code>上，点击子元素<code>li</code>时，<code>e.target</code>是<code>li</code>，但是<code>e.currentTarget</code>是<code>ul</code></p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义事件</span><br><span class="line">let eve&#x3D;new Event(&#39;eventName&#39;)</span><br><span class="line">&#x2F;&#x2F; 绑定事件</span><br><span class="line">dom.addEventListener(&#39;eventName&#39;,function()&#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; 触发事件</span><br><span class="line">dom.dispatchEvent(eve)</span><br></pre></td></tr></table></figure><p>如果定义事件时需要传递一些参数，可以使用<code>CustomEvent</code></p><h2 id="HTTP-协议类"><a href="#HTTP-协议类" class="headerlink" title="HTTP 协议类"></a>HTTP 协议类</h2><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>简单快速</li><li>灵活</li><li>无连接</li><li>无状态</li></ul><h3 id="HTTP-报文的组成部分"><a href="#HTTP-报文的组成部分" class="headerlink" title="HTTP 报文的组成部分"></a>HTTP 报文的组成部分</h3><p><strong>请求报文</strong></p><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul><p><strong>响应报文</strong></p><ul><li>状态行</li><li>响应行</li><li>空行</li><li>响应体</li></ul><h3 id="POST-和-GET-的区别"><a href="#POST-和-GET-的区别" class="headerlink" title="POST 和 GET 的区别"></a>POST 和 GET 的区别</h3><ol><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求 √</li><li>GET 产生的 URL 地址可以被收藏，而 POST 不可用</li><li>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置 √</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</li><li>GET 请求参数会被完整的保留在浏览器的历史记录里，而 POST 中的参数不会被保留 √</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制 √</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制 √</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li></ol><h2 id="原型链类问题"><a href="#原型链类问题" class="headerlink" title="原型链类问题"></a>原型链类问题</h2><h3 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h3><p>总共三种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">name</span>:<span class="string">'zhangsan'</span> &#125; <span class="comment">// 字面量的方式</span></span><br><span class="line"><span class="keyword">let</span> <span class="number">02</span> = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">'zhagnsan'</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的两种写法是一种声明方式。</p><p>第二种：构造函数的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Man = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><p>第三种：Object.create()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">name</span>: <span class="string">"zhangsan"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">Object</span>.create(<span class="number">01</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/JXpGoPyiIOwQk5j.png" alt="1348523-c516f36ecb8241e3.png"></p><h3 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h3><p>只要使用 new 创建实例，那这个函数这时就是构造函数，不使用 new 操作它，它就是普通的函数，所以任何函数都可以是构造函数。</p><blockquote><p>使用实例原型链上的 constructor 和 function 进行对比，来判断实例是哪个 function 的实例。</p></blockquote><h3 id="手动实现-new-运算法"><a href="#手动实现-new-运算法" class="headerlink" title="手动实现 new 运算法"></a>手动实现 new 运算法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Fun = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先创建一个空对象，并把它的原型指到func上</span></span><br><span class="line">  <span class="keyword">let</span> o = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">  <span class="comment">// 执行原函数</span></span><br><span class="line">  <span class="keyword">let</span> r = func.call(o);</span><br><span class="line">  <span class="comment">// 判断原函数是否有返回值，有返回值则返回，没有则返回上面创造的对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> r === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">  <span class="keyword">this</span>.list = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">Child.prototype = Parent.prototype;</span><br><span class="line"><span class="comment">// 第三种方式</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.contructor = Child;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// Child.prototype.__proto__=Parent.prototype;</span></span><br></pre></td></tr></table></figure><h2 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h2><h3 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h3><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。<br>这是一个用于隔离潜在恶意文件的关键的安全机制。</p><p>源=协议+域名+端口</p><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM 无法获得</li><li>AJAX 请求不能发送</li></ul><h3 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h3><ul><li>Ajax</li><li>WebSocket 不受同源策略限制</li><li>CORS 支持跨域通信也支持同源通信<br>这是一个新的企业通信标准</li></ul><h3 id="如何创建一个-Ajax"><a href="#如何创建一个-Ajax" class="headerlink" title="如何创建一个 Ajax"></a>如何创建一个 Ajax</h3><ul><li>XMLHttpRequest 对象的工作流程</li><li>兼容性处理</li><li>事件的触发条件</li><li>事件的触发顺序</li></ul><h3 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h3><ul><li>jSONP<br>使用 script 标签的 src 属性实现</li><li>Hash<br>就是 url 中#号后面的内容，hash 的改变是不刷新页面的，query 是的改变会刷新(?后面的)，所以 query 不能做<br>跨域通信</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景是当前页面 A 通过 iframe或frame嵌入了跨域的页面 B</span></span><br><span class="line"><span class="comment">// 在 A 中的伪代码如下：</span></span><br><span class="line"><span class="keyword">let</span> B = <span class="built_in">document</span>.getElementByTagName(<span class="string">"iframe"</span>);</span><br><span class="line">B[<span class="number">0</span>].src = B[<span class="number">0</span>].src + <span class="string">"#"</span> + <span class="string">"data"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 B 中的伪代码如下</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="built_in">window</span>.location.hash;</span><br><span class="line">  <span class="comment">// 然后再用data发出请求</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我想了想为什么 query 不行，按说上面的方式也能改变 url 的参数，并且在 B 页面是可以获取到的。但是为什么不能做跨域呢？<br>上面也说了这种方式不能是因为会引起刷新，问题是为什么引起刷新就不能做跨域了？<br>原因为刷新导致了其他服务端请求，这些请求被认为是 A 发出的，但是经过测试发现，<code>iframe</code>中发出的请求<code>origin</code>和<code>referer</code>都是 B 自己。那应该也可以啊？？？</p><ul><li>postMessage HTML5</li><li>WebSocket</li><li>CORS<br>为什么 cors 能跨域？<br>当浏览器发现发出的请求是 CORS，会在请求头里面加上 origin 参数。</li></ul><h2 id="安全类"><a href="#安全类" class="headerlink" title="安全类"></a>安全类</h2><p>主要就是 XSS 和 CSRF<br><a href="https://segmentfault.com/n/1330000017762196?token=3c334f35a69008d4e1607e3530f1612f" target="_blank" rel="noopener">https://segmentfault.com/n/1330000017762196?token=3c334f35a69008d4e1607e3530f1612f</a></p><h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><ul><li><p>排序<br><img src="https://i.loli.net/2020/02/26/v1NYejftgZaC9Ey.png" alt="各种排序算法的复杂度"></p></li><li><p>堆栈、队列、链表</p></li><li><p>递归</p></li><li><p>波兰式和逆波兰式</p></li></ul><p><a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">Javascript 算法——快速排序</a></p><p><a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">Javascript 算法——选择排序</a></p><p><a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">Javascript 算法——希尔排序</a></p><p><a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">JavaScript 中的递归</a></p><p><a href="https://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">波兰式、逆波兰式与表达式求值</a></p><p><a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">https://github.com/Tairraos/rpn.js/blob/master/rpn.js</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约开发笔记</title>
      <link href="/2020/01/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/09/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>记录智能合约开发的环境配置及各个软件的功能。</p><a id="more"></a><h3 id="Remix"><a href="#Remix" class="headerlink" title="Remix"></a>Remix</h3><p>一个在线的智能合约开发环境。</p><h3 id="MetaMask"><a href="#MetaMask" class="headerlink" title="MetaMask"></a>MetaMask</h3><p><a href="https://metamask.io/" target="_blank" rel="noopener">https://metamask.io/</a><br>这是一个 chrome 插件，管理以太坊钱包。用这个插件，你可以把你以太坊的公有和私有的钱包导入进来进行关联，并且使用 Remix 开发合约时，可以直接连通，使用钱包中的信息。</p><h3 id="ganache"><a href="#ganache" class="headerlink" title="ganache"></a>ganache</h3><p><a href="https://www.trufflesuite.com/ganache" target="_blank" rel="noopener">https://www.trufflesuite.com/ganache</a><br>快速启动个人 Ethereum 区块链，您可以使用它来运行测试、执行命令和检查状态，同时控制链的操作方式。</p><p>安装完后，启动后，它会在<code>http://127.0.0.1:7545</code>上启动一个服务，并生成几个私有合约的账号，用这些可以方便我们进行测试。</p><p>启动后，就可以使用<code>MetaMask</code>连接。</p><ul><li>把 metaMask 的网络选择”自定义 RPC”</li><li>输入名称，url 中输入<code>http://127.0.0.1:7545</code></li></ul><p>上面两步就连上了<code>metamask</code>启动的服务。把<code>metamask</code>上面的账户导入到 metamask 中，就可以看到对应账户的以太币。<br>复制账户的私钥，然后在 metamask 中导入即可</p><p>和<code>metamask</code>连通后，刷新<code>remix</code>，<code>remix</code>可以自动读取<code>metamask</code>的账户信息，可以用来进行智能合约的测试。</p><h3 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h3><p><a href="https://www.trufflesuite.com/" target="_blank" rel="noopener">https://www.trufflesuite.com/</a><br>这个是以太坊的开发套件，大家都喜欢称为瑞士军刀套件。有了这个就可以让智能合约的<strong>编译</strong>和<strong>部署</strong>就可以变的自动化。<br>在使用 remix 时，编译和部署都是在浏览器中自动进行的。我们自己开发中，合约写完后，需要把编译成 bat code 和 ibi 接口，ibi 是一个 json，是用来部署和 web3 来做接口。使用 truffle 可以让上面的流程自动化。<br>全局安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure><p>使用下面的命令可以下载官网提供的宠物领养的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle unbox pet-shop</span><br></pre></td></tr></table></figure><ul><li><code>contracts/</code>: 合约都放在这个文件夹中</li><li><code>migrations/</code>:部署文件放在这里</li><li><code>truffle-config.js</code>: Truffle configuration file</li></ul><p>使用如下命令编译合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br></pre></td></tr></table></figure><p>部署合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle migrate --reset</span><br></pre></td></tr></table></figure><p>也可以加–reset 重启服务<br>部署成功后，在<code>ganache</code>中就可以看到新部署的合约账户了。</p><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle test</span><br></pre></td></tr></table></figure><p>上面会测试所有 test 文件夹下的测试文件。注意：需要在项目中安装 truffle，即使全局已安装。</p><h3 id="浏览器端和智能合约进行交互"><a href="#浏览器端和智能合约进行交互" class="headerlink" title="浏览器端和智能合约进行交互"></a>浏览器端和智能合约进行交互</h3><p>上面的所有的操作，就把只能合约开发的服务端配置做完了，写的合约也能编译部署了，接下来就可以通过客户端来进行操作了。<br>前端操作智能合约需要两个库</p><ul><li>web3</li><li>truffle-contract //这是 truffle 在前端又包了一层</li></ul><p>创建一个 react 项目，把上面的合约服务器代码放到 src 下面，然后退回到前端代码的根目录，安装下面的两个库，因为这两个库是给前端开发使用的。<br>在项目中安装这两个库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i web3 truffle-contract --save</span><br></pre></td></tr></table></figure><blockquote><p>浏览器安装了<code>metaMask</code>，浏览器中就有了 web3 实例。</p></blockquote><h3 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h3><blockquote><p>“IPFS 全称是 Inter Planetary File System,直接翻译的话叫做“星际文件系统”,它由 Protocol Lab 提出,是一种点对点(P2P)的分布式文件系统。不过虽然说它是文件系统,是一种用来存储数据的技术,但更确切的说 IPFS 是一种传输协议。”</p></blockquote><p>ipfs 可以通过多种方式操作，也有 nodejs 的版本。<a href="https://github.com/ipfs/js-ipfs" target="_blank" rel="noopener">https://github.com/ipfs/js-ipfs</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ipfs --global</span><br></pre></td></tr></table></figure><p>全局安装以后，可以直接在命令窗口中进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsipfs --help</span><br></pre></td></tr></table></figure><p>就可以直接查看它的所有命令。下面命令是简单演示，上传一个本地文件，并查看和同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jsipfs init</span><br><span class="line">jsipfs add file.html</span><br><span class="line">jsipfs cat &lt;hash&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;hash&gt;</code> 是上传的时候生成的 hash 值，通过这个就可以直接在网页或者命令查看上传的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入框禁止输入表情和特殊符号</title>
      <link href="/2020/01/09/%E8%BE%93%E5%85%A5%E6%A1%86%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E8%A1%A8%E6%83%85%E5%92%8C%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
      <url>/2020/01/09/%E8%BE%93%E5%85%A5%E6%A1%86%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E8%A1%A8%E6%83%85%E5%92%8C%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>react+ant Design<br>我使用的 Input 组件。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>实现方式很简单，就是在 onChange 事件中过滤掉表情和特殊符号。</p><h3 id="过滤方法封装"><a href="#过滤方法封装" class="headerlink" title="过滤方法封装"></a>过滤方法封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">clearEmoji</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> regEmoji = <span class="regexp">/[^\u0020-\u007E\u00A0-\u00BE\u2E80-\uA4CF\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF\u0080-\u009F\u2000-\u201f\u2026\u2022\u20ac\r\n]/g</span>;</span><br><span class="line">  <span class="keyword">return</span> text.replace(regEmoji, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">clearEmojiAndSymbol</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> regSymbol = <span class="regexp">/[`~!@#$%^&amp;*()_\-+=&lt;&gt;?:"&#123;&#125;|,.\/;\\[\]·~！@#￥%……&amp;*（）——\-+=&#123;&#125;|《》？：“”【】、；‘’，。、]/g</span>;</span><br><span class="line">  <span class="keyword">return</span> clearEmoji(text).replace(regSymbol, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Input</span><br><span class="line">  size=<span class="string">"large"</span></span><br><span class="line">  disabled=&#123;isDisable&#125;</span><br><span class="line">  value=&#123;account&#125;</span><br><span class="line">  onChange=&#123;<span class="keyword">this</span>.onChangeAccount&#125;</span><br><span class="line">  maxLength=&#123;<span class="number">20</span>&#125;</span><br><span class="line">  placeholder=<span class="string">"请填写登录账号（至少包含一个字母）"</span></span><br><span class="line">/&gt;;</span><br><span class="line"></span><br><span class="line">onChangeAccount = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; onChange &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  onChange(<span class="string">"account"</span>, clearEmojiAndSymbol(e.target.value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="汉字只能打印一个的坑"><a href="#汉字只能打印一个的坑" class="headerlink" title="汉字只能打印一个的坑"></a>汉字只能打印一个的坑</h3><p>在测试上面的方法时，一切都很顺利，但是在测试输入汉字时，有个奇怪的现象，就是输入汉字的时候，当打出第二个汉字时，搜狗输入法的框就消失了，打印的拼音就被自动填充到输入框中。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>经过测试，如果不走验证特殊字符的方法就没问题，说明不是 replace 的时候影响了输入法，于是在验证特殊字符的方法中 debugger 了一下。</p><blockquote><p>原来是因为输入法在输入多个汉字的时候，每个拼音之间有一个单引号<code>&#39;</code>；<br>这样导致匹配成功，所以被 replace 了，输入结果被改变了;<br>输入法得到的只是字母，没有单引号，也就没有匹配的汉字，输入框就自动关闭了。</p></blockquote><p><strong>解决方法</strong><br>把匹配特殊字符串中的单引号去掉，就没这个问题了，哈哈，所以这个有个小漏洞就是单引号是可以输入的，小声告诉你</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些npm启动用到的插件</title>
      <link href="/2020/01/09/%E9%82%A3%E4%BA%9Bnpm%E5%90%AF%E5%8A%A8%E7%94%A8%E5%88%B0%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/01/09/%E9%82%A3%E4%BA%9Bnpm%E5%90%AF%E5%8A%A8%E7%94%A8%E5%88%B0%E7%9A%84%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="npm-run-all"><a href="#npm-run-all" class="headerlink" title="npm-run-all"></a>npm-run-all</h3><p>当我们全栈开发时，可能需要启动一个服务的命令窗口，一个启动前端的命令窗口，这样每次打开两个窗体口比较麻烦。<br>使用<code>npm-run-all</code> 可以多个命令一起执行。并且可定义并行或同步执行。并且跨平台。<br><a href="https://github.com/codepandy/react_ssr" target="_blank" rel="noopener">参考例子</a>服务端渲染中有用到</p><blockquote><p><code>npm</code>也提供了多命令同时执行的语法，使用<code>&amp;</code>或<code>&amp;&amp;</code>符号连接多个命令即可，但是<code>window</code>平台不支持<code>&amp;</code>。</p></blockquote><h3 id="cross-env"><a href="#cross-env" class="headerlink" title="cross-env"></a>cross-env</h3><p>由于 mac 和 window 的环境变量写法不一样，使用<code>cross-env</code>解决跨平台环境变量定义</p><h3 id="Concurrently"><a href="#Concurrently" class="headerlink" title="Concurrently"></a>Concurrently</h3><p>这也是一个解决多个命令窗口的问题，可以指定同时需要运行的多条命令。</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目性能和规范总结</title>
      <link href="/2020/01/09/%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E5%92%8C%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/09/%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E5%92%8C%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="使用-eslint-格式化指定文件"><a href="#使用-eslint-格式化指定文件" class="headerlink" title="使用 eslint 格式化指定文件"></a>使用 eslint 格式化指定文件</h3><p>在<code>package.json</code>文件中增加通过 eslint 格式代码的方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node scripts/start.js",</span><br><span class="line">  "build": "node scripts/build.js",</span><br><span class="line">  "test": "node scripts/test.js",</span><br><span class="line">  "format": "eslint src/**/*.&#123;jsx,js&#125; --fix", // 这行的配置</span><br><span class="line">  "deploy": "gh-pages -d build"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行<code>npm run format</code>就会使用<code>eslint</code>的规则对<code>src</code>路径下的<code>jsx</code>和<code>js</code>文件进行格式化。<br>使用的规则可以在<code>eslintConfig</code>字段就行配置，比如默认使用的是 react-app 的规则。这个规则非常有限。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"eslintConfig": &#123;</span><br><span class="line">  "extends": "react-app",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 eslint 推荐的规则进行格式化。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"eslintConfig": &#123;</span><br><span class="line">  "extends": [</span><br><span class="line">        “eslint:recommended”,</span><br><span class="line">        <span class="string">"react-app"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写格式规则"><a href="#重写格式规则" class="headerlink" title="重写格式规则"></a>重写格式规则</h3><p>在 eslintConfig 中的 rule 字段进行设置。比如下面是要求 jsx 的缩进是 4 个空格的空白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &quot;eslintConfig&quot;: &#123;</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">        “eslint:recommended”,</span><br><span class="line">        &quot;react-app&quot;</span><br><span class="line">  ],</span><br><span class="line"> &quot;rules&quot;:&#123;</span><br><span class="line">        &quot;react&#x2F;jsx-indent&quot; :[“error”,4]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>npm run format</code>后，不符合规则的文件将被修复成符合规则的格式。</p><h3 id="提交的时候自动格式化"><a href="#提交的时候自动格式化" class="headerlink" title="提交的时候自动格式化"></a>提交的时候自动格式化</h3><p>提交的时候做校验，需要用到 git 的 hooks，由于自己配置比较麻烦，可以使用第三方的公交<code>husky</code></p><p>另外需要配合 lint-staged，lint-staged 是被 husky 进行调用，然后进行规则验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i husky lint-staged -D</span><br></pre></td></tr></table></figure><p>安装完成后后 package.json 中进行配置。增加根字段 husky。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"husky":&#123;</span><br><span class="line">    "hooks":&#123;</span><br><span class="line">          "pre-commit":"lint-staged"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">"lint-staged":&#123;</span><br><span class="line">    "*.&#123;js,jsx&#125;":[</span><br><span class="line">            "eslint --fix",</span><br><span class="line">             <span class="string">"git add "</span></span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是对 pre-commit 进行了设置，其实 hooks 有很多种。<br>上面的配置意思是：提交之前执行 lint-staged 命令（在 modules 的 bin 文件夹中可以找到）， 然后配置 lint-staged 命令的规则。<br>当执行<code>git commit -am &quot;test&quot;</code>时，就会自动执行 lint-staged 的规则。</p><h3 id="使用-prettier-进行格式化"><a href="#使用-prettier-进行格式化" class="headerlink" title="使用 prettier 进行格式化"></a>使用 prettier 进行格式化</h3><p>由于 eslint 的格式化功能比较弱，并且支持的文件格式也不多，所以使用更强大的 prettier 会更合适，prettier 不仅能格式化 js、jsx 还能格式化 css 和 md 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i prettier -D</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"lint-staged":&#123;</span><br><span class="line">    "*.&#123;js,jsx&#125;":[</span><br><span class="line">            "prittier --write",</span><br><span class="line">            "eslint --fix",</span><br><span class="line">             <span class="string">"git add "</span></span><br><span class="line">      ],</span><br><span class="line">    "*.&#123;css,md&#125;":[</span><br><span class="line">          "prittier --write",</span><br><span class="line">          <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个改动会比较大，所以开发的时候配置的规则最好就是 prettier，不然提交后代码变动较大。</p><p>可以在根目录创建 prettier 的配置文件 prettier.config.js，来自定义规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  tabWidth: <span class="number">4</span>,</span><br><span class="line">  singleQuote: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>使用了 husky 后，手动执行命令的方式就不要了。</p></blockquote><h3 id="分析各个模块的代码体积"><a href="#分析各个模块的代码体积" class="headerlink" title="分析各个模块的代码体积"></a>分析各个模块的代码体积</h3><p>使用<code>webpack-bundle-analyzer</code>可以分析各个模块的体积大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">"webpack-bundle-analyzer"</span>).BundleAnalyzerPlugin;</span><br></pre></td></tr></table></figure><p>在 plugins 中增加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">      <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(....</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>配置好后，重新启动程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>这次启动除了原本服务之外，还会启动并打开一个<code>http://127.0.0.1:8888/</code>的服务，打开这个就能看到各个模块的体积了。<br>这种方式看到是开发模式下的体积，意义不大，看到打包后放到生产环境上的体积才是有意义的。<br>安装了这个插件后，执行打包后也会自动启动 8888 服务，这时候看到的就是生产环境上的体积了(注意：把原来启动的 8888 关掉，不然端口冲突)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="禁止打包的时候自动启动服务"><a href="#禁止打包的时候自动启动服务" class="headerlink" title="禁止打包的时候自动启动服务"></a>禁止打包的时候自动启动服务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">      <span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">            openAnalyzer: <span class="literal">false</span>, <span class="comment">//是否打开8888服务</span></span><br><span class="line">            analyzerMode: <span class="string">"static"</span>, <span class="comment">// 生成静态的html文件</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(....</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样打包后会生成一个 report.html 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>可以在 build 的 build 目录启个服务，访问 report.html 查看结果。使用 serve</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/</span><br><span class="line">serve</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:5000/report.html可以看到相通的结果。" target="_blank" rel="noopener">http://localhost:5000/report.html可以看到相通的结果。</a></p><p>可以控制是否生成分析文件，不然放到生产环境就不好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">     proces.env.GENERATE_BUNDLE_ANALYZER===<span class="string">"true"</span>&amp;&amp;<span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">            openAnalyzer: <span class="literal">false</span>, <span class="comment">//是否打开8888服务</span></span><br><span class="line">            analyzerMode: <span class="string">"static"</span>, <span class="comment">// 生成静态的html文件</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron入门笔记</title>
      <link href="/2020/01/08/Electron%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/08/Electron%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>讲解 electron 的一些入门知识。</p><a id="more"></a><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程和线程就像车间和车间中各个车间的关系。线程是进程的一部分。</p><h3 id="它们的区别"><a href="#它们的区别" class="headerlink" title="它们的区别"></a>它们的区别</h3><ol><li>内存<br>计算机会给每个进程分配单独的内存空间，通常情况下进程之间不共享内存；线程在进程内部共享进程的内存。</li><li>通信机制<br>通常情况下进程之间是不可互通的，通过一些手段也可实现，比如 IPC，但是线程之间通信就很方便快捷</li><li>量级的区别<br>线程更轻量级，创建更快，使用资源更少</li></ol><h2 id="Electron、Chromium-和进程之间的关系"><a href="#Electron、Chromium-和进程之间的关系" class="headerlink" title="Electron、Chromium 和进程之间的关系"></a>Electron、Chromium 和进程之间的关系</h2><p>Chromium 是由一个主进程和多个渲染进程组成，和浏览器一样，浏览器窗口就是主进程(即使打开多个窗口也是一个主进程)，每个 tab 就是一个渲染进程，主进程就是一个指挥官，负责对每个渲染进程进行控制和分配。<br>Electron 也一样，也是一个主进程和多个子进程的关系。</p><h3 id="Chromium-主进程的特点"><a href="#Chromium-主进程的特点" class="headerlink" title="Chromium 主进程的特点"></a>Chromium 主进程的特点</h3><ol><li>可以使用和系统对接的 Electron API - 比如创建菜单、上传文件等等。</li><li>负责创建渲染进程 - Render Process</li><li>全面支持 Node.js 语法</li><li>只有一个，作为整个程序的入口点</li></ol><h3 id="渲染进程-Render-Process-的特点"><a href="#渲染进程-Render-Process-的特点" class="headerlink" title="渲染进程 - Render Process 的特点"></a>渲染进程 - Render Process 的特点</h3><ol><li>可以有多个，每个对应一个窗口</li><li>每个都是一个单独的进程</li><li>全面支持 Node.js 和 DOM API</li><li>可以使用一部分 Electron 提供的 API</li></ol><h3 id="主进程和渲染进程可访问-Electron-API-的范围"><a href="#主进程和渲染进程可访问-Electron-API-的范围" class="headerlink" title="主进程和渲染进程可访问 Electron API 的范围"></a>主进程和渲染进程可访问 Electron API 的范围</h3><p><img src="https://upload-images.jianshu.io/upload_images/1348523-d3b387de10300a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主进程和渲染进程可访问Electron API的范围"></p><h2 id="BrowserWindow"><a href="#BrowserWindow" class="headerlink" title="BrowserWindow"></a>BrowserWindow</h2><p>创建一个窗口，也即使一个 tab，一个渲染进程- Render Process.</p><h3 id="使用-nodemon-帮助开发"><a href="#使用-nodemon-帮助开发" class="headerlink" title="使用 nodemon 帮助开发"></a>使用 nodemon 帮助开发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“start”:&quot;nodemon --watch  main.js --exec \&quot;electron .\&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="进程之间的通讯方式"><a href="#进程之间的通讯方式" class="headerlink" title="进程之间的通讯方式"></a>进程之间的通讯方式</h2><ul><li>Electron 使用 IPC (interprocess communication) 在进程之间进行通讯</li></ul><p>进程之间为什么要通讯？<br>因为主进程和渲染进程可访问的资源不同，比如渲染进程需要通过主进程访问一些系统资源等等。</p><h3 id="devtron-插件"><a href="#devtron-插件" class="headerlink" title="devtron 插件"></a>devtron 插件</h3><p>使用这个插件可以方便我们调试 electron 程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入</span><br><span class="line">require(&quot;devtron&quot;).install();</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">win.loadFile(&quot;index.html&quot;);</span><br><span class="line">&#x2F;&#x2F; 自动打开devtron工具</span><br><span class="line">win.webContents.openDevTools();</span><br></pre></td></tr></table></figure><h3 id="进程之间进行通讯"><a href="#进程之间进行通讯" class="headerlink" title="进程之间进行通讯"></a>进程之间进行通讯</h3><p>在主进程中注册监听事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow, ipcMain &#125; = <span class="built_in">require</span>(<span class="string">"electron"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * message 自定义的事件名称</span></span><br><span class="line"><span class="comment"> * event 事件对象</span></span><br><span class="line"><span class="comment"> * arg 事件参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ipcMain.on(<span class="string">"message"</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">  <span class="comment">// 主进程回复渲染进程信息,事件名reply可自定义</span></span><br><span class="line">  event.reply(<span class="string">"reply"</span>, <span class="string">"this is a message from main process."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>渲染进程中注册和监听事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">"electron"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信息</span></span><br><span class="line">ipcRenderer.send(<span class="string">"message"</span>, <span class="string">"this is a message from render process."</span>);</span><br><span class="line"></span><br><span class="line">监听主进程回复的信息;</span><br><span class="line">ipcRenderer.on(<span class="string">"reply"</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"main_msg"</span>).innerHTML = arg;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="remote-进程之间简单的通讯方式"><a href="#remote-进程之间简单的通讯方式" class="headerlink" title="remote 进程之间简单的通讯方式"></a>remote 进程之间简单的通讯方式</h3><p>在渲染进程的 js 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123; BrowserWindow &#125; &#x3D; require(&quot;electron&quot;).remote;</span><br><span class="line"></span><br><span class="line">let win &#x3D; new BrowserWindow(&#123; height: 400, width: 400 &#125;);</span><br><span class="line">win.loadURL(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;);</span><br></pre></td></tr></table></figure><h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><ul><li>避免全局安装</li><li>可以使用已安装模块</li></ul><h3 id="electrong-需要注意的地方"><a href="#electrong-需要注意的地方" class="headerlink" title="electrong 需要注意的地方"></a>electrong 需要注意的地方</h3><ol><li>package.json 中配置 main 字段 2.在根目录创建 main.js，这里写主进程的代码</li></ol>]]></content>
      
      
      <categories>
          
          <category> Electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能</title>
      <link href="/2020/01/08/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
      <url>/2020/01/08/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>总结一些前端性能的笔记。</p><a id="more"></a><h2 id="请求过程中潜在的一些性能优化点"><a href="#请求过程中潜在的一些性能优化点" class="headerlink" title="请求过程中潜在的一些性能优化点"></a>请求过程中潜在的一些性能优化点</h2><ol><li>dns 是否可以通过缓存减少 dns 查询时间？</li><li>网络请求的过程走最近的网络环境？</li><li>相同的静态资源是否可以缓存？</li><li>能否减小 http 请求的大小？</li><li>减少 http 请求数量</li><li>服务端渲染</li></ol><h2 id="资源压合并与压缩"><a href="#资源压合并与压缩" class="headerlink" title="资源压合并与压缩"></a>资源压合并与压缩</h2><p>这涉及到两方面的内容</p><ol><li>减少 http 请求数量</li><li>减小请求资源的大小</li></ol><h3 id="具体需要处理的方面"><a href="#具体需要处理的方面" class="headerlink" title="具体需要处理的方面"></a>具体需要处理的方面</h3><ul><li>html 压缩</li><li>css 压缩</li><li>js 的压缩和混乱</li><li>文件合并</li><li>开启 gzip</li></ul><h4 id="html-压缩"><a href="#html-压缩" class="headerlink" title="html 压缩"></a>html 压缩</h4><p>HTML 代码压缩就是压缩这些在文本文件中有意义，但是在 HTML 中不显示的字符，包括空格、制表符、换行符等，还有一些其他意义的字符，比如 HTML 注释也可以被压缩。<br>这些在我们写代码时有帮助，但对浏览器的解析没有意义，因此都可以被省略掉。</p><ul><li>蓝色是没压缩的 HTML</li><li>红色是进行了 HTML 压缩</li><li>绿色是进行了 gzip 压缩<br>仅仅进行 HTML 压缩，貌似压缩效果不是太明显，其实不然，比如谷歌这样的公司，他的流量站整个互联网的 40%，如果 1M 减少一个字节，每年就可以节省流量近 500TB，相当于上亿元的支出，当然如果网站的流量很小，那就不再讨论范围内了。</li></ul><h3 id="如何进行-html-压缩"><a href="#如何进行-html-压缩" class="headerlink" title="如何进行 html 压缩"></a>如何进行 html 压缩</h3><ol><li>在线的网站进行压缩<br>但是现在前端开发都会使用构建工具，所以这个一般用不上。</li><li><code>nodejs</code>提供的 <code>html-minifier</code> 工具</li><li>后端模板引擎渲染压缩</li></ol><h3 id="css-压缩"><a href="#css-压缩" class="headerlink" title="css 压缩"></a>css 压缩</h3><ul><li>无效代码删除</li><li>css 语义合并<br>一些语义重复的代码进行合并<br>如何进行 css 压缩</li></ul><ol><li>使用在线网站进行压缩</li><li>使用 html-minifier 对 html 中的 css 进行压缩</li><li>使用 clean-css 对 css 进行压缩</li></ol><h3 id="js-压缩与混乱"><a href="#js-压缩与混乱" class="headerlink" title="js 压缩与混乱"></a>js 压缩与混乱</h3><ol><li>无效的字符删除</li><li>剔除注释</li><li>代码语义的缩进和优化<br>比如变量、方法名替换成单字符等等</li><li>代码保护</li></ol><p>如何进行 js 压缩</p><ol><li>使用在线网站进行压缩</li><li>使用 html-minifier 对 html 中的 css 进行压缩</li><li>使用 unlifyjs2 对 js 进行压缩</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发并发布和更新一个npm包</title>
      <link href="/2020/01/08/%E5%BC%80%E5%8F%91%E5%B9%B6%E5%8F%91%E5%B8%83%E5%92%8C%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AAnpm%E5%8C%85/"/>
      <url>/2020/01/08/%E5%BC%80%E5%8F%91%E5%B9%B6%E5%8F%91%E5%B8%83%E5%92%8C%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AAnpm%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>最近开发了一个 npm 包，并发布到了官网上，下面记录下开发过程。<br><a href="https://github.com/codepandy/tabheader_react" target="_blank" rel="noopener">github 代码地址</a></p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>注册 npm 账号</li><li>认证 npm，不然不能发布包；（会给你发认证邮件）</li><li>设置 npm 源为官网</li></ol><h3 id="查看和设置-npm-源"><a href="#查看和设置-npm-源" class="headerlink" title="查看和设置 npm 源"></a>查看和设置 npm 源</h3><p>在国内我们通常都设置成了淘宝的仓库（<a href="https://registry.npm.taobao.org），这样是发布不了的。需要设置回官网的仓库连接（https://registry.npmjs.org/）。" target="_blank" rel="noopener">https://registry.npm.taobao.org），这样是发布不了的。需要设置回官网的仓库连接（https://registry.npmjs.org/）。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看</span><br><span class="line">npm config get registry</span><br><span class="line">// 设置</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>由于我使用的 react，搭建环境就是搭建 react 的开发环境。这里不做过多介绍。<br>只介绍几个发布组件相关的配置和注意事项。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><ul><li>main 字段设置的就是在引入你的程序时，执行的文件。</li><li>files 设置的是要发布到 npm 的文件。如果省略掉这一项，所有文件包括源代码会被一起上传到 npm</li><li>keywords 设置搜索关键字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"name"</span>: <span class="string">"tabheader-react"</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="string">"1.0.2"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">"a tabheader component for react."</span>,</span><br><span class="line"><span class="string">"main"</span>: <span class="string">"./build/bundle.js"</span>,</span><br><span class="line"><span class="string">"files"</span>: [</span><br><span class="line">  <span class="string">"build"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"webpack-dev-server --config webpack.dev.js"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --config webpack.pro.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"keywords"</span>: [</span><br><span class="line">  <span class="string">"react"</span>,</span><br><span class="line">  <span class="string">"tab"</span>,5</span><br><span class="line">  <span class="string">"header"</span>,</span><br><span class="line">  <span class="string">"tabheader"</span>,</span><br><span class="line">  <span class="string">"tabheader-react"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"author"</span>: <span class="string">"wenmu"</span>,</span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.cn/files/package.json/" target="_blank" rel="noopener">package.json 详情介绍</a></p><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>webpack 的配置需要注意的就是生产环境时，设置<code>libraryTarget</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &quot;build&quot;),</span><br><span class="line">  filename: &quot;bundle.js&quot;,</span><br><span class="line">  libraryTarget: &quot;commonjs2&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>libraryTarget 设置暴露的包类型，默认是 var，也就是变量的方式。这个要设置成模块的方式，这样可以通过模块的方式来引入。</p><h3 id="babel-的配置"><a href="#babel-的配置" class="headerlink" title="babel 的配置"></a>babel 的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;, &quot;@babel&#x2F;preset-react&quot;],</span><br><span class="line">  &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-proposal-class-properties&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>程序开发完后，就可以打包发布了。上面也配置了发布的文件是哪些。<br>打包和发布其实也很简单，就是单纯的把组件的代码打包然后发布就行了。<br>在组件代码的根目录执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm build</span><br></pre></td></tr></table></figure><p>打包成功后，登录 npm 然后发布组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 登录成功后，执行发布命令</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>成功后，就可以在<a href="https://www.npmjs.com/settings/wenmu/packages" target="_blank" rel="noopener">npm 官网</a>查看你发布的 package，并且在<code>npm</code>也能搜索到了。</p><h2 id="本地调试-link"><a href="#本地调试-link" class="headerlink" title="本地调试 link"></a>本地调试 link</h2><p>在开发组件时，还没发布到仓库，如何安装调试呢？这个可以使用<code>npm link</code>命令来实现。</p><h3 id="link组件到global-node-modules"><a href="#link组件到global-node-modules" class="headerlink" title="link组件到global node_modules"></a><code>link</code>组件到<code>global node_modules</code></h3><p>在组件的根目录执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><blockquote><p>如果组件文件是在根目录，那么 link 后，代码有改动，引用的项目里面立马会体现出来，但是如果代码是在 src 目录下，需要 build 代码项目中才能看到修改后的效果；也可以直接是 src 目录中 link</p></blockquote><p>使用下面命令查看是否 link 成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看全局安装的包</span><br><span class="line">npm list -g --depth 0</span><br></pre></td></tr></table></figure><h3 id="使用link的组件"><a href="#使用link的组件" class="headerlink" title="使用link的组件"></a>使用<code>link</code>的组件</h3><p>进入到项目的根目录，执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link your_component_name</span><br></pre></td></tr></table></figure><p>成功后，就可以在你的项目中使用组件了，使用方式和安装的组件一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import TabHeader from <span class="string">'tabheader_react'</span></span><br></pre></td></tr></table></figure><h3 id="解除link"><a href="#解除link" class="headerlink" title="解除link"></a>解除<code>link</code></h3><ol><li>在项目中解除<br>进入引用组件的根目录，执行命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink your_component_name</span><br></pre></td></tr></table></figure><ol start="2"><li>从<code>global node_modules</code>解除<br>进入组件的根目录，执行下面命令，注意后面不要跟组件名</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink</span><br></pre></td></tr></table></figure><h2 id="更新-npm-包"><a href="#更新-npm-包" class="headerlink" title="更新 npm 包"></a>更新 npm 包</h2><p>发布了 npm 包后，如果有修改，我们需要发布更新，步骤如下：</p><ol><li>提交代码，如果你的代码已经用<code>git</code>托管，先提交代码，不然发布会报错</li><li>修改版本号<br>修改版本号，官方提供了的命令，当执行后，package.json 文件会自动被修改。命令如下：<br>比如现在版本是 1.0.0</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 最后一位加1，执行命令后未：1.0.1</span><br><span class="line">npm version patch</span><br><span class="line"></span><br><span class="line">// 第二位加1，执行后：1.1.0</span><br><span class="line">npm version minor</span><br><span class="line"></span><br><span class="line">// 第一位加1，执行后：2.0.0</span><br><span class="line">npm version major</span><br></pre></td></tr></table></figure><ol start="3"><li>发布更新<br>通过上面修改过版本号后，执行下面命令重新发布，线上的就会被更新了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><h2 id="You-must-sign-up-for-private-packages"><a href="#You-must-sign-up-for-private-packages" class="headerlink" title="You must sign up for private packages"></a>You must sign up for private packages</h2><p>今天在发布包时，提示类似的名字已经有了，建议加上范围，如(“@wenmu/steps-react”)，但是加上后就报错了。一直提示<code>You must sign up for private packages</code>.</p><p>Scoped packages 会被自动发布为私有包，发布成公共的就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/db6113c94dbc" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/01/07/hello-world/"/>
      <url>/2020/01/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>create-react-app项目部署到Github Pages</title>
      <link href="/2019/05/25/create-react-app%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0GithubPages/"/>
      <url>/2019/05/25/create-react-app%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0GithubPages/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>本文讲解使用<code>create-react-app</code>创建的项目，如何部署<code>GitHub Pages</code>，以及这部署到过程中遇到到坑。</p><a id="more"></a><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>使用官网方式创建项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>弹出配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><h3 id="Github-Pages部署讲解"><a href="#Github-Pages部署讲解" class="headerlink" title="Github Pages部署讲解"></a><code>Github Pages</code>部署讲解</h3><p>把项目部署成<code>github pages</code>，在<code>github</code>上点开项目到设置，翻到<code>Github Pages</code>设置处，可以看到<code>Github Pages</code>只能使用<code>master</code>、<code>gh-pages</code>分支或者<code>master</code>下面的<code>docs</code>文件夹。<br>我们这里使用的是<code>gh-pages</code>分支的方式来创建。</p><h3 id="安装gh-pages"><a href="#安装gh-pages" class="headerlink" title="安装gh-pages"></a>安装<code>gh-pages</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gh-pages --save-dev</span><br></pre></td></tr></table></figure><p>通过<code>gh-pages</code>中间件可以把<code>build</code>文件下到文件推送到<code>github</code>，并且创建<code>gh-pages branch</code>。</p><h3 id="修改-package-json"><a href="#修改-package-json" class="headerlink" title="修改 package.json"></a>修改 package.json</h3><p>增加 homepage</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"name": "react_demo",</span><br><span class="line">"version": "1.1.0",</span><br><span class="line">"private": true,</span><br><span class="line">"homepage": "./",  //加上这一句</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>homepage</code>不要设置成<code>github page</code>上生成的那个链接路径，比如<code>https://username.github.io/react_demo/</code>。<br>如果设置成上面的连接，<code>build</code>打的包会这所有路径前面加上<code>react_demo</code>。<br>比如<code>index.html</code>文件中对同等目录下的文件引用应该是<code>src=&#39;./index.css&#39;</code>,结果会变成<code>src=&#39;./react_demo/index.css&#39;</code>,这样部署后肯定无法访问，所有资源都找不到。</p></blockquote><p>增加<code>npm scripts</code>命令，推送<code>gh-pages</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">        ...</span><br><span class="line">     + "deploy": "gh-pages -d build" //加上这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-d 后面是文件夹 ###推送项目<br><code>GitHub Pages</code>只是部署项目，<code>react</code>代码直接放上去是识别不了的，所以部署的是打包编译后到代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>编译后就可以推送了,执行上面配置的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><p>这时<code>github</code>上项目就多出了一个<code>gh-pages</code>的<code>branch</code>，在设置中<code>Github Pages</code>处选择<code>gh-pages</code>分支保存，部署完成。<br>点击生成的连接，查看是否部署成功。</p><p>2019-05-25</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> create-react-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你写一个react脚手架命令行CLI工具</title>
      <link href="/2019/04/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AAreact%E8%84%9A%E6%89%8B%E6%9E%B6%E5%91%BD%E4%BB%A4%E8%A1%8CCLI%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/04/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AAreact%E8%84%9A%E6%89%8B%E6%9E%B6%E5%91%BD%E4%BB%A4%E8%A1%8CCLI%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近封装了一些 react 的组件，每次都需要从头配置，比价麻烦，就动了写一个工具的念头，也想扩展下自己的技术。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先初始化一个简单的 node 项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>也可以在 github 上创建好项目，然后 clone 下来。</p><p>先介绍下要用到的插件：</p><ul><li>commander.js，可以自动的解析命令和参数，用于处理用户输入的命令。</li><li>download-git-repo，下载并提取 git 仓库，用于下载项目模板。</li><li>inquirer.js，通用的命令行用户界面集合，用于和用户进行交互。</li><li>ejs.js，模板引擎，将用户提交的信息动态填充到文件中。</li><li>ora，下载过程久的话，可以用于显示下载中的动画效果。</li><li>chalk，可以给终端的字体加上颜色。</li><li>log-symbols，可以在终端上显示出 √ 或 × 等的图标。</li><li>shelljs，执行终端命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i commander download-git-repo inquirer ejs ora chalk <span class="built_in">log</span>-symbols shelljs -S</span><br></pre></td></tr></table></figure><p><code>CLI</code> 的命令交互方式就是使用 <code>commander</code> 来实现的。</p><h2 id="先体验下自己写的-CLI"><a href="#先体验下自己写的-CLI" class="headerlink" title="先体验下自己写的 CLI"></a>先体验下自己写的 CLI</h2><p>为了熟悉下 <code>commander</code> 库，先写一个简单的 cli 工具，简单操作下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node  //这一行必须有，指定是以node环境来运行</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; program &#125; = <span class="built_in">require</span>(<span class="string">"commander"</span>);</span><br><span class="line"><span class="keyword">const</span> package = <span class="built_in">require</span>(<span class="string">"./package.json"</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .version(package.version, <span class="string">"-v --version"</span>, <span class="string">"查看当前版本"</span>)</span><br><span class="line">  .command(<span class="string">"init &lt;name&gt;"</span>)</span><br><span class="line">  .action(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`the name is :<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把进程process的参数传递给commander</span></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure><p>version 的默认选项标识为-V 和–version，当存在时会打印版本号并退出。上面我们重新定义了选项标识。<br>查看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node index.js -v</span><br><span class="line">//1.0.0</span><br></pre></td></tr></table></figure><p>配置命令执行文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">  <span class="string">"bin"</span>: &#123;</span><br><span class="line">    <span class="string">"c-rc-c"</span>: <span class="string">"index.js"</span> <span class="comment">// key就是命令名称</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>这里就可以看出 main 和 bin 的区别了，main 是指定引入组件时(import)调用的文件，bin 是安装组件后，指定执行的命令所关联的文件。</p></blockquote><p>上面的代码一个简单的 cli 就已经写好了，安装后，执行<code>c-rc-c -v</code>就会看到结果。</p><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>这个就是组件本地 link 的功能了；在组件 index.js 所在的目录中执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>建一个临时文件夹，安装，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line"><span class="built_in">cd</span> tmp</span><br><span class="line">npm init -y</span><br><span class="line">npm link create-react-component // 安装</span><br><span class="line">c-rc-c -v //1.0.0</span><br><span class="line">c-rc-c init zhangsan // the name is : zhangsan</span><br></pre></td></tr></table></figure><p>下面是运行查看各个插件的效果。<br><img src="https://i.loli.net/2020/04/01/9LsBSwipbV1tyH3.png" alt="cli-1.png"><br><img src="https://i.loli.net/2020/04/01/TxLc9n3UoEdAWza.png" alt="cli-view-2.png"></p><h2 id="完善脚手架-Cli"><a href="#完善脚手架-Cli" class="headerlink" title="完善脚手架 Cli"></a>完善脚手架 Cli</h2><p>脚手架 cli 的功能说白了，就是生成开发组件的代码。这些代码已经帮你把要使用到的依赖已经安装好，你只要专心写你的组件就行了。</p><h3 id="定义你的脚手架模板"><a href="#定义你的脚手架模板" class="headerlink" title="定义你的脚手架模板"></a>定义你的脚手架模板</h3><p>由于开发用到的依赖和环境基本上是相同的，有极个别是根据个人需要设置的，所以我们可以写好一个模板，把需要变动的部分动态生成即可。<br>模板文件你可以放到 github 仓库里面，也可以和 cli 文件放在一起；</p><p>我这里主要设置了项目名称、作者、关键字、github 的仓库、和 css 预处理器等这些是动态设置的，涉及到文件有 package.json 和 webpack.base.js 这两个。其他的文件都不变，所以直接下载下来就行。</p><h3 id="模板引擎的选择"><a href="#模板引擎的选择" class="headerlink" title="模板引擎的选择"></a>模板引擎的选择</h3><p>说到模板引擎，不得不说<a href="http://handlebarsjs.com./zh/guide/#%E4%BB%80%E4%B9%88%E6%98%AF-handlebars%EF%BC%9F" target="_blank" rel="noopener">handlebars</a>、<a href="https://ejs.bootcss.com/#features" target="_blank" rel="noopener">ejs</a>；另外看到还有使用<code>consolidate</code>和<code>Metalsmith</code>；</p><p>我使用的是<code>ejs</code>，它的文件格式是<code>*.ejs</code>，你也可以选择<code>handlebars</code>，它的文件格式是<code>*.hbs</code>；</p><p><code>package.json</code>的内容是<code>json</code>，读取出来可以直接修改，然后再写入文件即可，这就不用再专门使用一个模板引擎了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> packagePath = path.resolve(process.cwd(), name, <span class="string">"package.json"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(chalk.yellow(<span class="string">`package.json地址：<span class="subst">$&#123;packagePath&#125;</span>`</span>));</span><br><span class="line"><span class="keyword">const</span> packageString = fs.readFileSync(packagePath, <span class="string">"utf8"</span>);</span><br><span class="line"><span class="keyword">let</span> packageJson = <span class="built_in">JSON</span>.parse(packageString);</span><br><span class="line">packageJson = &#123;</span><br><span class="line">  ...packageJson,</span><br><span class="line">  author,</span><br><span class="line">  description,</span><br><span class="line">  keywords: keywords ? keywords.split(<span class="string">","</span>) : [],</span><br><span class="line">  repository: &#123;</span><br><span class="line">    type: <span class="string">`git`</span>,</span><br><span class="line">    url: <span class="string">`git+<span class="subst">$&#123;repository&#125;</span>`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  bugs: &#123;</span><br><span class="line">    url: <span class="string">`<span class="subst">$&#123;subRepository&#125;</span>/issues`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  homepage: <span class="string">`<span class="subst">$&#123;subRepository&#125;</span>#readme`</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(packagePath, <span class="built_in">JSON</span>.stringify(packageJson));</span><br></pre></td></tr></table></figure><p><code>webpakc</code>的配置文件生成，这个文件不能像<code>package.json</code>那样配置，这个使用<code>ejs</code>模板引擎来处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackTemplatePath = path.resolve(process.cwd(), name, <span class="string">"webpack.base.ejs"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(chalk.yellow(<span class="string">`webpack template 地址：<span class="subst">$&#123;webpackTemplatePath&#125;</span>`</span>));</span><br><span class="line"><span class="keyword">const</span> webpackTemplate = fs.readFileSync(webpackTemplatePath, <span class="string">"utf8"</span>);</span><br><span class="line"><span class="keyword">const</span> webpackString = ejs.render(webpackTemplate, &#123; cssPreprocessor &#125;);</span><br><span class="line"><span class="keyword">const</span> webpackFilePath = path.resolve(process.cwd(), name, <span class="string">"webpack.base.js"</span>);</span><br><span class="line">fs.writeFileSync(webpackFilePath, webpackString);</span><br><span class="line">webpackSpinner.succeed(<span class="string">"webpack 文件配置成功！"</span>);</span><br><span class="line">fs.unlinkSync(webpackTemplatePath); <span class="comment">// 删除模板文件</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>安装依赖使用了到了<code>shelljs</code>工具，这个是对<code>node</code>的<code>child_process</code>的封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shell.exec(</span><br><span class="line">  <span class="string">`cd <span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">  npm i`</span>,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      installDependenciesSpinner.fail(chalk.red(<span class="string">`依赖安装失败：<span class="subst">$&#123;error&#125;</span>`</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    installDependenciesSpinner.succeed(chalk.green(<span class="string">"依赖安装完成"</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="发布-CLI-到-npm-仓库"><a href="#发布-CLI-到-npm-仓库" class="headerlink" title="发布 CLI 到 npm 仓库"></a>发布 CLI 到 npm 仓库</h3><p>登录 npm，执行 npm 的发布命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p><a href="https://github.com/codepandy/create-react-component" target="_blank" rel="noopener">github 仓库地址</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在最新版Node中使用ES6语法-2019-03-27</title>
      <link href="/2019/03/27/%E5%9C%A8%E6%9C%80%E6%96%B0%E7%89%88Node%E4%B8%AD%E4%BD%BF%E7%94%A8ES6%E8%AF%AD%E6%B3%95-2019-03-27/"/>
      <url>/2019/03/27/%E5%9C%A8%E6%9C%80%E6%96%B0%E7%89%88Node%E4%B8%AD%E4%BD%BF%E7%94%A8ES6%E8%AF%AD%E6%B3%95-2019-03-27/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>node 中使用 ES6 语法，很简单，网上的文章写的太复杂,我根据网上的经验折腾了一下午，最后终结了下，几乎装个 babel 就能用的。<br>下面是我的使用过程，分享如何使用及遇到的问题。</p><a id="more"></a><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>首先的有<code>node</code>环境，这个不介绍，当前我的版本是<code>8.11.4</code> 1.初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>2.安装 babel<br>安装官网上介绍的操作就行，<a href="https://www.babeljs.cn/" target="_blank" rel="noopener">https://www.babeljs.cn/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli babel-preset-env</span><br></pre></td></tr></table></figure><p>创建  <a href="https://www.babeljs.cn/docs/usage/babelrc" target="_blank" rel="noopener"><code>.babelrc</code></a>  文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候已经配置完了，可以执行 ES6 语法了,但是<code>import</code>和<code>export</code>还是不支持的。</p><h3 id="检测对es6的支持情况"><a href="#检测对es6的支持情况" class="headerlink" title="检测对es6的支持情况"></a>检测对<code>es6</code>的支持情况</h3><p>安装<code>es-checker</code>来帮助我们查看对 es6 的支持情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev es-checker</span><br></pre></td></tr></table></figure><p>借助<code>npx</code>工具来运行<code>es-checker</code></p><blockquote><p><code>npx</code>的介绍可以看这篇文章：<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/02/npx.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx es-checker</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ECMAScript 6 Feature Detection (v1.4.1)</span><br><span class="line"></span><br><span class="line">Variables</span><br><span class="line">  √ <span class="built_in">let</span> and const</span><br><span class="line">  √ TDZ error <span class="keyword">for</span> too-early access of <span class="built_in">let</span> or const declarations</span><br><span class="line">  √ Redefinition of const declarations not allowed</span><br><span class="line">  √ destructuring assignments/declarations <span class="keyword">for</span> arrays and objects</span><br><span class="line">  √ ... operator</span><br><span class="line"></span><br><span class="line">...省略内容</span><br><span class="line"></span><br><span class="line">Module</span><br><span class="line">  × Module <span class="built_in">export</span> <span class="built_in">command</span></span><br><span class="line">  × Module import <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">Passes 39 feature Detections</span><br><span class="line">Your runtime supports 92% of ECMAScript 6</span><br><span class="line">=========================================</span><br></pre></td></tr></table></figure><blockquote><p>可以看到还是有一些不支持的。</p></blockquote><h3 id="测试-code"><a href="#测试-code" class="headerlink" title="测试 code"></a>测试 code</h3><p>.babelrc</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的配置其实就行了；但是我在看 babel 的文档时说设置 node 环境需要设置 targets，于是我的配置如下，但是我试了上面的配置也是可以的，下面的仅供参考。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"targets"</span>: &#123;</span><br><span class="line">          <span class="string">"node"</span>: <span class="string">"current"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"node"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"babel-cli"</span>: <span class="string">"^6.26.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="string">"es-checker"</span>: <span class="string">"^1.4.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stack.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stack = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      items.set(<span class="keyword">this</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line">    push(value) &#123;</span><br><span class="line">      <span class="keyword">let</span> stack = items.get(<span class="keyword">this</span>);</span><br><span class="line">      stack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    pop() &#123;</span><br><span class="line">      <span class="keyword">let</span> stack = items.get(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">      <span class="keyword">let</span> stack = items.get(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> stack.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">      <span class="keyword">let</span> stack = items.get(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> stack.length;</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">      <span class="keyword">let</span> stack = items.get(<span class="keyword">this</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(stack.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Stack;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">module</span>.exports.Stack = Stack;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Stack &#125; = <span class="built_in">require</span>(<span class="string">"./Stack.js"</span>);</span><br><span class="line"><span class="comment">//import &#123; Stack &#125; from "./Stack";</span></span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="string">"aaa"</span>);</span><br><span class="line">stack.print();</span><br></pre></td></tr></table></figure><p>在控制台中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br></pre></td></tr></table></figure><h3 id="解决-import-和-export-不能用"><a href="#解决-import-和-export-不能用" class="headerlink" title="解决 import 和 export 不能用"></a>解决 import 和 export 不能用</h3><p>其实<code>node</code>版本 9 以上就已经支持了，但是需要把文件名改成<code>*.mjs</code>,并且加上<code>--experimental-modules</code> 选项。</p><h3 id="升级-node"><a href="#升级-node" class="headerlink" title="升级 node"></a>升级 node</h3><p>介绍一个 node 升级的好工具，名字就叫<code>n</code>，具体可以去 npm 上查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure><p>执行如下命令进行升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n stable</span><br><span class="line">或</span><br><span class="line">n 10.15.3</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     install : node-v11.12.0</span><br><span class="line">       mkdir : /usr/<span class="built_in">local</span>/n/versions/node/11.12.0</span><br><span class="line">       fetch : https://nodejs.org/dist/v11.12.0/node-v11.12.0-darwin-x64.tar.gz</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">   installed : v11.12.0</span><br></pre></td></tr></table></figure><p>升级成功后，① 把文件都改成<code>*.mjs</code>，② 并把代码改成<code>import</code>和<code>export</code>的方式，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules arithmetic/index.mjs</span><br></pre></td></tr></table></figure><blockquote><p>上面两步都不能少。不然就执行不成功。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React虚拟DOM、Diff算法和生命周期的关系</title>
      <link href="/2018/04/25/React%E8%99%9A%E6%8B%9FDOM%E3%80%81Diff%E7%AE%97%E6%B3%95%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/04/25/React%E8%99%9A%E6%8B%9FDOM%E3%80%81Diff%E7%AE%97%E6%B3%95%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><blockquote><p>在这里的 setState 不会引起新的渲染</p></blockquote><h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h3><blockquote><p>在这里的 setState 不会引起新的渲染</p></blockquote><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h3><blockquote><p>不能在这里执行 setState</p></blockquote><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>componentDidMount 会在组件已经完成安装并且在浏览器中存在真实的 DOM 后调用，此时我们就可以完成原生事件的绑定《深入 react 技术栈》2.1.3</p><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><h3 id="ReactDOM"><a href="#ReactDOM" class="headerlink" title="ReactDOM"></a>ReactDOM</h3><p>DOM 真正被添加到 HTML 中的生命周期方法是 componentDidMount 和 componentDidUpdate 方法。在这两个方法中，我们可以获取真正的 DOM 元素</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生命周期</title>
      <link href="/2018/04/24/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/04/24/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>做个简单记载吧，老模糊，哈哈</p><h3 id="初次加载"><a href="#初次加载" class="headerlink" title="初次加载"></a>初次加载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount;</span><br><span class="line"></span><br><span class="line">render;</span><br><span class="line"></span><br><span class="line">ref;</span><br><span class="line"></span><br><span class="line">componentDidMount;</span><br></pre></td></tr></table></figure><h3 id="设置-props"><a href="#设置-props" class="headerlink" title="设置 props"></a>设置 props</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps);</span><br><span class="line"></span><br><span class="line">shouldComponentUpdate;</span><br><span class="line"></span><br><span class="line">componentWillUpdate;</span><br><span class="line"></span><br><span class="line">render;</span><br><span class="line"></span><br><span class="line">ref;</span><br><span class="line"></span><br><span class="line">componentDidUpdate;</span><br></pre></td></tr></table></figure><h3 id="设置-state"><a href="#设置-state" class="headerlink" title="设置 state"></a>设置 state</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate;</span><br><span class="line"></span><br><span class="line">componentWillUpdate;</span><br><span class="line"></span><br><span class="line">render;</span><br><span class="line"></span><br><span class="line">ref;</span><br><span class="line"></span><br><span class="line">componentDidUpdate;</span><br><span class="line"></span><br><span class="line">setStateCallback;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三阶魔方还原步骤</title>
      <link href="/2018/04/16/%E4%B8%89%E9%98%B6%E9%AD%94%E6%96%B9%E8%BF%98%E5%8E%9F%E6%AD%A5%E9%AA%A4/"/>
      <url>/2018/04/16/%E4%B8%89%E9%98%B6%E9%AD%94%E6%96%B9%E8%BF%98%E5%8E%9F%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步拼白色十字"><a href="#第一步拼白色十字" class="headerlink" title="第一步拼白色十字"></a>第一步拼白色十字</h2><p>这步比较简单。</p><h2 id="第二步：白色十字的各个棱块的另一个颜色和中心颜色对齐"><a href="#第二步：白色十字的各个棱块的另一个颜色和中心颜色对齐" class="headerlink" title="第二步：白色十字的各个棱块的另一个颜色和中心颜色对齐"></a>第二步：白色十字的各个棱块的另一个颜色和中心颜色对齐</h2><pre><code>1.转动顶层（白色层），直到有两个是和自己的中心对齐2.一个放到左手边，一个对着自己3.右手右边做：上、左、下、右、上4.然后白色十字的另一个颜色就都和自己的中心对好了特殊情况，就是那两个和自己中心对齐的面不相邻，而是相对1.找任意一个对齐的对着自己2.右手右边做：上、左、下、右、上3.转动顶就出现第一种情况，或者就对好了</code></pre><h2 id="第三步：还原白色层角块，还原第一层"><a href="#第三步：还原白色层角块，还原第一层" class="headerlink" title="第三步：还原白色层角块，还原第一层"></a>第三步：还原白色层角块，还原第一层</h2><pre><code>1.白色放底部2.找到顶部（黄色层）含有的白色面的角块3.把它移动到它的另外两个颜色的面的中间（比如白橙蓝的角块，把它转动到中心块是橙色和蓝色的中间）4.做：上、左、下、右，直到这个角块正确</code></pre><h2 id="第四步：还原第二层"><a href="#第四步：还原第二层" class="headerlink" title="第四步：还原第二层"></a>第四步：还原第二层</h2><pre><code>1.把白色层作为底部1.找顶层不含黄色的棱块A2.A对着自己的颜色转到它自己的中心面B，和中心形成一条直线3.A的另一个颜色的中心C应该中B的左右两侧4.如果C在B的右侧，顶层向左转90度，C在B度左侧，则顶层向右转90度5.然后转动C所在的一侧，在右边则做 上、左、下、右，在左边则做：上、右、下、左6.然后让C面对自己，B转到左手边，则左手做：上、右、下、左；B转到右手边则右手做：上、左、下、右（左右手做的动作毎步是一样的）特殊情况，上层都含有黄色棱块：把色块相反的棱块放到右手边，右手做上、左、下、右，把面移到左手边，左手做上、右、下、左</code></pre><h2 id="第三层还原"><a href="#第三层还原" class="headerlink" title="第三层还原"></a>第三层还原</h2><h3 id="第一步：拼黄十字架"><a href="#第一步：拼黄十字架" class="headerlink" title="第一步：拼黄十字架"></a>第一步：拼黄十字架</h3><pre><code>第一种情况，黄色有一条过中心的线，1.把黄色线平行自己，黄色做顶部2.前面的面顺时针转90度3.右手做上左下右4.前面逆时针回去第二种情况，小拐弯1.把小拐弯放到右下角，黄色层做顶部2.前面顺时针转90度3.右手做上左下右4.前面逆时针回去5.直线就出来了第三种情况，上面一个中心点，角上点黄色不算1.随便一面顺时针转90度2.右手做上左下右3.前面度面逆时针回去4.小拐弯出来了</code></pre><h3 id="第二步：小鱼"><a href="#第二步：小鱼" class="headerlink" title="第二步：小鱼"></a>第二步：小鱼</h3><p>黄色十字就出来了，然后需要转出“小鱼”，不是小鱼的有两种情况，一个是少四个黄色点，一种是少两个黄色点</p><pre><code>第一种（少四个点）的情况：1.把不含黄色点的面放到后面2.右手边做：下、右、上、右、下、右、右、上第二种（少两个点）的情况：1.把左后方含有黄色的面放到后面2.右手做：下、右、上、右、下、右、右、上第三步：把上面黄色都拼出来----黄色面1.把鱼头放到左上角，黄色面作为顶部2.右手做：下、右、上、右、下、右、右、上3.上一步如果黄色没出来，就重复1、2，直到出来第四步：调整黄色层角块的边，把每面角块的颜色调一样----黄色角块1.如果四个面的角块颜色，有的一样，有的不一样2.随机找出一个一样的面，作为底部，把黄色面面对自己3.右手做：上、顶右、上、底部右转180度、下、顶左、上、底部右转180度、右边下转1804.每面的角块的颜色就都出来了如果每面的角块都不一样1.任意找一面放到下面，黄色面对着自己2.右手做：上、顶右、上、底部右转180度、下、顶左、上、底部右转180度、右边下转180</code></pre><h3 id="最后一步，还原黄色层所有棱块"><a href="#最后一步，还原黄色层所有棱块" class="headerlink" title="最后一步，还原黄色层所有棱块"></a>最后一步，还原黄色层所有棱块</h3><pre><code>1.把黄色面作为顶部，找到颜色全部一样的面对着自己2.右手做：下，顶左、下、顶右、下、顶右、下、顶左、上、顶左、右边向上180度</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中setState几个现象---先知道再理解</title>
      <link href="/2018/02/28/React%E4%B8%ADsetState%E5%87%A0%E4%B8%AA%E7%8E%B0%E8%B1%A1-%E5%85%88%E7%9F%A5%E9%81%93%E5%86%8D%E7%90%86%E8%A7%A3/"/>
      <url>/2018/02/28/React%E4%B8%ADsetState%E5%87%A0%E4%B8%AA%E7%8E%B0%E8%B1%A1-%E5%85%88%E7%9F%A5%E9%81%93%E5%86%8D%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="常规情况"><a href="#常规情况" class="headerlink" title="常规情况"></a>常规情况</h3><p><strong>在同一个方法中多次 setState 是会被合并的，并且对相同属性的设置只保留最后一次的设置；</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> me = <span class="keyword">this</span>;</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> me = <span class="keyword">this</span>;</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClick() &#123;</span><br><span class="line">    <span class="keyword">let</span> me = <span class="keyword">this</span>;</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1111111111111111111111111111111111111111111"</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="button" value="点击我" onClick=&#123;this.onClick.bind(this)&#125; /</span>&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>上述执行过程如下：</p><ol><li><code>willmount</code>中的<code>setState</code>会合并成一次执行，<code>count</code>只会保留最后一次的设置，前面的放弃，所以<code>willmount</code>之后是<code>1</code>，并不是<code>3</code>；并且在<code>render</code>之前执行，不会引起新的<code>render</code></li><li>render 之后执行 didMount，setState 做同样的处理，这是<code>count</code>是<code>2</code>，并且引起新的 render</li><li>点击按钮，<code>setState</code>做同样处理，<code>count</code>是<code>3</code>，引起新的<code>render</code></li></ol></blockquote><p>###定时器中的 setState<br><strong>定时器中的 setState，每次都会引起新的 render，即使是同一个定时器中的多次 setState</strong></p><p>代码更改成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> me = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        me.setState(&#123;</span><br><span class="line">            count: me.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        me.setState(&#123;</span><br><span class="line">            count: me.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> me = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        me.setState(&#123;</span><br><span class="line">            count: me.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        me.setState(&#123;</span><br><span class="line">            count: me.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onClickTime() &#123;</span><br><span class="line">    <span class="keyword">let</span> me = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        me.setState(&#123;</span><br><span class="line">            count: me.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        me.setState(&#123;</span><br><span class="line">            count: me.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码，每次<code>setState</code>都会引发新的 render，需要深入了解的可以查查<code>setState</code>的原理，简单理解是定时器中的<code>setState</code>没走<code>react</code>的事物机制，执行时批量更新没被设置<code>true</code>，所以每次都直接 render 了。</p></blockquote><h3 id="原生事件中的-setState"><a href="#原生事件中的-setState" class="headerlink" title="原生事件中的 setState"></a>原生事件中的 setState</h3><blockquote><ul><li>在按钮原生事件中定义的<code>setState</code>,和定时器效果一样，<strong>每次<code>setState</code>都会引起新的<code>render</code></strong></li><li>react 事件是合并的成一次 render 的。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">       <span class="keyword">this</span>.button.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>, <span class="string">'原生事件'</span>), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onClick(info) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(info);</span><br><span class="line">       <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">           count: ++count</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">           count: ++count</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   render() &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">       <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">           &lt;input type="button" ref=&#123;input =&gt; this.button = input&#125; onClick=&#123;this.onClick.bind(this, 'React事件')&#125; value="生成计时器" /&gt;</span><br><span class="line">           &lt;div&gt;Count:&#123;this.state.count&#125;&lt;/div&gt;</span><br><span class="line"><span class="xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>点击按钮，先执行原生事件，再执行 react 事件，但是原生事件会触发两次 render，react 事件触发一次。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述是我对 setState 的理解，抛砖引玉，希望帮助大家有方向的去了解 react 原理机制。刚开始接触，很多同学想深入了解，但可能不知道从何入手，这也是我遇到过的困扰，所以现在分享出来，希望能帮助大家少走弯路，更快的、更有准针对性的去研究学习 React。</p><hr><p><strong>以下为补充内容</strong></p><h3 id="原因是什么？"><a href="#原因是什么？" class="headerlink" title="原因是什么？"></a>原因是什么？</h3><blockquote><h4 id="原因是：执行上下文发生了变化。"><a href="#原因是：执行上下文发生了变化。" class="headerlink" title="原因是：执行上下文发生了变化。"></a>原因是：执行上下文发生了变化。</h4><p>在事件执行的时候，<strong>当前上下文</strong>执行的是<code>setTimeout</code>函数，但当执行<code>setTimeout</code>函数的回调时，原来的上下文已经结束了，<strong>回调的上下文变成了 window</strong>，所以依据的批量更新属性<code>isBatchingUpdates</code>没有被设置成<code>true</code>的过程，因此始终是<code>false</code>，因此<code>setState</code>就同步执行了。</p></blockquote><h3 id="回调不会触发-react-的批量更新机制"><a href="#回调不会触发-react-的批量更新机制" class="headerlink" title="回调不会触发 react 的批量更新机制"></a>回调不会触发 react 的批量更新机制</h3><p>其实在回调函数中，setState 是不会触发批量更新机制的，无论是 promise，ajax，setTimeout 回调等等，同时设置多次 setState，每个 setState 都会单独执行并 render，因为上下文发生了变化。</p><p>下面是验证 code</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">onClickBtn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// const promise = new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   this.setState(&#123; count: this.state.count + 1 &#125;);</span></span><br><span class="line">  <span class="comment">//   console.log(this.state.count);</span></span><br><span class="line">  <span class="comment">//   this.setState(&#123; count: this.state.count + 1 &#125;);</span></span><br><span class="line">  <span class="comment">//   console.log(this.state.count);</span></span><br><span class="line">  <span class="comment">//   resolve();</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// promise.then(() =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   this.setState(&#123; count: this.state.count + 1 &#125;);</span></span><br><span class="line">  <span class="comment">//   console.log(this.state.count);</span></span><br><span class="line">  <span class="comment">//   this.setState(&#123; count: this.state.count + 1 &#125;);</span></span><br><span class="line">  <span class="comment">//   console.log(this.state.count);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">"/api/getlist"</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="生命周期和事件中多次-setState-的区别"><a href="#生命周期和事件中多次-setState-的区别" class="headerlink" title="生命周期和事件中多次 setState 的区别"></a>生命周期和事件中多次 setState 的区别</h3><p>在写 demo 时发现，虽然<code>didMount</code>中的多次<code>setState</code>会被合并，符合正常的规律，但是通过调试发现，在<code>didMount</code>中<code>isBatchingUpdates</code>始终是<code>false</code>，而事件调用触发的<code>setState</code>，<code>isBatchingUpdates</code>则是<code>true</code>。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>create-react-app使用less最详细说明20190413</title>
      <link href="/2014/04/13/create-react-app%E4%BD%BF%E7%94%A8less%E6%9C%80%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E20190413/"/>
      <url>/2014/04/13/create-react-app%E4%BD%BF%E7%94%A8less%E6%9C%80%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E20190413/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>创建步骤和官网一致，大家可以查看官网，下面简单列举下.</p><p>创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> my-app/</span><br></pre></td></tr></table></figure><p><code>eject</code>出配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br><span class="line">或者</span><br><span class="line">yarn eject</span><br></pre></td></tr></table></figure><h3 id="安装-less"><a href="#安装-less" class="headerlink" title="安装 less"></a>安装 less</h3><p>less 和 less-loader 都要安装。less 是支持 less 语法的，less-loader 是 webpack 使用来编译 less 的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save</span><br></pre></td></tr></table></figure><h3 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h3><p>修改<code>config/webpack.config.js</code></p><p>新增 less 配置变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cssRegex = <span class="regexp">/\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassRegex = <span class="regexp">/\.(scss|sass)$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassModuleRegex = <span class="regexp">/\.module\.(scss|sass)$/</span>;</span><br><span class="line"><span class="keyword">const</span> lessRegex = <span class="regexp">/\.less$/</span>; <span class="comment">// 新增less配置</span></span><br><span class="line"><span class="keyword">const</span> lessModuleRegex = <span class="regexp">/\.module\.less$/</span>; <span class="comment">// 新增less配置，这个其实不配置也行</span></span><br></pre></td></tr></table></figure><p>增加 module 下面 rule 规则，可以 copy <code>cssRegex</code>或者<code>sassRegex</code>的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: sassModuleRegex,</span><br><span class="line">use: getStyleLoaders(&#123;</span><br><span class="line">importLoaders: <span class="number">2</span>,</span><br><span class="line">sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">modules: <span class="literal">true</span>,</span><br><span class="line">getLocalIdent: getCSSModuleLocalIdent</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"sass-loader"</span></span><br><span class="line">)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">test: lessRegex,</span><br><span class="line">exclude: lessModuleRegex,</span><br><span class="line">use: getStyleLoaders(&#123;</span><br><span class="line">importLoaders: <span class="number">1</span>,<span class="comment">// 值是1</span></span><br><span class="line">modules: <span class="literal">true</span>, <span class="comment">// 增加这个可以通过模块方式来访问css</span></span><br><span class="line">sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"less-loader"</span></span><br><span class="line">),</span><br><span class="line">sideEffects: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 这个测试删了也不影响</span></span><br><span class="line">&#123;</span><br><span class="line">test: lessModuleRegex,</span><br><span class="line">use: getStyleLoaders(&#123;</span><br><span class="line">importLoaders: <span class="number">1</span>,</span><br><span class="line">sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">modules: <span class="literal">true</span>,</span><br><span class="line">getLocalIdent: getCSSModuleLocalIdent</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"less-loader"</span></span><br><span class="line">)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// "file" loader makes sure those assets get served by WebpackDevServer.</span></span><br></pre></td></tr></table></figure><p>需要注意一下几个地方：</p><p>1.<code>lessRege</code>x 中 importLoaders 的值为 1</p><blockquote><p>当然这个是 2 也能使用，但是它的值是根据 lessRegex 变量后面正则中匹配的 loader 数来决定的，比如<code>const cssRegex = /\.css$/</code>只是处理 css 一种类型的文件，那应该就是 1；<code>const sassRegex = /\.(scss|sass)$/;</code>对应的是 scss 和 sass 两种类型，那就应该是 2.</p></blockquote><p>2.<code>lessRegex</code>的<code>use</code>中增加 modules 配置</p><blockquote><p>modules 可以不设置，不设置的话，less 只能通过字符串名的方式使用，比如定义了一个<code>.title</code>,引用时<code>import &#39;./index.less&#39;</code>，使用时：<code>&lt;div className=&quot;title&quot;&gt;&lt;/div&gt;</code></p></blockquote><blockquote><p>如果需要通过<strong>模块</strong>的方式调用，则需要把 modules 设置成 true，就可以通过<code>styles.title</code>方式使用了。<code>import styles from &#39;./index.less&#39;</code>,使用<code>&lt;div className={styles.title}&gt;&lt;/div&gt;</code></p></blockquote><h3 id="第二种配置方式"><a href="#第二种配置方式" class="headerlink" title="第二种配置方式"></a>第二种配置方式</h3><p>可以不增加新的变量，把 css 的配置包含 less</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cssRegex = <span class="regexp">/\.(css|less)$/</span>; <span class="comment">//增加less</span></span><br><span class="line"><span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.(css|less)$/</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">test: cssRegex,</span><br><span class="line">exclude: cssModuleRegex,</span><br><span class="line">use: getStyleLoaders(&#123;</span><br><span class="line">importLoaders: <span class="number">2</span>,<span class="comment">// 改成2</span></span><br><span class="line">            modules: <span class="literal">true</span>,<span class="comment">//使用模块方式访问样式</span></span><br><span class="line">sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"less-loader"</span> <span class="comment">//增加loader</span></span><br><span class="line">),</span><br><span class="line"><span class="comment">// Don't consider CSS imports dead code even if the</span></span><br><span class="line"><span class="comment">// containing package claims to have no side effects.</span></span><br><span class="line"><span class="comment">// Remove this when webpack adds a warning or an error for this.</span></span><br><span class="line"><span class="comment">// See https://github.com/webpack/webpack/issues/6571</span></span><br><span class="line">sideEffects: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全文完！！！2019-04-13</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> create-react-app </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
